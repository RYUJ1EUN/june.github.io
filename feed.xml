<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ryuj1eun.github.io/june.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ryuj1eun.github.io/june.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-02-21T03:56:37+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/feed.xml</id><title type="html">June</title><subtitle>PhD student&apos;s blog in Cryptography focusing on RNG, PQC, and WBC. </subtitle><entry><title type="html">KpqC íŠ¹ê°• ì •ë¦¬</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2026/pqc/" rel="alternate" type="text/html" title="KpqC íŠ¹ê°• ì •ë¦¬"/><published>2026-02-19T00:00:00+00:00</published><updated>2026-02-19T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2026/pqc</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2026/pqc/"><![CDATA[<p>ğŸ·ï¸(2025ë…„ë„ ìƒë°˜ê¸°) ì •ë³´ë³´í˜¸ ì „ë¬¸ê°€ë¥¼ ìœ„í•œ ì•”í˜¸êµìœ¡, 2025.05.<br/> ìµœí˜•ë¯¼, â€œê³µê°œí‚¤ ì•”í˜¸ ê¸°ì´ˆâ€, CryptoLab, inc. </p> <h4 id="game-based-security">Game-based Security</h4> <p>ë¹„ë°€ ì •ë³´ë¥¼ ì§€ë‹Œ Challengerì™€ ê·¸ ë¹„ë°€ì„ íƒˆì·¨í•˜ë ¤ëŠ” Attacker ê°„ì˜ ì‹¸ì›€ì„ ëª¨ë¸ë§í•œ ê²ƒ</p> <h5 id="attacker-adversary">Attacker (Adversary)</h5> <ul> <li> <p>ê³µê°œ ì •ë³´ íšë“ ê°€ëŠ¥</p> </li> <li>ê³µê²©ìì˜ ëŠ¥ë ¥ì´ íŠ¹ì • ì˜¤ë¼í´ í˜•íƒœë¡œ ì œí•œë¨</li> <li>ê³µê²©ìì˜ ëª¨ë“  í–‰ë™ì€ ë‹¤í•­ì‹ ì‹œê°„ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í‘œí˜„ë˜ì–´ì•¼ í•¨</li> </ul> <h5 id="pkekem-ì•ˆì „ì„±-ì •ì˜">PKE/KEM ì•ˆì „ì„± ì •ì˜</h5> <ul> <li>ê³µê²©ìëŠ” íŠ¹ì • ë©”ì‹œì§€ì— ëŒ€í•œ ìº¡ìŠí™”ë¥¼ í•  ìˆ˜ ìˆìŒ</li> <li>ê³µê²©ìëŠ” íŠ¹ì • ì•”í˜¸ë¬¸ì— ëŒ€í•œ ë³µí˜¸í™”ë¥¼ <ul> <li>í•  ìˆ˜ ì—†ìŒ: IND-CPA</li> <li>í•  ìˆ˜ ìˆìŒ: IND-CCA1</li> <li>ì•”í˜¸ë¬¸ì„ ì¶”ì¸¡í•˜ì—¬ ì•”í˜¸í™”, ë³µí˜¸í™”ë¥¼ í•  ìˆ˜ ìˆìŒ: IND-CCA2</li> </ul> </li> <li>$\text{Adv}^{\text{IND-win}}({\cal A}) \ge \frac{1}{2}$ì¼ ë•Œ ì•ˆì „í•˜ë‹¤ê³  í•¨ <ul> <li>$\text{Adv}^{\text{IND}}({\cal A}) = \Pr[\text{Exp}^{\text{IND-1}}(A)=1]-\Pr[\text{Exp}^{\text{IND-0}}({\cal A})=1]$</li> <li>$\Pr[\text{Exp}^{\text{IND-1}}({\cal A})=1]-\Pr[\text{Exp}^{\text{IND-0}}({\cal A})=1] &lt; \epsilon$ (ê³µê²©ìê°€ 0,1ì„ êµ¬ë³„í•  ìˆ˜ ì—†ìŒ)</li> <li>$\text{Adv}^{\text{IND-win}}({\cal A}) = \frac{1}{2}\left( \text{Adv}^{\text{IND}}({\cal A}) +1\right)$</li> </ul> </li> </ul> <h5 id="ì „ìì„œëª…ì˜-ì•ˆì „ì„±-ì •ì˜">ì „ìì„œëª…ì˜ ì•ˆì „ì„± ì •ì˜</h5> <ul> <li>ê³µê²©ìëŠ” íŠ¹ì • ì„œëª…ì— ëŒ€í•œ ê²€ì¦ì„ ìš”ì²­í•  ìˆ˜ ìˆìŒ</li> <li>ê³µê²©ìëŠ” íŠ¹ì • ë©”ì‹œì§€ì— ëŒ€í•œ ì„œëª…ì„ <ul> <li>ìš”ì²­í•  ìˆ˜ ì—†ìŒ: UF-NMA</li> <li>ìš”ì²­í•  ìˆ˜ ìˆìŒ: UF-CMA</li> <li>ë™ì¼ ë©”ì‹œì§€ì— ëŒ€í•œ ë°˜ë³µ ì„œëª…ì„ ìš”ì²­í•  ìˆ˜ ìˆìŒ: SUF-CMA</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="Study"/><category term="Cryptography"/><category term="PQC"/><summary type="html"><![CDATA['2025ë…„ë„ ìƒë°˜ê¸° ì •ë³´ë³´í˜¸ ì „ë¬¸ê°€ë¥¼ ìœ„í•œ ì•”í˜¸êµìœ¡' íŠ¹ê°• ë‚´ìš© ì •ë¦¬]]></summary></entry><entry><title type="html">Secret Sharing</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2026/ss/" rel="alternate" type="text/html" title="Secret Sharing"/><published>2026-02-13T00:00:00+00:00</published><updated>2026-02-13T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2026/ss</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2026/ss/"><![CDATA[<p>ğŸ“– Adi Shamir, â€œHow to Share a Secretâ€, Communications of the ACM, Vol.22, No.11, 1979.</p> <p>This technique enables the construction of robust key management schemes for cryptographic systems that can function securely and reliably even when misfortunes destroy half the pieces and security breaches expose all but one of the remaining pieces.</p> <ol> <li> <p>knowledge of any $k$ or more $D_i$ pieces makes $D$ easily computable;</p> </li> <li> <p>knowledge of any $k-1$ or fewer $D_i$ pieces leaves $D$ completely undetermined (in the sense that all its possible values are equally likely)</p> </li> </ol> <p>By using a $(k,n)$ threshold scheme with $n=2k-1$ we get a very robust key management scheme:</p> <p>our opponents cannot reconstruct the key even when security breaches expose $\lfloor n/2 \rfloor = k-1$ of the remaining $k$ pieces.</p> <p>Our scheme is based on polynomial interpolation:</p> <p>Knowledge of just $k-1$ of these values, on the other hand, does not suffice in order to calculate $D$.</p> <p>Let us now assume that $k-1$ of these $n$ pieces are revealed to an opponent. For each candidate value $Dâ€™$ in $[0, p)$ he can construct one and only one polynomial $qâ€™(x)$ of degree $k- 1$ such that $qâ€™(0) =Dâ€™$ and $qâ€™(i) =D_i$ for the $k- 1$ given arguments. By construction, these $p$ possible polynomials are equally likely, and thus there is absolutely nothing the opponent can deduce about the real value of $D$.</p> <p>the smallest usable value of $p$ is $n + 1$ (there must be at least $n + 1$ distinct arguments in $[0, p)$ to evaluate $q(x)$ at).</p> <hr/> <p>ğŸ“– Katz, Jonathan, and Yehuda Lindell.Â <em>Introduction to modern cryptography: principles and protocols</em>. Chapman and Hall/CRC, 2007.</p> <p>ğŸ“– Silverman, Joseph H., Jill Pipher, and Jeffrey Hoffstein.Â <em>An introduction to mathematical cryptography</em>. Vol. 1. Springer New York, 2008.</p> <h3 id="secret-sharing-schemes">Secret Sharing Schemes</h3> <p>A Secret Sharing Scheme (SSS) provides a way of sharing a secret among several people.</p> <p>In a true secret sharing scheme among a group of $n$ people, no subgroup of $n-1$ people should be able to gain an advantage in discovering the secret.</p> <h4 id="sss-for-n-participants">SSS for $n$ participants</h4> <p>For example, to share a secret $S\bmod m$ among $n$ people, select $n-1$ random numbers</p> \[s_1,\ s_2,\ \ldots,\ s_{n-1}\mod m,\] <p>and set</p> \[s_n\equiv S -s_1- s_2- \cdots- s_{n-1}\mod m\] <p>or simply</p> \[s_n := S \oplus (\bigoplus_{i=1}^{n-1} s_i)\] <p>over the binary vector space.</p> <p>The $i$th participant receives the value of $s_i$, and it requires all $n$ values to recover the secret</p> \[S\equiv s_1+ s_2+ \cdots+ s_{n-1}+ s_n\mod m.\] <p>and</p> \[S = \bigoplus_{i=1}^{n} s_i\] <h4 id="sss-for-t-participants-among-n-people">SSS for $t$ participants among $n$ people</h4> <p>Suppose that we want to share a secret among $n$ people in such a way that any $t$ of them can recover the secret, but no $t-1$ of them can do so: $(t, n)$ threshold sharing schemes, where $t$ is the threshold of the scheme.</p> <h5 id="when-does-it-need">When does it need?</h5> <p>A nuclear-launch code: Any $t$ users should be able to pool their shares and reconstruct the secret, but no coalition of fewer than $t$ users should get any information about $s$ from their collective shares (beyond whatever information they had about $s$ already).</p> <h5 id="shamirs-sss">Shamirâ€™s SSS</h5> <ul> <li> <p><strong>COROLLARY</strong> Any two distinct degree-$t$ polynomials $f$ and $g$ agree on at most $t$ points.</p> <p><strong>PROOF</strong> If not, then the nonzero, degree-$t$ polynomial $f âˆ’ g$ would have more than $t$ roots.</p> </li> </ul> <p>Shamirâ€™s scheme relies on the fact that for any $t$ pairs of elements $(x_1, y_1),â€¦, (x_t, y_t)$ from $\mathbb F$ (with the ${x_i}$ distinct), there is a unique polynomial $f$ of degree $t âˆ’ 1$ such that $f(x_i) = y_i$ for $1\le i\le t$.</p> <p>We can prove this quite easily.</p> <p>It takes $k+1$ values to determine a polynomial of degree $k$.</p> <p>Set $a_0=S$, choose random number $a_1, a_2, â€¦, a_{t-1}$, and form the polynomial</p> \[f(x) = a_0+a_1 x+a_2 x^2 +\cdots+a_{t-1} x^{t-1}.\] <p>Next, we choose $n$ random values for $x$, say $x_1, x_2, â€¦, x_n$, and compute</p> \[y_i = f(x_i)\qquad\text{for }\ 1\le i\le n.\] <p>The $i$th participant is given the value $y_i$.</p> <p>After sharing their $y_i$, these $t$ participants can form the following system of equations:</p> \[\begin{aligned} y_1 &amp;= f(x_1) = a_0 + a_1 x_1 + a_2 x_1^2 + \cdots + a_{t-1} x_1^{t-1}\\ y_2 &amp;= f(x_2) = a_0 + a_1 x_2 + a_2 x_2^2 + \cdots + a_{t-1} x_2^{t-1}\\ \vdots &amp; \qquad\qquad\qquad\qquad\qquad\quad\vdots \\ y_t &amp;= f(x_t) = a_0 + a_1 x_t + a_2 x_t^2 + \cdots + a_{t-1} x_t^{t-1} \end{aligned}\] <p>The participants know all of the $x_i$ and $y_i$ values, so they know this system of $t$ linear equations for the $t$ unknown $a_0, a_1, â€¦,a_{t-1}$.</p> <p>They can solve the system using Gaussian elimination to find the $a_j$ and thus recover the secret $a_0=S$.</p> <p>In practice, a more efficient way to reconstruct $f(x)$ is to use what are known as Lagrange interpolation polynomials.</p> <p>In detail: for $i = 1, â€¦ , t$, define the degree-$(t âˆ’ 1)$ polynomial</p> \[â\] <p>Note that $\delta_i(x_j)=0$ for any $j \neq i$, and $\delta_i(x_i)=1$.</p> <p>So</p> \[f(X) \stackrel{\text{def}}{=} \sum_{i=1}^t \delta_i(X) \cdot y_i\] <p>is a polynomial of degree $(t âˆ’ 1)$ with $f(x_i) = y_i$ for $1 \le i \le t$.</p> <p>Uniqueness follows from <strong>COROLLARY</strong>.</p> <table> <tbody> <tr> <td>Let $\mathbb F$ be a finite field that contains the domain of possible secrets, and with $</td> <td>{\mathbb F}</td> <td>&gt; N$.</td> </tr> </tbody> </table> <p>Let $x_1, â€¦ ,x_n \in \mathbb F$ be distinct, nonzero elements that are fixed and publicly known. (Such elements exist since $|{\mathbb F}| &gt; N$.)</p> <p>The scheme works as follows:</p> <ul> <li> <p>Sharing</p> <p>Given a secret $s \in\mathbb F$, the dealer chooses uniform $a_1, â€¦ ,a_{tâˆ’1}\in\mathbb F$ and defines the polynomial</p> \[f(X) \stackrel{\text{def}}{=} s + \sum_{i=1}^{t-1} a_i X^i\] <p>This is a uniform degree-$(t âˆ’ 1)$ polynomial with constant term $s$.</p> <p>The share of user $P_i$ is $s_i := f(x_i) \in\mathbb F$.</p> </li> <li> <p>Reconstruction</p> <p>Say $t$ users $P_{i_1}, â€¦ ,P_{i_t}$ pool their shares $s_{i_1}, â€¦ , s_{i_t}$.</p> <p>Using polynomial interpolation, they compute the unique degree-$(t âˆ’ 1)$ polynomial $fâ€™$ for which</p> \[f'(x_{i_j}) = s_{i_j} \qquad\text{for }\ 1 \le j \le t.\] <p>The secret is $fâ€™(0)$.</p> <p>It is clear that reconstruction works since $fâ€™=f$ and $f(0) = s$.</p> </li> </ul> <p>It remains to show that any $t âˆ’ 1$ users learn nothing about the secret $s$ from their shares.</p> <h3 id="verifiable-secret-sharing">Verifiable Secret Sharing</h3> <p>We are also concerned about active, malicious behavior.</p> <p>There are two separate concerns:</p> <ul> <li>First, a corrupted dealer may give inconsistent shares to the users, i.e., such that different secrets are recovered depending on which $t$ users pool their shares.</li> <li> <p>Second, in the reconstruction phase, a malicious user may present a different share from the one given to them by the dealer, and thus affect the recovered secret.</p> <p>(While this could be addressed by having the dealer sign the shares, this does not work when the dealer itself may be dishonest.)</p> </li> </ul> <p>Verifiable secret-sharing (VSS) schemes prevent both these attacks.</p> <p>More formally, we allow any $t-1$ users to be corrupted and to collude with each other and, possibly, the dealer.</p> <p>We require:</p> <ol> <li> <p>at the end of the sharing phase, a secret $s$ is defined such that any set of users that includes $t$ uncorrupted users will successfully recover $s$ in the reconstruction phase;</p> <p>moreover,</p> </li> <li> <p>if the dealer is honest, then $s$ corresponds to the dealerâ€™s secret.</p> </li> </ol> <p>In addition,</p> <ol> <li>when the dealer is honest, then, as before, any set of $t-1$ corrupted users learns nothing about the secret from their shares and any public information the dealer publishes.</li> </ol> <p>Since we want there to be $t$ uncorrupted users even if $t-1$ users are corrupted, we require $n\ge t+(t-1)$ or $n&gt;2t$;</p> <p>in other words, we assume a majority of the users remain uncorrupted.</p> <p>Let $H$ denote a function to be modeled as a random oracle.</p> <p>We also assume that some trusted parameters $({\mathbb G}, q, g)$, generated using ${\mathcal G}(1^n)$, are published in advance, where $q$ is prime and so $\mathbb{Z}_q$ is a field.</p> <p>Finally, we assume that all users have access to a broadcast channel, such that a message broadcast by any user is heard by everyone.</p> <p>The sharing phase now involves the $N$ users running an interactive protocol with the dealer that proceeds as follows:</p> <ol> <li> <p>To share a secret $s$, the dealer chooses uniform $a_0 \in \mathbb{Z}_q$ and then shares $a_0$ as in Shamirâ€™s scheme.</p> <p>That is, the dealer chooses uniform $a_1,â€¦,a_{t-1}\in\mathbb{Z}_q$ and defines the polynomial</p> \[f(X) \stackrel{\text{def}}{=} \; \sum_{j=0}^{t-1} a_j X^j.\] <p>The dealer sends the share</p> \[s_i = f(x_i) =\; \sum_{j=0}^{t-1} a_j x_i^j.\] <p>In addition, the dealer publicly broadcasts the values $A_0:= g^{a_0}, â€¦ ,A_{t-1}:= g^{a_{t-1}}$, and the â€œmasked secretâ€ $c := H(a_0)\oplus s$.</p> </li> <li> <p>Each user $P_i$ verifies that its share $s_i$ satisfies</p> \[g^{s_i} = \prod_{j=0}^{t-1} (A_j)^{i^j}.\] <p>If not, $P_i$ publicly broadcasts a complaint.</p> <p>Note that if the dealer is honest, we have</p> \[\prod_{j=0}^{t-1} (A_j)^{i^j} = \prod_{j=0}^{t-1} (g^{a_j})^{i^j} = g^{\sum_{j=0}^{t-1} a_j \cdot i^j} = g^{p(i)} = g^{s_i},\] <p>and so no honest user will complain. Since there are at most $t âˆ’ 1$ corrupted users, there are at most $tâˆ’1$ complaints if the dealer is honest.</p> </li> <li> <p>If more than $tâˆ’1$ users complain,</p> <p>the dealer is disqualified and the protocol is aborted.</p> <p>Otherwise, the dealer responds to a complaint from $P_i$ by broadcasting $s_i$.</p> <ol> <li>If this share does not satisfy Equation (or if the dealer refuses to respond to a complaint at all), the dealer is disqualified and the protocol is aborted.</li> <li>Otherwise, $P_i$ uses the broadcast value (rather than the value it received in the first round) as its share.</li> </ol> </li> </ol> <p>In the reconstruction phase, say a group of users (that includes at least $t$ uncorrupted users) pool their shares. A share $s_i$ provided by a user $P_i$ is discarded if it does not satisfy Equation. Among the remaining shares, any $t$ of them are used to recover $a_0$ exactly as in Shamirâ€™s scheme. The original secret is then computed as $s = c \oplus H(a_0)$.</p> <p>Combined with the fact that an honest dealer is never disqualified, this proves that conditions (1a) and (1b) hold.</p> <p>Define $a_i := \log_g A_i$ for $0 \le i \le t-1$; the ${a_i}$ cannot be computed efficiently if the discrete-logarithm problem is hard, but they are still well-defined. Define the polynomial $p(X) \stackrel{\text{def}}{=}\sum_{i=0}^{t-1} a_i X^i$.</p> <p>Any share $s_i$, contributed by party $P_i$, that is not discarded during the reconstruction phase must satisfy Equation, and hence satisfies $s_i = p(i)$. It follows that, regardless of which shares are used, the parties will reconstruct polynomial $p$, compute $a_0 = p(0)$, and then recover $s = c \oplus H(a_0)$.</p> <p>It is also possible to show that condition (2) holds for computationally bounded adversaries if the discrete-logarithm problem is hard for $\mathcal G$. (In contrast to Shamirâ€™s secret-sharing scheme, secrecy here is no longer unconditional. Unconditionally secure VSS schemes are possible, but are beyond the scope of our treatment.) Intuitively, this is because the secret $s$ is masked by the random value $H(a_0)$, and the information given to any $t âˆ’ 1$ users in the sharing phaseâ€”namely, their shares and the public values ${A_i}$â€”reveals only $g^{a_0}$, from which it is hard to compute $a_0$. This intuition can be made rigorous, but we do not do so here.</p>]]></content><author><name></name></author><category term="Study"/><category term="Cryptography"/><category term="SS"/><summary type="html"><![CDATA[Paper review regarding the secret sharing]]></summary></entry><entry><title type="html">AIS 31 (version 3.0)</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2026/ais31/" rel="alternate" type="text/html" title="AIS 31 (version 3.0)"/><published>2026-02-12T00:00:00+00:00</published><updated>2026-02-12T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2026/ais31</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2026/ais31/"><![CDATA[<p>AIS 31 (version 3.0) 4.2.1.</p> <iframe src="/june.github.io/assets/pdf/AIS31.pdf" width="100%" height="800px" style="border: none;"> PDF ë¯¸ë¦¬ë³´ê¸°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. <a href="/june.github.io/assets/pdf/AIS31.pdf">ì—¬ê¸°</a>ë¥¼ í´ë¦­í•´ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”. </iframe>]]></content><author><name></name></author><category term="Study"/><category term="Cryptography"/><category term="RNG"/><category term="MATH"/><summary type="html"><![CDATA[Study note: AIS 31 (version 3.0)]]></summary></entry><entry><title type="html">NTT ML-KEM</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2025/ntt-ml-kem/" rel="alternate" type="text/html" title="NTT ML-KEM"/><published>2025-12-16T00:00:00+00:00</published><updated>2025-12-16T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2025/ntt-ml-kem</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2025/ntt-ml-kem/"><![CDATA[<p>ğŸ“š <strong>[MAIN]</strong> Liang, Zhichuang, and Yunlei Zhao. â€œNumber theoretic transform and its applications in lattice-based cryptosystems: A survey.â€Â <em>arXiv preprint arXiv:2211.13546</em>Â (2022).<br/> ğŸ“š <strong>[Sub 1]</strong> Pollard, John M. â€œThe fast Fourier transform in a finite field.â€Â <em>Mathematics of computation</em>Â 25.114 (1971): 365-374.<br/> ğŸ“š <strong>[Sub 2]</strong> Agarwal, Ramesh C., and C. Sidney Burrus. â€œNumber theoretic transforms to implement fast digital convolution.â€Â <em>Proceedings of the IEEE</em>Â 63.4 (2005): 550-560.<br/> ğŸ“š <strong>[Sub 3]</strong> FÃ¼rer, Martin. â€œFaster integer multiplication.â€Â <em>Proceedings of the thirty-ninth annual ACM symposium on Theory of computing</em>. 2007.<br/> ğŸ“š <strong>[Sub 4]</strong> Fraleigh, John B.Â <em>A first course in abstract algebra</em>. Pearson Education India, 2003.</p> <hr/> <h3 id="ml-kemcrystals-kyber">ML-KEM(CRYSTALS-Kyber)</h3> <p>Kyber is an IND-CCA secure MLWE-based KEM from the lattice-based cryptography suite called â€œCryptographic Suite for Algebraic Lattices (CRYSTALS)â€.</p> <p>The Kyber uses a ring $\mathbb{Z}_q[x]/(x^n + 1)$ with $n = 256$ and $q = 3329$, which no longer satisfy $q \equiv 1 \pmod{2n}$, but $q \equiv 1 \pmod{n}$.</p> <h3 id="preliminary">Preliminary</h3> <h4 id="primitive-and-principal-root-of-unity">Primitive and Principal Root of Unity</h4> <p>Define $\psi$ is the primitive $k$-th root of unity in ring $R$</p> <p>$\iff$ $\psi^k=1$, and $\psi^i\neq 1,\; i=1,2,\ â€¦\,,\ k-1$.</p> <p>(i.e., $k$ is the least positive integer s.t. $\psi^k = 1$)</p> <h5 id="cyclotomic-polynomial">Cyclotomic polynomial</h5> <p>$n$-th cyclotomic polynomial $\phi_n(x)$ëŠ” primitive $n$-th roots of unityë“¤ë§Œì„ ê·¼ìœ¼ë¡œ ê°–ëŠ” ìµœê³ ì°¨í•­ ê³„ìˆ˜ê°€ 1ì¸ ë‹¤í•­ì‹ì„</p> \[\phi_n(x)=\prod_{1\le k&lt;n,\\[1em] \gcd(k,n)=1}(x-e^{2\pi ki/n})\] <h5 id="2n-th-cyclotomic-polynomial">2n-th cyclotomic polynomial</h5> <p>Let $n$ be a power of two, then $x^n +1$ is the $2n$-th cyclotomic polynomial.</p> <p>ì¦‰, $x^n +1$ì€ primitive $2n$-th roots of unityë“¤ë§Œì„ ê·¼ìœ¼ë¡œ ê°–ëŠ” ë‹¤í•­ì‹ì„</p> <h4 id="convolution">Convolution</h4> <ul> <li> <p><strong>Cyclic</strong> convolution</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n - 1)$, then</p> \[\boldsymbol{c} = \sum_{k=0}^{n-1} c_k x^k,\] \[\text{where } c_k = \sum_{i=0}^k a_i b_{k-i} + \sum_{i=k+1}^{n-1} a_i b_{n+k-i} \bmod q\quad (k = 0, 1, \dots, n - 1).\] <p>And $\boldsymbol{c}$ is referred to as the cyclic convolution (CC for short) of $\boldsymbol{a}$ and $\boldsymbol{b}$.</p> </li> <li> <p><strong>Negative wrapped</strong> convolution</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n + 1)$, then</p> \[\boldsymbol c = \sum_{k=0}^{n-1} c_k x^k,\] \[\text{where } c_k = \sum_{i=0}^k a_i b_{k-i} - \sum_{i=k+1}^{n-1} a_i b_{n+k-i} \bmod q \quad (k = 0, 1, \dots, n - 1).\] <p>Here, $\boldsymbol{c}$ is referred to as their negative wrapped convolution (NWC for short).</p> <p>â€» $x^{n+k} = x^n \cdot x^k \equiv \mathbf{(-1)} \cdot x^k = -x^k$</p> </li> </ul> <h3 id="ntt">NTT</h3> <h4 id="cyclic-convolution-based-ntt">Cyclic Convolution-based NTT</h4> <p>$n$-point CC-based NTT has two parameters.</p> <ul> <li>The length or the point $n$, where $n$ is a power of two.</li> <li> <p>The modulus $q$, where $q$ is a prime number satisfying $q \equiv 1 \pmod n$.</p> </li> <li> <p>It implies that the primitive $n$-th root of unity $\omega_n$ in $\mathbb{Z}_q$ exists.</p> <p>$\mathbb{Z}_q$ê°€ ì†Œìˆ˜ $q$ì— ëŒ€í•œ Fieldì´ë¯€ë¡œ,</p> <p>0ì„ ì œì™¸í•œ ê³±ì…ˆêµ° $\mathbb{Z}_q^* = {1, 2, \dots, q-1}$ì€ order$\,=q-1$ì¸ groupì´ë‹¤.</p> <p>$\mathbb{Z}_q$ì˜ ê³±ì…ˆêµ° $\mathbb{Z}_q^*$ëŠ” í•­ìƒ cyclic groupì´ë¯€ë¡œ,</p> <p>ì–´ë–¤ generator $g$ê°€ ì¡´ì¬í•˜ì—¬ $\mathbb{Z}_q^* = { g^1, g^2, \dots, g^{q-1} }$ì´ë‹¤.</p> <p>ì´ë•Œ $q \equiv 1 \pmod n$ì´ë¯€ë¡œ $n \mid (q-1)$ì´ê³ ,</p> <p>ë”°ë¼ì„œ $\mathbb{Z}_q$ì—ëŠ” order$\,=n$ì¸ cyclic subgroupì˜ generatorê°€ ì¡´ì¬í•œë‹¤.</p> <p>order$\,=n$ì¸ $x\in\mathbb{Z}_q$ëŠ” ë‹¤ìŒì„ ë§Œì¡±í•œë‹¤.</p> <ul> <li>$x^n \equiv 1 \pmod q$</li> <li>$0 &lt; k &lt; n$ ì¸ ëª¨ë“  $k$ì— ëŒ€í•´ $x^k \not\equiv 1 \pmod q$</li> </ul> <p>ì¦‰, $x$ëŠ” primitive $n$-th root of unityì´ë‹¤.</p> <p>ë”°ë¼ì„œ ì†Œìˆ˜ $q$ì— ëŒ€í•´ $q \equiv 1 \pmod n$ì´ë¼ë©´, $\mathbb{Z}_q$ì—ëŠ” primitive $n$-th root of unity <strong>$\omega_n$</strong>ê°€ ì¡´ì¬í•˜ë©°,</p> <p>íŠ¹íˆ, $\phi(n)$ê°œë§Œí¼ ì¡´ì¬í•œë‹¤.</p> </li> </ul> <p>The forward transform, denoted by NTT, is defined as: $\hat{\boldsymbol{a}} = \text{NTT}(\boldsymbol{a})$, where</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \omega_n^{ij} \bmod q \quad (j = 0, 1, \dots, n - 1).\] <ul> <li> <p>NTTì˜ matrix í‘œí˜„</p> \[NTT=\begin{bmatrix} \omega^{0\times0} &amp;\cdots &amp; \omega^{0\times j} &amp;\cdots&amp; \omega^{0\times(n-1)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\ \omega^{i\times0} &amp;\cdots &amp; \omega^{i\times j} &amp;\cdots&amp; \omega^{i\times(n-1)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\ \omega^{(n-1)\times0} &amp;\cdots &amp; \omega^{(n-1)\times j} &amp;\cdots&amp; \omega^{(n-1)\times(n-1)}\\ \end{bmatrix}\] </li> </ul> <p>The inverse transform, denoted by INTT, is defined as $\boldsymbol{a} = \text{INTT}(\hat{\boldsymbol{a}})$, where</p> \[a_i = n^{-1} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q \quad (i = 0, 1, \dots, n - 1).\] <ul> <li> <p>INTTì˜ matrix í‘œí˜„</p> \[\begin{aligned} NTT^{-1}&amp;=\frac{1}{n}\begin{bmatrix} \;\omega^{-[0\times0]} &amp;\cdots &amp; \omega^{-[0\times j]} &amp;\cdots&amp; \omega^{-[0\times(n-1)]}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \;\omega^{-[i\times0]} &amp;\cdots &amp; \omega^{-[i\times j]} &amp;\cdots&amp; \omega^{-[i\times(n-1)]}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \;\omega^{-[(n-1)\times0]} &amp;\;\;\cdots\;\; &amp; \omega^{-[(n-1)\times j]} &amp;\cdots&amp; \omega^{-[(n-1)\times(n-1)]}\; \end{bmatrix}\\ &amp; =\frac{1}{n}\begin{bmatrix} \omega^{[0\times0] + (n/2)} &amp;\cdots &amp; \omega^{[0\times j] + (n/2)} &amp;\cdots&amp; \omega^{[0\times(n-1)] + (n/2)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \omega^{[i\times0] + (n/2)} &amp;\cdots &amp; \omega^{[i\times j] + (n/2)} &amp;\cdots&amp; \omega^{[i\times(n-1)] + (n/2)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \omega^{[(n-1)\times0] + (n/2)} \!\!\!\!&amp;\cdots &amp; \!\!\!\!\omega^{[(n-1)\times j] + (n/2)} \!\!\!\!&amp;\cdots&amp;\!\!\!\! \omega^{[(n-1)\times(n-1)] + (n/2)}\\ \end{bmatrix} \end{aligned}\] </li> </ul> <p>Note that the inverse transform can be implemented by replacing the $\omega_n$ in NTT procedure with $\omega_n^{-1}$, followed by multiplying by a scale factor $n^{-1}$.</p> <h5 id="prop-cyclic-convolution-property">Prop) Cyclic Convolution Property</h5> <p>Let $\boldsymbol{c}$ be the cyclic convolution of $\boldsymbol{a}$ and $\boldsymbol{b}$, then it holds that</p> \[\text{NTT}(\boldsymbol{c}) = \text{NTT}(\boldsymbol{a}\cdot\boldsymbol{b}) = \text{NTT}(\boldsymbol{a}) \circ \text{NTT}(\boldsymbol{b}).\] <h4 id="negative-wrapped-convolution-based-ntt">Negative Wrapped Convolution-based NTT</h4> <p>The modulus $q$ is set to be a prime number satisfying $q \equiv 1 \pmod{2n}$ such that</p> <ul> <li> <p>the primitive $2n$-th root of unity $\psi_{2n}$ in $\mathbb{Z}_q$ exists.</p> <p>[ì™œ $2n$-th root of unityë¥¼ êµ¬í•˜ëŠ”ê°€?]</p> <p>Negative Wrapped Convolutionì€ $\mathbb{Z}_q[x]/(x^n+1)$ì—ì„œ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ $x^n \equiv -1$ê°€ ë˜ëŠ” $x$ë¥¼ êµ¬í•´ì•¼ í•œë‹¤.</p> <p><code class="language-plaintext highlighter-rouge">n-th primitive roots of unityëŠ” x^n=1ì´ë¯€ë¡œ êµ¬í•˜ê³ ì í•˜ëŠ” ê·¼ì´ ì•„ë‹˜</code></p> <p>ì´ë•Œ $x$ëŠ” $x^{2n} \equiv 1$ì´ë¯€ë¡œ $q \equiv 1 \pmod{2n}$ë¡œ ì„¤ì •í•˜ë©´,</p> <p>$(\psi_{2n}^{n})^2\equiv 1\implies \psi_{2n}^{n}\equiv -1$ì¸ primitive $2n$-th root of unity $\psi_{2n}\in\mathbb{Z}_q$ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤.</p> <p>ì´ë•Œ, $\psi_{2n}$ëŠ” primitiveì´ë¯€ë¡œ $k&lt;2n$ì— ëŒ€í•˜ì—¬ $\psi_{2n}^k\neq 1$ì´ë¯€ë¡œ $\psi_{2n}^n\equiv1$ì´ë‹¤.</p> <p>â€» $\mathbb{Z}_{q}[x]/(x^{2n}-1)$ì˜ primitive $2n$-th roots of unity $\psi_{2n}$</p> <p>ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬ì— ì˜í•´</p> \[\mathbb{Z}_q[x]/(x^{2n}-1) \;\cong\; \underbrace{\,\mathbb{Z}_q[x]/(x^n-1)}_{\text{Cyclic Convolution}} \;\times \; \underbrace{\,\mathbb{Z}_q[x]/(x^n+1)}_{\text{Negative Wrapped}}\] <p>ì´ê³ , $\mathbb{Z}_{q}[x]/(x^{2n}-1)$ì—ì„œ êµ¬í•œ $2n$ê°œ ê·¼ì€ ${ \psi_{2n}^0, \psi_{2n}^1, \psi_{2n}^2, \dots, \psi_{2n}^{2n-1} }$ì´ë‹¤.</p> <p>ì´ë•Œ, $k=0,1,\,â€¦\,,n-1$ì— ëŒ€í•˜ì—¬ $\psi_{2n}^{2k}$ëŠ”</p> \[(\psi_{2n}^{2k})^n = (\psi_{2n}^{2n})^k = 1^k = 1\] <p>ì´ë¯€ë¡œ $\mathbb{Z}_{q}[x]/(x^n-1)$ì˜ ê·¼ì´ ë˜ê³ , $\psi_{2n}^{2k+1}$ì€</p> \[(\psi_{2n}^{2k+1})^n = (\psi_{2n}^{2n})^k \cdot \psi_{2n}^n = 1 \cdot (-1) = -1\] <p>ì´ë¯€ë¡œ $\mathbb{Z}_{q}[x]/(x^n+1)$ì˜ ê·¼ì´ ëœë‹¤.</p> </li> </ul> <p>Take $\omega_n = \psi_{2n}^2 \bmod q$, and write</p> \[\boldsymbol{\psi} = (1, \psi_{2n}, \psi_{2n}^2, \dots, \psi_{2n}^{n-1}),\quad \boldsymbol{\psi}^{-1} = (1, \psi_{2n}^{-1}, \psi_{2n}^{-2}, \dots, \psi_{2n}^{-(n-1)}).\] <p>Define</p> \[\bar{\boldsymbol{a}} = \boldsymbol{\psi} \circ \boldsymbol{a},\text{ where } \bar{a}_i = \psi_{2n}^i a_i \\[.5em] \boldsymbol{a} = \boldsymbol{\psi}^{-1} \circ \bar{\boldsymbol{a}},\text{ where } a_i = \psi_{2n}^{-i} \bar{a}_i.\] \[\hat{\boldsymbol{a}} = \text{NTT}^\psi(\boldsymbol{a}) = \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a}),\\[1em] \boldsymbol{a} = \text{INTT}^{\psi^{-1}}(\hat{\boldsymbol{a}}) = \boldsymbol{\psi}^{-1} \circ \text{INTT}(\hat{\boldsymbol{a}}).\] <p><code class="language-plaintext highlighter-rouge">matrix í‘œí˜„ì€ CCì™€ ë™ì¼ (psiê°€ ì•„ë‹Œ omega ì‚¬ìš©)</code></p> <p>More specifically, the forward transform $\hat{\boldsymbol{a}} = \text{NTT}^\psi(\boldsymbol{a})$ can be written as</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \psi_{2n}^i \omega_n^{ij} \bmod q \quad (j = 0, 1, \dots, n - 1).\] <p>The inverse transform $\boldsymbol{a} = \text{INTT}^{\psi^{-1}}(\hat{\boldsymbol{a}})$ can be written as</p> \[a_i = n^{-1} \psi_{2n}^{-i} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q \quad (i = 0, 1, \dots, n - 1).\] <h5 id="prop-negative-wrapped-convolution-property">Prop) Negative Wrapped Convolution Property</h5> <p>Let $\boldsymbol{c}$ be the negative wrapped convolution of $\boldsymbol{a}$ and $\boldsymbol{b}$, then it holds that</p> \[\begin{aligned} \text{NTT}^\psi(\boldsymbol{c}) &amp; = \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})\\[.3em] &amp;=\text{NTT}(\boldsymbol{\psi} \circ (\underbrace{\boldsymbol{a}\cdot\boldsymbol{b}}_\text{NWC}))\\[.3em] &amp;=\text{NTT}(\underbrace{(\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b})}_{\text{CC\; }\because\ \psi_{wn}^{2k+1}\,\to\ \psi_{wn}^{2k+2}})\\[.3em] &amp;=\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{a})\circ\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{b})\\[.3em] &amp;=\text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b}). \end{aligned}\] <ul> <li> <p>Example</p> <p><strong>Initialization</strong></p> <ul> <li>$\mathbb{Z}_q[x]/(x^n+1)$ <ul> <li>$n=2$, modulus $x^2 + 1$ (ì¦‰, $x^2 \equiv -1$)</li> <li>$q=5$ ($q \equiv 1 \pmod{2n}$ ë§Œì¡±)</li> </ul> </li> <li> <p>$\psi=2$</p> <p>$2^1=2,\; 2^2=4,\; 2^3=8\equiv3,\; 2^4=16\equiv1$, $\psi^n \equiv -1 \pmod q$</p> </li> <li>$\omega=4$</li> <li>NTT matrix $N = \begin{bmatrix} 1 &amp; 1 \ 1 &amp; \omega \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 4 \end{bmatrix}$</li> <li>$\boldsymbol{a} = [1, 1]$ (ì¦‰, $x+1$)</li> <li>$\boldsymbol{b} = [2, 1]$ (ì¦‰, $x+2$)</li> </ul> <p><strong>Calculation</strong> (ë²¡í„°í‘œí˜„ê³¼ ë§ì¶”ê¸° ìœ„í•´ ë‹¤í•­ì‹ì„ ì €ì°¨í•­ë¶€í„° í‘œê¸°)</p> <p>$\boldsymbol{\psi}=[ \psi^0, \psi^1 ] = [1, 2]$</p> <ol> <li> <p>$\text{NTT}^\psi(\boldsymbol{c}) :=\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})=\text{NTT}(\boldsymbol{\psi} \circ (\boldsymbol{a}\cdot\boldsymbol{b}))$</p> <p>$\boldsymbol{c}=(1+x)(2+x) = 2 + 3x + x^2\equiv 2 + 3x + (-1) = 1+3x \implies[1,3]$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{c}=[1,2]\circ[1,3]=[1,6]\equiv[1,1]$</p> \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})=N([1,1])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 1 \end{bmatrix}=\begin{bmatrix} 2 \\ 5 \end{bmatrix}\equiv\begin{bmatrix} 2 \\ 0 \end{bmatrix}=[2,0]\] <p>$\boldsymbol{a}\cdot \boldsymbol{b}=\boldsymbol{c}=[1,3]$</p> <p>$\text{NTT}(\boldsymbol{\psi} \circ (\boldsymbol{a}\cdot \boldsymbol{b}))=[2,0]$</p> </li> <li> <p>$\text{NTT}((\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}))$</p> <p>â€» $\boldsymbol{\psi}$ë¥¼ ê³±í•´ì¤¬ê¸° ë•Œë¬¸ì— Cyclic convolution ê³µê°„ì´ ë¨ â‡’ $x^2\equiv 1$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{a}=[1,2]\circ[1,1]=[1,2]\implies1+2x$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{b}=[1,2]\circ[2,1]=[2,2]\implies 2+2x$</p> \[\begin{aligned} (\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}) &amp;=(1+2x)(2+2x)=2+4x+2x+4x^2\\ &amp;=2+6x+4(1)=6+6x\\ &amp;\equiv 1+x\implies [1,1] \end{aligned}\] \[\text{NTT}((\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}))=N([1,1])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 1 \end{bmatrix}=\begin{bmatrix} 2 \\ 5 \end{bmatrix}\equiv\begin{bmatrix} 2 \\ 0 \end{bmatrix}=[2,0]\] </li> <li> <p>$\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{a})\circ\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{b}) := \text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b})$</p> \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a})=N([1,2])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 2 \end{bmatrix}=\begin{bmatrix} 3 \\ 9 \end{bmatrix}\equiv\begin{bmatrix} 3 \\ 4 \end{bmatrix}=[3,4]\] \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{b})=N([2,2])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 2 \\ 2 \end{bmatrix}=\begin{bmatrix} 4 \\ 10 \end{bmatrix}\equiv\begin{bmatrix} 4 \\ 0 \end{bmatrix}=[4,0]\] \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a})\circ \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{b})=[3,4]\circ[4,0]=[12,0]=[2,0]\] </li> </ol> </li> </ul> <h4 id="ntt-based-polynomial-multiplication">NTT-based Polynomial Multiplication</h4> <h5 id="cyclic-convolution-based-polynomial-multiplication">Cyclic convolution-based polynomial multiplication</h5> <p>To compute the cyclic convolution $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n - 1)$,</p> <p>one can straightly use $n$-point NTT/INTT, according to cyclic convolution property</p> \[\boldsymbol{c} = \text{INTT}(\text{NTT}(\boldsymbol{a}) \circ \text{NTT}(\boldsymbol{b})).\] <h5 id="negative-wrapped-convolution-based-polynomial-multiplication">Negative wrapped convolution-based polynomial multiplication</h5> <p>To compute the negative wrapped convolution $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n + 1)$, one can use the negative wrapped convolution property</p> \[\boldsymbol{c} = \text{INTT}^{\psi^{-1}}\left(\text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b})\right).\] <h5 id="advantages-of-ntt">Advantages of NTT</h5> <p>Here, let NTT/INTT be any kind of forward/inverse transforms.</p> <ul> <li> <p>Firstly, both NTT and INTT are linear transformations, based on which INTTs can be saved in lattice-based schemes (e.g., Kyber and Dilithium), i.e.,</p> \[\begin{aligned} \sum_{i=0}^l \boldsymbol{a}_i \boldsymbol{b}_i &amp;= \sum_{i=0}^l \text{INTT}(\text{NTT}(\boldsymbol{a}_i) \circ \text{NTT}(\boldsymbol{b}_i)) \\ &amp;= \text{INTT}(\sum_{i=0}^l \text{NTT}(\boldsymbol{a}_i) \circ \text{NTT}(\boldsymbol{b}_i)). \end{aligned}\] </li> </ul> <h4 id="fft-trick-for-nwc-based-ntt-over-mathbbz_qxxn--1">FFT Trick for NWC-based NTT over $\mathbb{Z}_q[x]/(x^n + 1)$</h4> <p>The FFT trick to compute $\text{NTT}^\psi$ and $\text{INTT}^{\psi^{-1}}$ over $\mathbb{Z}_q[x]/(x^n + 1)$,</p> <p>where $n$ is a power of two and $q$ is a prime number satisfying $q \equiv 1 \pmod{2n}$.</p> <p>Since $\psi_{2n}^{n/2} \equiv -1 \pmod q$,</p> \[x^n + 1 = x^n - \psi_{2n}^{n/2} = (x^{n/2} - \psi_{2n}^{n/2})(x^{n/2} + \psi_{2n}^{n/2}) \pmod q.\] <p>As for $\text{NTT}^\psi$, the forward FFT trick implies that we have the following isomorphism</p> \[\mathbb{Z}_q[x]/(x^n + 1) \;\cong\; \mathbb{Z}_q[x]/(x^{n/2} - \psi_{2n}^{n/2}) \times \mathbb{Z}_q[x]/(x^{n/2} + \psi_{2n}^{n/2})\] <p>Notice that $x^n + 1$ has $n$ distinct roots in $\mathbb{Z}<em>q$, i.e., $\psi</em>{2n}^{2i+1}, i = 0, 1, \dots, n-1$.</p> <p>Therefore, there is a CRT isomorphism similarly.</p> \[\mathbb{Z}_q[x]/(x^n + 1) \;\cong\; \prod_{i=0}^{n-1} \mathbb{Z}_q[x]/(x - \psi_{2n}^{2\text{brv}_n(i)+1}).\] <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/image.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>After the $k$-th level, where $0 \le k &lt; \log n$, it produces</p> \[\qquad\mathbb{Z}_q[x]/(x^{n/2^{k+1}} \pm \psi_{2n}^{\text{brv}_n(2^k+i)})\] <p>with pairs of rings.</p> <h5 id="example">Example</h5> <p>$n=8 \Rightarrow 2n=16$</p> <p>Let $\psi_{2n}$ is a primitive $2n$-th root of unity: i.e., $\psi_{2n}^{2n}=1$</p> <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/image_1.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Let $\omega=\psi_{2n}^2$, then $\omega$ is a primitive $n$-th root of unity: $\omega^{n}= (\psi_{2n}^2)^{n}=1$</p> <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/image_2.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/image_3.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <h4 id="radix-2-fast-nwc-based-ntt">Radix-2 Fast NWC-based NTT</h4> <p>The Cooley-Tukey butterfly or CT butterfly<code class="language-plaintext highlighter-rouge">Multiplication â†’ Addition</code>.</p> <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/14416731-2c31-4e01-9c81-ca220167df77.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Gentlemen-Sande butterfly or GS butterfly<code class="language-plaintext highlighter-rouge">Addition â†’ Multiplication</code>.</p> <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/bc9e4c46-c1a8-4888-8f28-8fab825d7c10.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>The process of multiplying the coefficients by $\psi_{2n}^i$ before forward transform is referred to as pre-processing.</p> <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/image_4.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/image_5.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <ol> <li> <p><strong>Cooley-Tukey algorithm for $\text{NTT}^\psi$</strong></p> <p>According to the definition of $\text{NTT}^\psi$, the coefficients of $\hat{\boldsymbol{a}}$ can be written as</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \psi_{2n}^i \omega_n^{ij} \bmod q, \quad j = 0, 1, \dots, n - 1.\] <p>For $j = 0, 1, \dots, n - 1$,</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} \omega_n^{2ij} \psi_{2n}^{2i} + \sum_{i=0}^{n/2-1} a_{2i+1} \omega_n^{(2i+1)j} \psi_{2n}^{2i+1} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i + \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, for $j = 0, 1, \dots, n/2 - 1$</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i + \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q \\[1.5em] \hat{a}_{j+n/2} &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i - \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} \hat{a}'_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q,\\[1.5em] \hat{a}''_j &amp;= \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q. \end{aligned}\] <p>With $\omega_n^j \psi_{2n} = \psi_{2n}^{2j+1}$,</p> \[\hat{a}_j = \hat{a}'_j + \psi_{2n}^{2j+1} \hat{a}''_j \bmod q, \quad \hat{a}_{j+n/2} = \hat{a}'_j - \psi_{2n}^{2j+1} \hat{a}''_j \bmod q.\] <p>One can see that, $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$ can be obtained via exact $n/2$-point $\text{NTT}^\psi$s.</p> </li> <li> <p><strong>Gentleman-Sande algorithm for $\text{INTT}^{\psi^{-1}}$</strong></p> <p>According to the definition of $\text{INTT}^{\psi^{-1}}$, the coefficients of $\boldsymbol{a}$ can be written as</p> \[a_i = n^{-1} \psi_{2n}^{-i} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q, \quad i = 0, 1, \dots, n - 1.\] <p>With neglecting $n^{-1}$, for $i = 0, 1, \dots, n - 1$,</p> \[\begin{aligned} a_i &amp;= \psi_{2n}^{-i} \left( \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-ij} + \sum_{j=n/2}^{n-1} \hat{a}_j \omega_n^{-ij} \right) \\[1.5em] &amp;= \psi_{2n}^{-i} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-ij} + \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-i(j+n/2)} \right] \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= \psi_{2n}^{-2i} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-2ij} + (-1)^{2i} \cdot \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-2ij} \right] \bmod q \\[1.5em] &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} (\hat{a}_j + \hat{a}_{j+n/2}) (\omega_n^2)^{-ij} \bmod q, \\[2em] a_{2i+1} &amp;= \psi_{2n}^{-(2i+1)} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-(2i+1)j} + (-1)^{2i+1} \cdot \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-(2i+1)j} \right] \bmod q \\[1.5em] &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \left[ (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \omega_n^{-j} \psi_{2n}^{-1} \right] (\omega_n^2)^{-ij} \bmod q. \end{aligned}\] <p>Since $\omega_n^{-j} \psi_{2n}^{-1} = \psi_{2n}^{-(2j+1)}$, letting</p> \[\begin{aligned} \hat{b}'_j &amp;= \hat{a}_j + \hat{a}_{j+n/2} \bmod q,\\[1em] \hat{b}''_j &amp;= (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \psi_{2n}^{-(2j+1)} \bmod q,\quad j = 0, 1, \dots, n/2 - 1, \end{aligned}\] <p>the above formula can be rewritten as, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}'_j (\omega_n^2)^{-ij} \bmod q, \\[1.5em] a_{2i+1} &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}''_j (\omega_n^2)^{-ij} \bmod q. \end{aligned}\] <p>Computing $n$-point $\text{INTT}^{\psi^{-1}}$ can be transformed into two $n/2$-point $\text{INTT}^{\psi^{-1}}$s with respect to $\hat{b}â€™_j, \hat{b}â€™â€˜_j$.</p> <p>Forthermore, $\boldsymbol{\psi}^{-1}$ and $n^{-1}$ can both be integrated into $\text{INTT}^{GS}_{bo \to no}$.</p> <p>Thus, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= \left(\frac{n}{2}\right)^{\!\!-1}\! (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}'_j (\omega_n^2)^{-ij} \bmod q, \\[1.5em] a_{2i+1} &amp;= \left(\frac{n}{2}\right)^{\!\!-1}\! (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}''_j (\omega_n^2)^{-ij} \bmod q, \end{aligned}\] \[\begin{aligned} \text{where }\; &amp; \hat{b}'_j = (\hat{a}_j + \hat{a}_{j+n/2})/2 \mod q,\\[.5em]&amp; \hat{b}''_j = (\hat{a}_j - \hat{a}_{j+n/2})/2 \cdot \psi_{2n}^{-(2j+1)} \bmod q, \quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] </li> </ol> <h3 id="kyber-ntt">Kyber NTT</h3> <p>ğŸ’¡</p> <ol> <li>Kyber ringì€ $\mathbb{Z}_q[x]/(x^n+1)$ì´ë¯€ë¡œ NWC-based NTTë¥¼ ìˆ˜í–‰í•˜ê¸° ìœ„í•œ primitive $2n$-th root of unityê°€ í•„ìš”í•¨ <ul> <li> <p>$2n$-th root of unity $\psi_{2n}$ëŠ” $\psi_{2n}^{2n}=1$ì´ë¯€ë¡œ</p> <p>$\psi_{2n}^n=-1\implies x^n+1=x^n-(\psi_{2n}^n)=0$ì„ ë§Œì¡±í•¨</p> </li> </ul> </li> <li>Primitive $2n$-th root of unityê°€ ì¡´ì¬í•˜ë ¤ë©´ <ol> <li>$n=2^k$</li> <li>$q\equiv 1\pmod{2n}$</li> </ol> <p>ì„ ë§Œì¡±í•´ì•¼ í•¨</p> </li> <li> <p>KyberëŠ” $n=256=2^8$ì´ì§€ë§Œ $q$ì— ëŒ€í•˜ì—¬ $q\equiv 257\neq 1\pmod{512}$ì´ë¯€ë¡œ $2n$-th root of unityê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ</p> </li> <li>Kyber ring $\mathbb{Z}_q[x]/(x^{256}+1)$ì„ $(\mathbb{Z}_q[y]/(y^2-x))[x]/(x^{128}+1)$ë¡œ ë³€í™˜í•¨ <ol> <li>$nâ€™=128$ì— ëŒ€í•˜ì—¬ primitive $2n$-th root of unityê°€ ì¡´ì¬í•¨</li> <li> <p>FFTë¥¼ ì ìš©í•œ point-wise multiplicationì€</p> <p>$(c_0 +c_1 y)(c_0â€™ +c_1â€™ y)\in \mathbb{Z}_q[y]/(y^2-x)$ë¡œì¨ ìˆ˜í–‰ë¨</p> </li> </ol> </li> </ol> <h5 id="full-nwc-based-ntt-ì ìš©-ë¶ˆê°€">Full NWC-based NTT ì ìš© ë¶ˆê°€</h5> <p>Full NWC-based NTTëŠ” ë‹¤ìŒì„ ë§Œì¡±í•´ì•¼ í•¨</p> \[n=2^k\quad\text{ and }\quad q\equiv1\;(\bmod{\;2n})\] <p>íŠ¹íˆ, Full NWC-based NTTëŠ”</p> \[\mathbb{Z}_q[x]/(x^n + 1) \;\cong\; \prod_{i=0}^{n-1} \mathbb{Z}_q[x]/(x - \psi_{2n}^{2\text{brv}_n(i)+1})\] <p>ë¥¼ ë§Œë“œëŠ” ê³¼ì •ì´ë¯€ë¡œ primitive $2n$-th root of unity $\psi_{2n}$ê°€ ì¡´ì¬í•´ì•¼ ì ìš© ê°€ëŠ¥í•¨</p> <p>Kyberì˜ specì€ ë‹¤ìŒê³¼ ê°™ìŒ</p> \[n=256=2^8\quad\text{ and }\quad q\equiv1\;(\bmod{\;256})\quad\text{ but }\quad q\neq 1\;(\bmod{\;512})\] <p>ì´ëŠ” $\mathbb{Z}_q$ ìƒì— primitive 256-th root of unityëŠ” ì¡´ì¬í•˜ì§€ë§Œ, primitive 512-th root of unityëŠ” ì¡´ì¬í•˜ì§€ ì•ŠìŒì„ ì˜ë¯¸</p> <h4 id="truncated-nttë¥¼-ì´ìš©í•œ-í•´ê²°">Truncated NTTë¥¼ ì´ìš©í•œ í•´ê²°</h4> <h5 id="incomplete-fft-trick-truncated-ntt">Incomplete FFT trick (Truncated NTT)</h5> <p>Incomplete FFT trickì€ FFT depth level $\beta$ì— ëŒ€í•˜ì—¬ ë‹¤í•­ì‹ ring êµ¬ì¡°ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ë³€í™˜í•¨</p> \[\mathbb{Z}_q[x]/(x^n+1) \cong \prod_{i=0}^{n/2^\beta - 1} \mathbb{Z}_q[x] / (x^{2^\beta} - \psi_{2n/2^\beta}^{2\text{brv}(i)+1})\] <ul> <li>$\beta$ëŠ” $\log n$-levelì˜ NTTë¥¼ $\beta$-level ì´ì „ì— ë§ˆì¹¨ì„ ì˜ë¯¸í•¨</li> </ul> <p>$\beta$ëŠ”</p> \[q \equiv 1 \pmod{2n/2^{\beta}}\] <p>ë¥¼ ë§Œì¡±í•˜ë„ë¡ ì„ íƒí•˜ë©°, KyberëŠ” íš¨ìœ¨ì„±ì„ ìœ„í•´ ê°€ì¥ ì‘ì€ $\beta=1$ì„ ì„ íƒí•¨</p> \[q=3329 \equiv 1\quad(\bmod{\;256}=\bmod{\;{2n}/2})\] <p>KyberëŠ” $\beta=1$ì¸ Incomplete FFT trickì„ ì‚¬ìš©í•˜ë¯€ë¡œ</p> \[\mathbb{Z}_q[x]/(x^n+1) \cong \prod_{i=0}^{n/2 - 1} \mathbb{Z}_q[x] / (x^{2} - \psi_{n}^{2\text{brv}(i)+1})\] <p>ë¡œ ring êµ¬ì¡°ë¥¼ ë³€í™˜í•¨</p> <p>ì´ëŠ” Kyber ringì—ì„œ ì •ì˜ëœ ë‹¤í•­ì‹ $a(x)\in \mathbb{Z}_q[x]/(x^n+1)$ë¥¼ $y = x^{2^\beta} = x^2$ë¡œ ì¹˜í™˜í•˜ì—¬ $y$ì— ëŒ€í•œ ë‹¤í•­ì‹</p> \[\begin{aligned} a(y) = \sum_{i=0}^{n/2^\beta -1} \tilde{a}_i y^i &amp;\in \left(\mathbb{Z}_q[x]/(x^{2^\beta} - y)\right)[y]/(y-\psi_{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1}) \\[1.5em] \text{ where }\quad \tilde{a}_i=\sum_{j=0}^{2^\beta -1}a_{2^\beta i+j} x^j &amp;\in \mathbb{Z}_q[x]/(x^{2^\beta} - y) \end{aligned}\] <p>ì¦‰,</p> \[\begin{aligned} a(y) = \sum_{i=0}^{n/2 -1} \tilde{a}_i y^i &amp;\in \left(\mathbb{Z}_q[x]/(x^{2} - y)\right)[y]/(y-\psi_{n}^{2\text{brv}_{n/2}(i)+1}) \\[1.5em] \text{ where }\quad \tilde{a}_i=\sum_{j=0}^{1}a_{2i+j} x^j &amp;\in \mathbb{Z}_q[x]/(x^{2} - y) \end{aligned}\] <p>ë¡œ í‘œí˜„í•¨ì„ ì˜ë¯¸í•¨</p> <p>ì´ëŠ”</p> \[\mathbb{Z}_q[x]/(x^n+1) \cong \prod_{i=0}^{n/2^\beta - 1} \mathbb{Z}_q[x] / (x^{2^\beta} - \psi_{2n/2^\beta}^{2\text{brv}(i)+1})\] <p>ì—ì„œ ìµœìƒìœ„ levelì—ì„œì˜ ring êµ¬ì¡°ë¥¼</p> \[\mathbb{Z}_q[x]/(x^n+1) \to \left(\mathbb{Z}_q[x]/(x^{2^\beta} - y)\right)[y]/(y^{n/2^\beta} +1)\] <p>ë¡œ ë°”ë¼ë³´ëŠ” ê²ƒì„</p> <p>$n=256,\ \beta=1$ì— ëŒ€í•˜ì—¬</p> \[\mathbb{Z}_q[x]/(x^{256}+1) \to \left(\mathbb{Z}_q[x]/(x^{2} - y)\right)[y]/(y^{128} +1)\] <p>ì´ë©°,</p> <p>ì´ëŠ” ìµœìƒìœ„ levelì˜ ring êµ¬ì¡°ë¥¼ $y$ì— ëŒ€í•˜ì—¬ ê³„ìˆ˜ê°€ 1ì°¨ ë‹¤í•­ì‹ $c_0+c_1 x$ì¸ 127ì°¨ ë‹¤í•­ì‹ìœ¼ë¡œ ë³´ëŠ” ê²ƒì„</p> <p>KyberëŠ” ìœ„ êµ¬ì¡°ì—ì„œ $y$ì— ëŒ€í•œ 128-point Full NWC-based NTTë¥¼ ìˆ˜í–‰í•¨</p> \[\mathbb{Z}_q[x]/(x^{256}+1) \to \left(\mathbb{Z}_q[x]/(x^{2} - y)\right)[y]/(y^{128} +1)\] <p>ë˜í•œ, formal variable $x, y$ë¥¼ êµí™˜í•˜ë©´</p> \[\mathbb{Z}_q[x]/(x^{256}+1) \to \left(\mathbb{Z}_q[y]/(y^{2} - x)\right)[x]/(x^{128} +1)\] <p>ì´ë¯€ë¡œ, NTTë¥¼ ì ìš©í•  ë‹¤í•­ì‹ì„ $c_0+c_1 y$ í˜•íƒœì˜ ê³„ìˆ˜ë¥¼ ê°–ëŠ” $x$ì— ëŒ€í•œ ë‹¤í•­ì‹ìœ¼ë¡œ í‘œí˜„í•  ìˆ˜ ìˆìŒ</p> <p>ì´ë•Œ $\omega=\psi_{2n/2}=\psi_{n}$ì´ë©°, $\omega_i:=\omega^i$ë¼ê³  í•  ë•Œ ë‹¤í•­ì‹ $\boldsymbol{a}$ëŠ” ë‹¤ìŒìœ¼ë¡œ ë§¤í•‘ë¨</p> \[\begin{aligned} \mathbb{Z}_q[x]/(x^{256}+1) &amp;\cong \prod_{i=0}^{127} \mathbb{Z}_q[x] / (x^2 - \omega_i) \\[1.5em]&amp;\cong \prod_{i=0}^{127} \left(\mathbb{Z}_q[y]/(y^{2} - x)\right)[x]/ (x^2 - \omega_i) \end{aligned}\] <p><img src="/june.github.io/assets/img/post/ntt_ml_kem/image_6.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <h4 id="ë‹¤í•­ì‹-ê³±ì…ˆì„-ìœ„í•œ-ntt-ì„ íƒ">ë‹¤í•­ì‹ ê³±ì…ˆì„ ìœ„í•œ NTT ì„ íƒ</h4> <p>KyberëŠ” NWC-based NTT ì—°ì‚°ì„ ì ìš©í•´ì•¼ í•˜ë¯€ë¡œ</p> \[\text{NTT}^{CT,\psi}_{no\,\to\, bo}\quad\text{ and }\quad\text{INTT}^{GS,\psi^{-1}}_{bo\,\to\, no}\] <p>ë¥¼ ì‚¬ìš©í•¨</p> <p>Point-wise multiplicationì€</p> \[a(x), b(x) \in \mathbb{Z}_q[x]/(x^2 - \omega_i)\] <p>ì— ëŒ€í•˜ì—¬ (formal variable $y\to x$)</p> \[c(x) = a(x)b(x) \pmod{x^2 - \omega_i}\] <p>ì„ êµ¬í•˜ëŠ” ê³¼ì •ì´ë©°</p> \[\begin{aligned} (a_0 + a_1x)(b_0 + b_1x) &amp;= a_0b_0 + (a_0b_1 + a_1b_0)x + a_1b_1x^2\\ &amp;\equiv (a_0b_0 + a_1b_1\omega^2) + (a_0b_1 + a_1b_0)x \pmod{x^2 - \omega_i} \end{aligned}\] <p>ìœ¼ë¡œ êµ¬í•  ìˆ˜ ìˆìŒ</p> <h3 id="algorithm-analysis">Algorithm analysis</h3> <h5 id="bf-algorithm--color0000ffsf-nttf">${\bf Algorithm} \ \color{#0000ff}{\sf NTT}(f)$</h5> <p>Computes the NTT representation $\hat f$ of the given polynomial $f\in R_q$.</p> <p>${\bf{Input}}: {\rm array}\ f\in\mathbb{Z}_q^{256}.$</p> <p>${\bf{Output}}: {\rm array}\ \hat{f}\in\mathbb{Z}_q^{256}.$</p> <p>$01: \hat{f}\leftarrow f$</p> <p>$02: i\leftarrow 1$</p> <p>$03: {\bf for}({\rm len} \leftarrow 128\ ;\ {\rm len}\ge 2\ ;\ {\rm len}/2)$</p> <p>$04: \quad {\bf for} ({\rm start} \leftarrow 0\ ;\ {\rm start}&lt;256\ ;\ {\rm start}\leftarrow {\rm start}!+!2!\cdot!{\rm len})$</p> <p>$05: \qquad {\rm zeta} \leftarrow \zeta^{\color{0000ff} {\sf BitRev}_7(i)} \mod q$</p> <p>$06: \qquad i\leftarrow i!+!1$</p> <p>$07: \qquad {\bf for} (j\leftarrow {\rm start}\ ;\ j&lt;{\rm start+len}\ ;\ j\text{++})$</p> <p>$08: \quad\qquad t \leftarrow {\rm zeta}\cdot\hat{f}[j+\rm len]\mod q$</p> <p>$09: \quad\qquad \hat{f}[j+\rm len] \leftarrow \hat{f}[j]-t\mod q$</p> <p>$10: \quad\qquad \hat{f}[j] \leftarrow \hat{f}[j]+t\mod q$</p> <p>$11: \qquad {\bf endfor}$</p> <p>$12: \quad {\bf endfor}$</p> <p>$13: {\bf endfor}$</p> <p>$14: {\bf return}\ \hat{f}$</p> <h4 id="truncation">Truncation</h4> <ul> <li> <p>Algorithm line 3: len=128, 64, â€¦ ,2</p> <p>â‡’ Crops with $\beta=1$</p> <p>Full NWC-based NTTëŠ” $2^0\sim2^7$ê¹Œì§€ $\log 2^8=8$-levelì˜ NTTë¥¼ ìˆ˜í–‰í•˜ì§€ë§Œ</p> <p>KyberëŠ” $\beta=1$-levelì¸ $\text{len}=2^0$ì— ëŒ€í•œ ë¶„í•´ë¥¼ ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ</p> </li> <li> <p>Line 8~10</p> <p>â‡’ Point-wise multiplication over $\mathbb{Z}_q[x]/(x^2-\zeta)$ for $\zeta=\omega_i$</p> \[\left(\ \sum_{i=0}^{1} \hat{a}_i x^i\right)\left(\ \sum_{i=0}^{1} \hat{b}_i x^i\right) =(\hat{a}_0 x^0+\hat{a}_1 x^1)(\hat{b}_0 x^0+\hat{b}_1 x^1) \mod({x^{2} - \zeta}),\] </li> </ul>]]></content><author><name></name></author><category term="Study"/><category term="MATH"/><category term="PQC"/><category term="Cryptography"/><summary type="html"><![CDATA[NTT(Number Theoretic Transform) for ML-KEM, ML-DSA]]></summary></entry><entry><title type="html">NTT</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2025/ntt/" rel="alternate" type="text/html" title="NTT"/><published>2025-12-12T00:00:00+00:00</published><updated>2025-12-12T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2025/ntt</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2025/ntt/"><![CDATA[<p>ğŸ“š <strong>[MAIN]</strong> Liang, Zhichuang, and Yunlei Zhao. â€œNumber theoretic transform and its applications in lattice-based cryptosystems: A survey.â€Â <em>arXiv preprint arXiv:2211.13546</em>Â (2022).<br/> ğŸ“š <strong>[Sub 1]</strong> Pollard, John M. â€œThe fast Fourier transform in a finite field.â€Â <em>Mathematics of computation</em>Â 25.114 (1971): 365-374.<br/> ğŸ“š <strong>[Sub 2]</strong> Agarwal, Ramesh C., and C. Sidney Burrus. â€œNumber theoretic transforms to implement fast digital convolution.â€Â <em>Proceedings of the IEEE</em>Â 63.4 (2005): 550-560.<br/> ğŸ“š <strong>[Sub 3]</strong> FÃ¼rer, Martin. â€œFaster integer multiplication.â€Â <em>Proceedings of the thirty-ninth annual ACM symposium on Theory of computing</em>. 2007.<br/> ğŸ“š <strong>[Sub 4]</strong> Fraleigh, John B.Â <em>A first course in abstract algebra</em>. Pearson Education India, 2003.</p> <hr/> <h3 id="preliminaries">PRELIMINARIES</h3> <h4 id="notations-and-definitions">Notations and Definitions</h4> <ul> <li>$\mathbb{Z}$: the ring of rational integers</li> <li>$n$, $q$: some positive integers</li> <li>$\mathbb{Z}_q\cong{0, 1,\ â€¦\, ,\ q âˆ’ 1}$</li> <li>$xâ€™ \equiv x \pmod ğ‘$: $q\mid (xâ€™ âˆ’ x)$</li> <li>$xâ€™ = x \pmod q$: $xâ€™$ is the unique element in $\mathbb{Z}_ğ‘$ satisfying $ğ‘¥â€™ \equiv ğ‘¥ \pmod ğ‘$</li> <li>$\bf a$, $a(x)$: polynomials</li> <li>$\bf r=a\mod b$: ğ’“ is the polynomial remainder of ğ’‚ divided by ğ’ƒ</li> <li>For any $n_1,n_2\in\mathbb{Z}$, $n_1 &gt; n_2$ and any $a_i$, $\sum_{j=n_1}^{n_2} a_i = 0$</li> <li>$\circ$: point-wise multiplication</li> </ul> <h5 id="def-bitreversal">Def) Bitreversal</h5> <p>Let $n$ be a power of two, and</p> <p>$b$ be a non-negative integer satisfying $b&lt;n$.</p> <p>The bitreversal of $b$ with respect to $n$ is defined as</p> \[{\rm brv}_n (b_{\log_{n-1}}2^{\log n-1} + \cdots + b_1 2 + b_0) = b_0 2^{\log n-1} + \cdots + b_{\log_{n-2}}2 + b_{\log_{n-1}},\] <p>where $b_i$ is the $i$-th bit of the binary expansion of $b$ .</p> <h5 id="def-primitive-and-principal-root-of-unity">Def) Primitive and Principal Root of Unity</h5> <p>The elements of the set $U_{k}={ \psi\in\mathbb{C} \mid \psi^k=1 }$ are called the $k$-th roots of unity.</p> <p>Let $R$ be a commutative ring with multiplicative identity 1,</p> <p>$k$ be a positive integer, and</p> <p>$\psi(\neq1)$ be an element in $R$.</p> <p>Define $\psi$ is the primitive $k$-th root of unity in $R$</p> <p>$\iff$ $\psi^k=1$, and $\psi^i\neq 1,\; i=1,2,\ â€¦\,,\ k-1$.</p> <p>(i.e., $k$ is the least positive integer s.t. $\psi^k = 1$)</p> <p>Define $\psi$ is the principal $k$-th root of unity in $R$</p> <p>$\iff$ $\psi^k = 1$, and $\sum_{j=0}^{k-1}\psi^{jl}=0,\; l=1,2,\ â€¦\,,\ k-1$.</p> <p>Notice that primitive and principal $ğ‘˜$-th root of unity coincide if $R = \mathbb{Z}_q$ where $q$ is a prime number.</p> <ul> <li><strong>Coincide if $R=\mathbb{Z}_q$</strong> <ol> <li> <p>Primitive â‡’ Principal</p> <p>$\mathbb{Z}_q$ì˜ primitive $k$-th root of unity $\psi$ê°€ ì¡´ì¬í•˜ë©´, $\psi$ëŠ” $\mathbb{Z}_q$ì˜ principal $k$-th root of unityì´ë‹¤.</p> <p>pf ) $\psi$ê°€ primitive $k$-th root of unityì´ë¯€ë¡œ</p> <p>$\psi^k\equiv 1\bmod q$ì´ê³ , ëª¨ë“  $i=1,2,\, â€¦\,,k-1$ì— ëŒ€í•˜ì—¬ $\psi^i\neq 1$ì´ë‹¤.</p> <p>ì¦‰, ëª¨ë“  $l=1,2,\,â€¦\,,k-1$ì— ëŒ€í•´ $\psi^l -1\neq0$ì´ë¯€ë¡œ</p> \[\sum_{j=0}^{k-1} \psi^{jl} = \frac{(\psi^l)^k - 1}{\psi^l-1} = \frac{(\psi^k)^l - 1}{\psi^l-1} = \frac{(1)^k - 1}{\psi^l-1} = 0\] <p>ì´ë‹¤.</p> <p>$\psi^k\equiv 1\bmod q$ì´ê³ , ëª¨ë“  $l=1,2,\,â€¦\,,k-1$ì— ëŒ€í•´ $\sum_{j=0}^{k-1} \psi^{jl}=0$ì´ë¯€ë¡œ</p> <p>$\psi$ëŠ” principal $k$-th root of unityì´ë‹¤.</p> </li> <li> <p>Principal â‡’ Primitive</p> <p>$\mathbb{Z}_q$ì˜ principal $k$-th root of unity $\psi$ê°€ ì¡´ì¬í•˜ë©´, $\psi$ëŠ” $\mathbb{Z}_q$ì˜ primitive $k$-th root of unityì´ë‹¤.</p> <p>pf ) $\psi$ê°€ $\mathbb{Z}_q$ì˜ principal $k$-th root of unityì¼ ë•Œ,</p> <p>ì–´ë–¤ $l\in{1,2,\,â€¦\,,k-1}$ì— ëŒ€í•˜ì—¬ $\psi^l=1$ì´ë¼ê³  ê°€ì •í•˜ì.</p> <p>ì´ $l$ì— ëŒ€í•´</p> \[\sum_{j=0}^{k-1}\psi^{jl} = (\psi^l)^0 + (\psi^l)^1 + \cdots + (\psi^l)^{k-1}= 1+1+\cdots+1=k\neq0\pmod q\] <p>ì´ë‹¤. ($k\mid (q-1)$ì´ì–´ì•¼ í•˜ë¯€ë¡œ $k &lt; q$) ì´ëŠ” $\psi$ê°€ principal $k$-th root of unityë¼ëŠ” ê°€ì •ì— ëª¨ìˆœì´ë¯€ë¡œ $\psi$ëŠ” ëª¨ë“  $l=1,2,\,â€¦\,,k-1$ì— ëŒ€í•´ $\psi^j\neq 1$ì´ë‹¤. ëª¨ë“  $j=1,2,\,â€¦\,,k-1$ì— ëŒ€í•˜ì—¬ $\psi^j\neq 1$ì´ê³ , $\psi^k\equiv 1\bmod q,\ \psi\neq 1$ì´ë¯€ë¡œ $\psi$ëŠ” principal $k$-th root of unityì´ë‹¤.</p> </li> </ol> </li> <li> <p>Example</p> <p>$\mathbb{Z}_5$ì—ì„œ $a^i$ Table</p> <table> <thead> <tr> <th>$\psi$ $\setminus$ $i$</th> <th>0</th> <th>1</th> <th>2</th> <th>3</th> <th>4</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>2</td> <td>1</td> <td><strong>2</strong></td> <td><strong>4</strong></td> <td><strong>8=3</strong></td> <td><strong>6=1</strong></td> </tr> <tr> <td>3</td> <td>1</td> <td><strong>3</strong></td> <td><strong>9=4</strong></td> <td><strong>12=2</strong></td> <td><strong>6=1</strong></td> </tr> <tr> <td>4</td> <td>1</td> <td>4</td> <td>16=1</td> <td>4</td> <td>16=1</td> </tr> </tbody> </table> <p>2, 3 are primitive 4-th roots of unity in $\mathbb{Z}_5$</p> <table> <thead> <tr> <th>$\psi$</th> <th>$\sum_{j=0}^3 a^j$</th> <th>$\sum_{j=0}^3 a^{2j}$</th> <th>$\sum_{j=0}^3 a^{3j}$</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>4</td> <td>4</td> <td>4</td> </tr> <tr> <td>2</td> <td><strong>0</strong></td> <td><strong>0</strong></td> <td><strong>0</strong></td> </tr> <tr> <td>3</td> <td><strong>0</strong></td> <td><strong>0</strong></td> <td><strong>0</strong></td> </tr> <tr> <td>4</td> <td>0</td> <td>4</td> <td>0</td> </tr> </tbody> </table> <p>2, 3 are principal 4-th roots of unity in $\mathbb{Z}_5$</p> <p>â†’ primitive and principal 4-th roots of unity coincide in $\mathbb{Z}_5$</p> </li> </ul> <h4 id="polynomial-rings">Polynomial Rings</h4> <p>Let $\mathbb{Z}[x]$ and $\mathbb{Z}_q[x]$ be the polynomial rings over $\mathbb{Z}$ and $\mathbb{Z}_q$ respectively, with corresponding quotient rings $\mathbb{Z}[x]/!\left&lt;\phi(x)\right&gt;$ and $\mathbb{Z}_q[x]/!\left&lt;\phi(x)\right&gt;$, where $\phi(x)$ is a polynomial with integer coefficients.</p> <ul> <li> <p>Preliminary</p> <p><strong>Def)</strong> zero of $f(x)$</p> <p>Let $F$ be a subfield of a field $E$, and let $\alpha$ be an element of $E$.</p> <p>Let $f(x)=a_0 + a_1 x +\cdots+a_n x^n$ be in $F[x]$, and let $\phi_\alpha:F[x]\to E$ be the evaluation homomorphism.</p> <p>Let $f(\alpha)$ denote</p> \[\phi_\alpha(f(x))=a_0+a_1\alpha+\cdots+a_n\alpha^n.\] <p>If $f(\alpha)=0$, then $\alpha$ is a zero of $f(x)$.</p> <p><strong>Def)</strong> factor of $f(x)$</p> <p>An element $a\in F$ is a zero of $f(x)\in F[x]$ if and only if $x-a$ is a factor of $f(x)$ in $F[x]$.</p> <p><strong>Thm)</strong> Eisenstein Criterion</p> <p>Let $q\in\mathbb{Z}$ be a prime.</p> <p>Suppose that $f(x)=a_nx ^n +\cdots+a_0$ is in $\mathbb{Z}[x]$, and $a_n\neq 0\pmod q$, but $a_i=0\pmod q$ for all $i&lt;n$, with $a_0\neq 0\pmod {q^2}$.</p> <p>Then $f(x)$ is irreducible over $\mathbb{Q}$.</p> </li> </ul> <p>Especially, $\phi(x)$ is chosen to be a cyclotomic polynomial.</p> <ul> <li> <p>Preliminary</p> <p><strong>Cor)</strong> The polynomial</p> \[\phi_p(x)=\frac{x^p -1}{x-1}=x^{p-1}+\cdots+x+1\] <p>is irreducible over $\mathbb{Q}$ for any prime $p$.</p> <p>The polynomial $\phi_p(x)$ is the $p$-th cyclotomic polynomial.</p> <p>$n$-th cyclotomic polynomial $\phi_n(x)$ëŠ” 1ì˜ primitive $n$-th roots of unityë“¤ë§Œì„ ê·¼ìœ¼ë¡œ ê°–ëŠ” ë‹¤í•­ì‹ì´ë‹¤.</p> \[\phi_n(x)=\prod_{1\le k&lt;n, \gcd(k,n)=1}(x-e^{2\pi ki/n})\] <p>$p$ê°€ ì†Œìˆ˜ì¼ ë•Œ, ë°©ì •ì‹ $x^p -1=0$ì€ ë³µì†Œí‰ë©´ ìœ„ì—ì„œ ì´ $p$ê°œì˜ í•´ë¥¼ ê°€ì§„ë‹¤. $p$ê°œì˜ ê·¼ì„ $\zeta_k$ë¼ê³  í•˜ë©´</p> \[\zeta_k=e^{2\pi ki/n}\quad(k=0,1,\,...\,,p-1)\] <p>ì´ê³ , $k=0$ì¼ ë•Œ $\zeta_0 = 1$ì´ë‹¤. ì´ëŠ” orderê°€ 1ì´ë¯€ë¡œ primitive $p$-th roots of unityê°€ ì•„ë‹ˆë‹¤.</p> <p>$k\neq 0$ì¸ ê²½ìš°, $p$ê°€ primeì´ë¯€ë¡œ, 1ë³´ë‹¤ í¬ê³  $p$ë³´ë‹¤ ì‘ì€ ëª¨ë“  $k$ëŠ” $\gcd(k,p)=1$ì„ ë§Œì¡±í•œë‹¤. ë”°ë¼ì„œ, 1ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ $p-1$ê°œì˜ ê·¼ì€ ëª¨ë‘ order=$p$ì¸ primitive roots of unityì´ë‹¤.</p> <p>ë”°ë¼ì„œ</p> \[x^p -1=\prod_{k=0}^{p-1}(x-\zeta_k)=(x-1)\prod_{k=1}^{p-1}(x-\zeta_k)\] <p>ì´ê³ , ì •ì˜ì— ë”°ë¼</p> \[\prod_{k=1}^{p-1}(x-\zeta_k) = (x^p -1)/(x-1)\] <p>ì€ cyclotomic polynomialì´ ëœë‹¤.</p> </li> </ul> <p>If $\deg \phi(x)=n$ holds, the element in $\mathbb{Z}_q[x]/\langle\phi(x)\rangle$, for example, $\mathbf{a}$, can be represented in the form of $\mathbf{a}=\sum_{i=0}^{n-1}a_i x^i$, or in the form of $\mathbf{a}=(a_0, a_1, \dots, a_{n-1})$ <code class="language-plaintext highlighter-rouge">vector space over Zq</code>, where $a_i \in \mathbb{Z}_q$.</p> <p>Main target rings are $\mathbb{Z}_q[x] / (x^n-1)$ and $\mathbb{Z}_q[x] / (x^n+1)$, since they are widely used in lattice-based schemes.</p> <p>Let $n$ be a power of two, then $x^n +1$ is the $2n$-th cyclotomic polynomial.</p> <ul> <li>$n=2^k$ì¼ ë•Œ, $\phi_{2n}(x)=x^n +1$ ì¦ëª… <ol> <li> <p>ì‚¬ì „ ì¦ëª…</p> \[x^n - 1 = \prod_{d \mid n} \Phi_d(x)\] <p>ì´ë¯€ë¡œ, ì†Œìˆ˜ $p$ì™€ ìì—°ìˆ˜ $r \ge 1$ì— ëŒ€í•´ $n = p^r$ì¼ ë•Œ, ì•½ìˆ˜ë“¤ì€ $1, p, p^2, \cdots, p^r$ì´ê³ </p> \[x^{p^r} - 1 = \prod_{j=0}^{r} \Phi_{p^j}(x) = \Phi_{p^r}(x) \cdot \prod_{j=0}^{r-1} \Phi_{p^j}(x) = \Phi_{p^r}(x) (x^{p^{r-1}} - 1)\] <p>ì´ë¯€ë¡œ</p> \[\Phi_{p^r}(x) = \frac{x^{p^r} - 1}{x^{p^{r-1}} - 1}\] <p>ì´ë‹¤.</p> <p>í•œí¸,</p> \[\Phi_p(y) = \frac{y^p - 1}{y - 1}\] <p>ì´ë¯€ë¡œ $y=x^{p^{r-1}}$ë¥¼ ëŒ€ì…í•˜ë©´</p> \[\Phi_p(x^{p^{r-1}}) = \frac{(x^{p^{r-1}})^p - 1}{x^{p^{r-1}} - 1} = \frac{x^{p^r} - 1}{x^{p^{r-1}} - 1}\] <p>ì´ë‹¤. ë”°ë¼ì„œ</p> \[\Phi_{p^r}(x) = \Phi_p(x^{p^{r-1}})\] <p>ì´ë‹¤. ì¦‰, $p^r$-th cyclotomic polynomialì€ $p$-th cyclotomic polynomialì˜ ë³€ìˆ˜ì— $x^{p^{r-1}}$ì„ ëŒ€ì…í•œ ê²ƒê³¼ ê°™ë‹¤.</p> </li> <li> <p>ë³¸ ì¦ëª…</p> <p>$n=2^k$ì´ë¯€ë¡œ ($k \ge 0$)</p> \[\Phi_{2n}(x) = \Phi_{2^{k+1}}(x) = \Phi_2(x^{2^{(k+1)-1}}) = \Phi_2(x^{2^k})\] <p>ì´ë‹¤.</p> <p>2-th cyclotomic polynomialì€</p> \[\Phi_2(y) = \frac{y^2-1}{y-1} = y+1\] <p>ì´ë¯€ë¡œ, $y$ì— $x^{2^k}=x^n$ë¥¼ ëŒ€ì…í•˜ë©´</p> \[\Phi_{2n}(x) = \Phi_2(x^{2^k}) = \Phi_2(x^n) = x^n + 1\] <p>ì´ë‹¤.</p> <p>ê²°ê³¼ì ìœ¼ë¡œ $2n=2^{k+1}$-th cyclotomic polynomialì€ $x^n +1$ì´ë‹¤.</p> </li> </ol> </li> </ul> <h4 id="crt-for-the-polynomial-ring">CRT for the Polynomial Ring</h4> <h5 id="theorem">Theorem</h5> <p>$f_1(x), f_2(x), \dots, f_k(x)$ê°€ $F[x]$ì˜ ì›ì†Œì´ê³ ,</p> <p>ëª¨ë“  $i \neq j$ì— ëŒ€í•´ $\gcd(f_i(x), f_j(x)) = 1$ì´ë¼ê³  ê°€ì •í•˜ì.</p> <ul> <li> <p>$f(x) = f_1(x)f_2(x)\cdots f_k(x)$ ë¼ê³  í•  ë•Œ, ë‹¤ìŒ ring Isomorphismì´ ì„±ë¦½í•œë‹¤.</p> <p>ë‘ ring $(R, +, \cdot)$ê³¼ $(S, \oplus, \odot)$ ì‚¬ì´ì— í•¨ìˆ˜ $\phi : R \to S$ê°€ ì¡´ì¬í•˜ê³ , ë‹¤ìŒ ì„¸ ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ $\phi$ë¥¼ Ring Isomorphismì´ë¼ê³  í•œë‹¤.</p> <ol> <li> <p><strong>ì „ë‹¨ì‚¬(Bijective):</strong></p> <p>$\phi$ëŠ” ì¼ëŒ€ì¼ ëŒ€ì‘(One-to-one correspondence)ì´ì–´ì•¼ í•œë‹¤.</p> <p>ì¦‰, ë‹¨ì‚¬(Injective)ì´ë©´ì„œ ì „ì‚¬(Surjective)ì—¬ì•¼ í•œë‹¤. (1-1, onto)</p> </li> <li> <p><strong>ë§ì…ˆ ë³´ì¡´ (Homomorphism - Additive):</strong></p> <p>ì„ì˜ì˜ $a, b \in R$ì— ëŒ€í•´, $\phi(a + b) = \phi(a) \oplus \phi(b)$</p> </li> <li> <p><strong>ê³±ì…ˆ ë³´ì¡´ (Homomorphism - Multiplicative):</strong></p> <p>ì„ì˜ì˜ $a, b \in R$ì— ëŒ€í•´, $\phi(a \cdot b) = \phi(a) \odot \phi(b)$</p> </li> </ol> </li> </ul> \[F[x] / \langle f(x) \rangle \;\cong\; F[x] / \langle f_1(x) \rangle \times F[x] / \langle f_2(x) \rangle \times \dots \times F[x] / \langle f_k(x) \rangle\] <p>ì´ëŠ” ì„ì˜ì˜ ë‹¤í•­ì‹ $a_1(x), \dots, a_k(x)$ê°€ ì£¼ì–´ì¡Œì„ ë•Œ,</p> <p>ë‹¤ìŒ ì—°ë¦½ í•©ë™ì‹ì„ ë§Œì¡±í•˜ëŠ” ë‹¤í•­ì‹ $A(x)$ê°€ modulus $f(x)$ì— ëŒ€í•´ ìœ ì¼í•˜ê²Œ ì¡´ì¬í•¨ì„ ì˜ë¯¸í•œë‹¤.</p> \[\begin{aligned} A(x) &amp;\equiv a_1(x) \pmod{f_1(x)} \\ A(x) &amp;\equiv a_2(x) \pmod{f_2(x)} \\ &amp;\vdots \\ A(x) &amp;\equiv a_k(x) \pmod{f_k(x)} \end{aligned}\] <h5 id="proof">Proof</h5> <ol> <li>map ì •ì˜</li> <li>Homomorphism</li> <li>Injective</li> <li> <p>Surjective</p> </li> <li> <p><strong>Define the Map</strong></p> <p>í•¨ìˆ˜ $\phi : F[x] \to F[x] / \langle f_1(x) \rangle \times \dots \times F[x] / \langle f_k(x) \rangle$ ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•œë‹¤.</p> \[\phi(h(x)) = (h(x) \,\bmod{f_1(x)},\; \dots,\; h(x) \,\bmod{f_k(x)})\] </li> <li> <p><strong>Homomorphsim</strong></p> <p>ì´ í•¨ìˆ˜ $\phi$ëŠ” ë‹¤í•­ì‹ì˜ ë§ì…ˆê³¼ ê³±ì…ˆì„ ë³´ì¡´í•˜ë¯€ë¡œ Ring Homomorphism(ë§ì…ˆ ë³´ì¡´, ê³±ì…ˆ ë³´ì¡´, indentity ë³´ì¡´)ì´ë‹¤.</p> </li> <li> <p><strong>Injective:</strong></p> <p>ì´ í•¨ìˆ˜ê°€ ë‹¨ì‚¬ì„ì„ ë³´ì´ë ¤ë©´ â€œí•¨ìˆ˜ê°’ ${\phi}(h(x))$ê°€ $(0, \dots, 0)$ ì´ë¼ë©´, $h(x)$ê°€ ë°˜ë“œì‹œ $0$ì´ì–´ì•¼ í•¨â€ì„ ë³´ì´ë©´ ëœë‹¤.</p> <ol> <li> <p>Kernelì´ ê³µì§‘í•©ì´ ì•„ë‹ˆë¼ê³  ê°€ì •í•˜ì.</p> <p>ì¦‰, ì–´ë–¤ ë‹¤í•­ì‹ $h(x)$ê°€ quatient ring $F[x]/\langle f(x) \rangle$ì˜ ì›ì†Œì´ê³ ,</p> \[{\phi}(h(x)) = (0, 0, \dots, 0)\] <p>ë¼ê³  í•˜ì.</p> </li> <li> <p>í•¨ìˆ˜ì˜ ì •ì˜ì— ë”°ë¼, ì´ëŠ” $h(x)$ë¥¼ ê° $f_i(x)$ë¡œ ë‚˜ëˆ„ì—ˆì„ ë•Œ ë‚˜ë¨¸ì§€ê°€ ëª¨ë‘ 0ì´ë¼ëŠ” ëœ»ì´ë‹¤.</p> <p>ì¦‰,</p> \[\begin{aligned} h(x) &amp;\equiv 0 \pmod{f_1(x)}\\[.5em] h(x) &amp;\equiv 0 \pmod{f_2(x)}\\ &amp;\vdots\\[.5em] h(x) &amp;\equiv 0 \pmod{f_k(x)} \end{aligned}\] </li> <li> <p>ëª¨ë“  $f_i(x)$ëŠ” ì„œë¡œì†Œì´ë¯€ë¡œ, ê°œë³„ì ì¸ $f_i(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ë©´,</p> <p>ê·¸ë“¤ì˜ ê³±ì¸ $f(x)$ë¡œë„ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§„ë‹¤.</p> </li> <li> <p>$h(x)$ê°€ $f(x)$ì˜ ë°°ìˆ˜ë¼ëŠ” ë§ì€, $F[x]/\langle f(x) \rangle$)ì—ì„œ $0$ê³¼ ë™ì¹˜ë¼ëŠ” ëœ»ì´ë‹¤.</p> <p>\(f(x) = f_1(x)f_2(x)\cdots f_k(x) \;\mid\; h(x)\) \(\implies h(x) \equiv 0 \pmod{f(x)}\)</p> </li> </ol> <p>ì´ëŠ” $\phi(h(x))=(0,..,0)$ì´ ë˜ëŠ” $h(x)$ê°€ $0$ë°–ì— ì—†ë‹¤ëŠ” ê²ƒì´ë¯€ë¡œ</p> \[\text{Ker}({\phi}) = \{ {0} \}\] <p>ì´ê³ , Kernelì´ 0 í•˜ë‚˜ë¿ì´ë¯€ë¡œ, ì´ í•¨ìˆ˜ëŠ” ë‹¨ì‚¬(Injective)ì´ë‹¤.</p> <ul> <li> <p><strong>Kernel ì„ í†µí•œ ë™í˜• ì‚¬ìƒ êµ¬í•˜ê¸°</strong></p> <p>$\phi$ì˜ kernelì´ $\langle f(x)\rangle$ì´ë©´ $F[x]/\langle f(x)\rangle \cong \text{Im}(\phi)$ì´ë¯€ë¡œ $\phi$ì˜ Kernelì„ êµ¬í•´ ì´ë¥¼ ì¸í•œë‹¤.</p> <p>$\phi(h(x)) = (0, \dots, 0)$ ì´ ë˜ë ¤ë©´ ëª¨ë“  $i$ì— ëŒ€í•´ ë‹¤ìŒì´ ì„±ë¦½í•´ì•¼ í•œë‹¤.</p> \[h(x) \equiv 0 \pmod{f_i(x)}\] <p>ì¦‰, $h(x)$ëŠ” ëª¨ë“  $f_i(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì ¸ì•¼ í•œë‹¤.</p> <p>$f_i(x)$ë“¤ì´ ìŒë§ˆë‹¤ ì„œë¡œ ì†Œ(pairwise coprime)ì´ë¯€ë¡œ, $h(x)$ëŠ” ê·¸ë“¤ì˜ ê³±ì¸ $f(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì ¸ì•¼ í•œë‹¤.</p> \[\text{Ker}(\phi) = \{ h(x) \in F[x] \mid f(x) \text{ divides } h(x) \} = \langle f(x) \rangle\] <p>ë”°ë¼ì„œ, First Isomorphism Theoremì— ì˜í•´ ë‹¤ìŒì´ ì„±ë¦½í•œë‹¤.</p> \[F[x] / \langle f(x)\rangle = F[x] / \text{Ker}(\phi) \cong \text{Im}(\phi)\] </li> </ul> </li> <li> <p><strong>Surjectivity</strong></p> <p>ì˜¤ë¥¸ìª½ ringì˜ ì„ì˜ì˜ ì›ì†Œ $(a_1(x), \dots, a_k(x))$ì— ëŒ€í•´,</p> <p>$\phi(A(x)) = (a_1(x), \dots, a_k(x))$ë¥¼ ë§Œì¡±í•˜ëŠ” $A(x)$ê°€ ì¡´ì¬í•¨ì„ ë³´ì—¬ì•¼ í•œë‹¤.</p> <p>ê° $i$ ($1 \le i \le k$)ì— ëŒ€í•´ ë‹¤ìŒì„ ì •ì˜í•œë‹¤.</p> \[M_i(x) = \frac{f(x)}{f_i(x)} = \prod_{j \neq i} f_j(x)\] <p>$f_j(x)$ë“¤ì´ ì„œë¡œ ì†Œì´ë¯€ë¡œ, $M_i(x)$ì™€ $f_i(x)$ëŠ” ì„œë¡œ ì†Œì…ë‹ˆë‹¤ ($\gcd(M_i(x), f_i(x)) = 1$).</p> <p>ë”°ë¼ì„œ Extended Euclidean Algorithmì— ì˜í•´ ë‹¤ìŒì„ ë§Œì¡±í•˜ëŠ” ë‹¤í•­ì‹ $s_i(x), t_i(x)$ê°€ ì¡´ì¬í•œë‹¤.</p> \[s_i(x)M_i(x) + t_i(x)f_i(x) = 1\] <p>ìœ„ ì‹ì„ modulusë²• $f_i(x)$ë¡œ ë³´ë©´</p> \[s_i(x)M_i(x) \equiv 1 \pmod{f_i(x)}\] <p>ì´ê³ , $e_i(x) = s_i(x)M_i(x)$ ë¼ê³  ì •ì˜í•˜ë©´, $e_i(x)$ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì„±ì§ˆì„ ê°€ì§„ë‹¤.</p> <ul> <li>$e_i(x) \equiv 1 \pmod{f_i(x)}$</li> <li> <p>$e_i(x) \equiv 0 \pmod{f_j(x)}$ (ë‹¨, $j \neq i$)</p> <p>($M_i(x)$ê°€ $f_j(x)$ë¥¼ ì¸ìˆ˜ë¡œ í¬í•¨í•˜ë¯€ë¡œ)</p> </li> </ul> <p>ì´ì œ í•´ $A(x)$ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±í•œë‹¤.</p> \[A(x) = \sum_{i=1}^{k} a_i(x)e_i(x) = \sum_{i=1}^{k} a_i(x)s_i(x)M_i(x)\] <p>ì´ $A(x)$ë¥¼ $f_j(x)$ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ í™•ì¸í•˜ë©´</p> \[A(x) \equiv a_j(x) \cdot 1 + \sum_{i \neq j} a_i(x) \cdot 0 \equiv a_j(x) \pmod{f_j(x)}\] <p>ì´ë‹¤. ë”°ë¼ì„œ $A(x)$ëŠ” ì£¼ì–´ì§„ ëª¨ë“  í•©ë™ì‹ì„ ë§Œì¡±í•œë‹¤.</p> </li> </ol> <p>$\phi$ë¥¼ í†µí•´ ìœ ë„ëœ ì‚¬ìƒ $\bar{\phi} : F[x]/\langle f(x) \rangle \to \prod F[x]/\langle f_i(x) \rangle$ ëŠ” ë‹¨ì‚¬(Injective)ì´ë©° ì „ì‚¬(Surjective)ì´ë¯€ë¡œ ë™í˜•(Isomorphism)ì´ë‹¤.</p> <p><strong>Uniqueness (ìœ ì¼ì„± ì¦ëª…)</strong></p> <p>ë§ë¶™ì—¬, ë§Œì•½ ë‘ ë‹¤í•­ì‹ $A(x)$ì™€ $B(x)$ê°€ ëª¨ë‘ ì£¼ì–´ì§„ ì—°ë¦½ í•©ë™ì‹ì„ ë§Œì¡±í•œë‹¤ê³  ê°€ì •í•˜ì. ì¦‰, ëª¨ë“  $i=1, \dots, k$ì— ëŒ€í•˜ì—¬ ë‹¤ìŒì´ ì„±ë¦½í•œë‹¤.</p> \[A(x) \equiv a_i(x) \pmod{f_i(x)}\] \[B(x) \equiv a_i(x) \pmod{f_i(x)}\] <p>ë‘ ì‹ì„ ë¹¼ë©´,</p> \[A(x) - B(x) \equiv 0 \pmod{f_i(x)}\] <p>ì¦‰, $D(x) = A(x) - B(x)$ëŠ” ëª¨ë“  $f_i(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§„ë‹¤.</p> <p>$f_i(x)$ë“¤ì€ ì„œë¡œì†Œ(pairwise coprime)ì´ë¯€ë¡œ, $D(x)$ëŠ” ê·¸ë“¤ì˜ ê³±ì¸ $f(x) = f_1(x)\cdots f_k(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì ¸ì•¼ í•œë‹¤.</p> \[A(x) - B(x) \equiv 0 \pmod{f(x)}\] \[\therefore A(x) \equiv B(x) \pmod{f(x)}\] <p>ë”°ë¼ì„œ modulus $f(x)$ì— ëŒ€í•œ í•´ $A(x)$ëŠ” ìœ ì¼í•˜ë‹¤.</p> <h3 id="example">Example</h3> <p>ë‹¤ìŒ ì—°ë¦½ í•©ë™ì‹ì„ ë§Œì¡±í•˜ëŠ” ë‹¤í•­ì‹ $A(x)$ë¥¼ êµ¬í•˜ì‹œì˜¤.</p> \[\begin{aligned} 1.\quad A(x) &amp;\equiv 2 \pmod{x-1} \\ 2.\quad A(x) &amp;\equiv 2x + 1 \pmod{x^2 + 1} \end{aligned}\] <ul> <li> <p>$f_1(x) = x-1$, $f_2(x) = x^2 + 1$</p> <p>â‡’ $\gcd(x-1, x^2+1) = 1$ì´ë¯€ë¡œ CRT ì ìš© ê°€ëŠ¥</p> </li> <li>$f(x) = (x-1)(x^2+1) = x^3 - x^2 + x - 1$</li> <li>$a_1(x) = 2$, $a_2(x) = 2x + 1$</li> </ul> <p>$M_1(x) = {f(x)}/{f_1(x)} = x^2 + 1$</p> <p>$M_2(x) = {f(x)}/{f_2(x)} = x - 1$</p> <ol> <li> <p><strong>$M_1^{-1}(x) \pmod{x-1}$</strong></p> <p>$M_1(x) = x^2 + 1$</p> <p>$M_1(1) = 1^2 + 1 = 2$</p> <p>â†’ $2 \cdot s_1 \equiv 1 \pmod{x-1}$ì´ ë˜ëŠ” ìƒìˆ˜ $s_1$ì„ ì°¾ì•„ì•¼ í•¨</p> <p>$\mathbb{Q}$ì—ì„œ $2$ì˜ ì—­ì›ì€ ${1}/{2}$</p> <p>$\therefore M_1^{-1}(x) = {1}/{2}$</p> </li> <li> <p><strong>$M_2^{-1}(x) \pmod{x^2+1}$</strong></p> <p>$M_2(x) = x - 1$</p> <p>$x^2+1$ì´ë¯€ë¡œ</p> <ul> <li> <p>$x^2 + 1$ì„ $x-1$ë¡œ ë‚˜ëˆ„ë©´</p> \[x^2 + 1 = (x+1)(x-1) + 2\] <p>ë¡œ ë‚˜ë¨¸ì§€ê°€ 2ì´ë©°, ì‹ì„ ì •ë¦¬í•˜ë©´</p> \[2 = (x^2+1) - (x+1)(x-1)\] \[1 = \frac{1}{2}(x^2+1) - \frac{1}{2}(x+1)(x-1)\] </li> </ul> \[1 \equiv -\frac{1}{2}(x+1) \cdot (x-1) \pmod{x^2+1}\] <p>ë”°ë¼ì„œ $(x-1)$ì˜ ì—­ì›ì€ $-{1}/{2}(x+1)$</p> <p>$\therefore M_2^{-1}(x) = -{1}/{2}(x+1)$</p> </li> <li> <p><strong>í•´ $A(x)$ êµ¬ì„±</strong></p> \[A(x) = a_1 M_1 M_1^{-1} + a_2 M_2 M_2^{-1}\] \[\begin{aligned} A(x) &amp;= 2 \cdot (x^2 + 1) \cdot \left(\frac{1}{2}\right) + (2x + 1) \cdot (x - 1) \cdot \left[ -\frac{1}{2}(x+1) \right] \\ &amp;= (x^2 + 1) - \frac{1}{2}(2x+1)(x^2-1) \quad (\because (x-1)(x+1)=x^2-1) \\ &amp;= (x^2 + 1) - \frac{1}{2}(2x^3 - 2x + x^2 - 1) \\ &amp;= x^2 + 1 - x^3 + x - \frac{1}{2}x^2 + \frac{1}{2} \\ &amp;= -x^3 + \frac{1}{2}x^2 + x + \frac{3}{2} \end{aligned}\] </li> <li> <p><strong>Modulus $f(x)$ë¡œ reduction</strong></p> <p>êµ¬í•œ í•´ì˜ ì°¨ìˆ˜ê°€ $f(x)$ $3$ì°¨ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìœ¼ë¯€ë¡œ, $f(x) = x^3 - x^2 + x - 1$ë¡œ ë‚˜ëˆ„ì–´ ë‚˜ë¨¸ì§€ë¥¼ êµ¬í•´ì•¼ í•œë‹¤.</p> <p>$A(x)$ ë¥¼ $x^3 - x^2 + x - 1$ ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ êµ¬í•œë‹¤.</p> <p>$x^3 \equiv x^2 - x + 1 \pmod{f(x)}$ ê´€ê³„ë¥¼ ì´ìš©í•´ ëŒ€ì…í•œë‹¤.</p> \[\begin{aligned} A(x) &amp;\equiv -(x^2 - x + 1) + \frac{1}{2}x^2 + x + \frac{3}{2} \\ &amp;\equiv -x^2 + x - 1 + \frac{1}{2}x^2 + x + \frac{3}{2} \\ &amp;\equiv -\frac{1}{2}x^2 + 2x + \frac{1}{2} \end{aligned}\] </li> </ol> <h5 id="verification">Verification</h5> <p>êµ¬í•œ í•´ $A(x) = -{1}/{2}x^2 + 2x + {1}/{2}$ ê°€ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ í™•ì¸í•´ ë´…ì‹œë‹¤.</p> <ol> <li> <p>ì²« ë²ˆì§¸ ì¡°ê±´ ($x-1$): $x=1$ ëŒ€ì…</p> <p>\(A(1) = -\frac{1}{2} + 2 + \frac{1}{2} = 2\) \(\rightarrow A(x) \equiv 2 \pmod{x-1}\)</p> </li> <li> <p>ë‘ ë²ˆì§¸ ì¡°ê±´ ($x^2+1$): $x^2 \equiv -1$ ëŒ€ì…</p> <p>\(A(x) \equiv -\frac{1}{2}(-1) + 2x + \frac{1}{2} = \frac{1}{2} + 2x + \frac{1}{2} = 2x + 1\) \(\rightarrow A(x) \equiv 2x+1 \pmod{x^2+1}\)</p> </li> </ol> <h5 id="polynomial-multiplication-and-convolution">Polynomial multiplication and Convolution</h5> <p>Without loss of generality, $\boldsymbol{a}$ and $\boldsymbol{b}$ of degree $n - 1$ are considered in this paper. Pad them with zero if their lengths are less than $n$.</p> <ul> <li> <p><strong>Linear</strong> convolution</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]$, then</p> <p>\(\boldsymbol{c} = \sum_{k=0}^{2n-2} c_k x^k \in \mathbb{Z}_q[x],\) \(\text{where } c_k = \sum_{i+j=k} a_i b_j \bmod q\quad (k = 0, 1, \dots, 2n - 2).\)</p> <p>Here, $c$ is referred to as the linear convolution of $\boldsymbol{a}$ and $\boldsymbol{b}$.</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/!\left&lt;\phi(x)\right&gt;$. One can first compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]$, then $\boldsymbol{c} = \boldsymbol{c}â€™ \bmod \phi(x)$.</p> </li> <li> <p><strong>Cyclic</strong> convolution</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n - 1)$, then</p> <p>\(\boldsymbol{c} = \sum_{k=0}^{n-1} c_k x^k,\) \(\text{where } c_k = \sum_{i=0}^k a_i b_{k-i} + \sum_{i=k+1}^{n-1} a_i b_{n+k-i} \bmod q\quad (k = 0, 1, \dots, n - 1).\)</p> <p>And $\boldsymbol{c}$ is referred to as the cyclic convolution (CC for short) of $\boldsymbol{a}$ and $\boldsymbol{b}$.</p> </li> <li> <p><strong>Negative wrapped</strong> convolution</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n + 1)$, then</p> <p>\(\boldsymbol c = \sum_{k=0}^{n-1} c_k x^k,\) \(\text{where } c_k = \sum_{i=0}^k a_i b_{k-i} - \sum_{i=k+1}^{n-1} a_i b_{n+k-i} \bmod q \quad (k = 0, 1, \dots, n - 1).\)</p> <p>Here, $\boldsymbol{c}$ is referred to as their negative wrapped convolution (NWC for short).</p> <p>â€» $x^{n+k} = x^n \cdot x^k \equiv \mathbf{(-1)} \cdot x^k = -x^k$</p> </li> </ul> <h3 id="number-theoretic-transform-ntt">NUMBER THEORETIC TRANSFORM (NTT)</h3> <p>NTT is the special case of the discrete Fourier transform (DFT) over a finite field.</p> <p>NTT and DFT share the same formula and similar properties, except that DFT has complex twiddle factors $\exp(-2\pi i/n)$, while NTT uses an integer primitive root of unity $\omega_n$.</p> <h4 id="cyclic-convolution-based-ntt">Cyclic Convolution-based NTT</h4> <p>$n$-point CC-based NTT has two parameters.</p> <ul> <li>The length or the point $n$, where $n$ is a power of two.</li> <li>The modulus $q$, where $q$ is a prime number satisfying $q \equiv 1 \pmod n$.</li> <li> <p>It implies that the primitive $n$-th root of unity $\omega_n$ in $\mathbb{Z}_q$ exists.</p> <p>$\mathbb{Z}_q$ê°€ ì†Œìˆ˜ $q$ì— ëŒ€í•œ Fieldì´ë¯€ë¡œ,</p> <p>0ì„ ì œì™¸í•œ ê³±ì…ˆêµ° $\mathbb{Z}_q^* = {1, 2, \dots, q-1}$ì€ order$\,=q-1$ì¸ groupì´ë‹¤.</p> <p>$\mathbb{Z}_q$ì˜ ê³±ì…ˆêµ° $\mathbb{Z}_q^*$ëŠ” í•­ìƒ cyclic groupì´ë¯€ë¡œ,</p> <p>ì–´ë–¤ generator $g$ê°€ ì¡´ì¬í•˜ì—¬ $\mathbb{Z}_q^* = { g^1, g^2, \dots, g^{q-1} }$ì´ë‹¤.</p> <p>ì´ë•Œ $q \equiv 1 \pmod n$ì´ë¯€ë¡œ $n \mid (q-1)$ì´ê³ ,</p> <p>ë”°ë¼ì„œ $\mathbb{Z}_q$ì—ëŠ” order$\,=n$ì¸ cyclic subgroupì˜ generatorê°€ ì¡´ì¬í•œë‹¤.</p> <p>order$\,=n$ì¸ $x\in\mathbb{Z}_q$ëŠ” ë‹¤ìŒì„ ë§Œì¡±í•œë‹¤.</p> <ul> <li>$x^n \equiv 1 \pmod q$</li> <li>$0 &lt; k &lt; n$ ì¸ ëª¨ë“  $k$ì— ëŒ€í•´ $x^k \not\equiv 1 \pmod q$</li> </ul> <p>ì¦‰, $x$ëŠ” primitive $n$-th root of unityì´ë‹¤.</p> <p>ë”°ë¼ì„œ ì†Œìˆ˜ $q$ì— ëŒ€í•´ $q \equiv 1 \pmod n$ì´ë¼ë©´, $\mathbb{Z}_q$ì—ëŠ” primitive $n$-th root of unity <strong>$\omega_n$</strong>ê°€ ì¡´ì¬í•˜ë©°,</p> <p>íŠ¹íˆ, $\phi(n)$ê°œë§Œí¼ ì¡´ì¬í•œë‹¤.</p> </li> </ul> <p>The forward transform, denoted by NTT, is defined as: $\hat{\boldsymbol{a}} = \text{NTT}(\boldsymbol{a})$, where</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \omega_n^{ij} \bmod q \quad (j = 0, 1, \dots, n - 1).\] <ul> <li> <p>NTTì˜ matrix í‘œí˜„</p> \[NTT=\begin{bmatrix} \omega^{0\times0} &amp;\cdots &amp; \omega^{0\times j} &amp;\cdots&amp; \omega^{0\times(n-1)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\ \omega^{i\times0} &amp;\cdots &amp; \omega^{i\times j} &amp;\cdots&amp; \omega^{i\times(n-1)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\ \omega^{(n-1)\times0} &amp;\cdots &amp; \omega^{(n-1)\times j} &amp;\cdots&amp; \omega^{(n-1)\times(n-1)}\\ \end{bmatrix}\] </li> </ul> <p>The inverse transform, denoted by INTT, is defined as $\boldsymbol{a} = \text{INTT}(\hat{\boldsymbol{a}})$, where</p> \[a_i = n^{-1} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q \quad (i = 0, 1, \dots, n - 1).\] <ul> <li> <p>INTTì˜ matrix í‘œí˜„</p> \[\begin{aligned} NTT^{-1}&amp;=\frac{1}{n}\begin{bmatrix} \;\omega^{-[0\times0]} &amp;\cdots &amp; \omega^{-[0\times j]} &amp;\cdots&amp; \omega^{-[0\times(n-1)]}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \;\omega^{-[i\times0]} &amp;\cdots &amp; \omega^{-[i\times j]} &amp;\cdots&amp; \omega^{-[i\times(n-1)]}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \;\omega^{-[(n-1)\times0]} &amp;\;\;\cdots\;\; &amp; \omega^{-[(n-1)\times j]} &amp;\cdots&amp; \omega^{-[(n-1)\times(n-1)]}\; \end{bmatrix}\\ &amp; =\frac{1}{n}\begin{bmatrix} \omega^{[0\times0] + (n/2)} &amp;\cdots &amp; \omega^{[0\times j] + (n/2)} &amp;\cdots&amp; \omega^{[0\times(n-1)] + (n/2)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \omega^{[i\times0] + (n/2)} &amp;\cdots &amp; \omega^{[i\times j] + (n/2)} &amp;\cdots&amp; \omega^{[i\times(n-1)] + (n/2)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \omega^{[(n-1)\times0] + (n/2)} \!\!\!\!&amp;\cdots &amp; \!\!\!\!\omega^{[(n-1)\times j] + (n/2)} \!\!\!\!&amp;\cdots&amp;\!\!\!\! \omega^{[(n-1)\times(n-1)] + (n/2)}\\ \end{bmatrix} \end{aligned}\] </li> </ul> <p>Note that the inverse transform can be implemented by replacing the $\omega_n$ in NTT procedure with $\omega_n^{-1}$, followed by multiplying by a scale factor $n^{-1}$.</p> <h5 id="prop">Prop)</h5> <p>It always holds that $\boldsymbol{a} = \text{INTT}(\text{NTT}(\boldsymbol{a}))$.</p> <h5 id="prop-cyclic-convolution-property">Prop) Cyclic Convolution Property</h5> <p>Let $\boldsymbol{c}$ be the cyclic convolution of $\boldsymbol{a}$ and $\boldsymbol{b}$, then it holds that</p> \[\text{NTT}(\boldsymbol{c}) = \text{NTT}(\boldsymbol{a}\cdot\boldsymbol{b}) = \text{NTT}(\boldsymbol{a}) \circ \text{NTT}(\boldsymbol{b}).\] <h4 id="negative-wrapped-convolution-based-ntt">Negative Wrapped Convolution-based NTT</h4> <p>The modulus $q$ is set to be a prime number satisfying $q \equiv 1 \pmod{2n}$ such that</p> <ul> <li> <p>the primitive $2n$-th root of unity $\psi_{2n}$ in $\mathbb{Z}_q$ exists.</p> <p>[ì™œ $2n$-th root of unityë¥¼ êµ¬í•˜ëŠ”ê°€?]</p> <p>Negative Wrapped Convolutionì€ $\mathbb{Z}_q[x] / (x^n+1)$ì—ì„œ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ $x^n \equiv -1$ê°€ ë˜ëŠ” $x$ë¥¼ êµ¬í•´ì•¼ í•œë‹¤.</p> <p><code class="language-plaintext highlighter-rouge">n-th primitive roots of unityëŠ” x^n=1ì´ë¯€ë¡œ êµ¬í•˜ê³ ì í•˜ëŠ” ê·¼ì´ ì•„ë‹˜</code></p> <p>ì´ë•Œ $x$ëŠ” $x^{2n} \equiv 1$ì´ë¯€ë¡œ $q \equiv 1 \pmod{2n}$ë¡œ ì„¤ì •í•˜ë©´,</p> <p>$(\psi_{2n}^{n})^2\equiv 1\implies \psi_{2n}^{n}\equiv -1$ì¸ primitive $2n$-th root of unity $\psi_{2n}\in\mathbb{Z}_q$ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤.</p> <p>ì´ë•Œ, $\psi_{2n}$ëŠ” primitiveì´ë¯€ë¡œ $k&lt;2n$ì— ëŒ€í•˜ì—¬ $\psi_{2n}^k\neq 1$ì´ë¯€ë¡œ $\psi_{2n}^n\equiv1$ì´ë‹¤.</p> <p>â€» $\mathbb{Z}_q[x] / (x^{2n}-1)$ì˜ primitive $2n$-th roots of unity $\psi_{2n}$</p> <p>ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬ì— ì˜í•´</p> \[\mathbb{Z}_q[x] / (x^{2n}-1) \;\cong\; \underbrace{\,\mathbb{Z}_q[x] / (x^n-1)}_{\text{Cyclic Convolution}} \;\times \; \underbrace{\,\mathbb{Z}_q[x] / (x^n+1)}_{\text{Negative Wrapped}}\] <p>ì´ê³ , $\mathbb{Z}<em>q[x] / (x^{2n}-1)$ì—ì„œ êµ¬í•œ $2n$ê°œ ê·¼ì€ ${ \psi</em>{2n}^0, \psi_{2n}^1, \psi_{2n}^2, \dots, \psi_{2n}^{2n-1} }$ì´ë‹¤.</p> <p>ì´ë•Œ, $k=0,1,\,â€¦\,,n-1$ì— ëŒ€í•˜ì—¬ $\psi_{2n}^{2k}$ëŠ”</p> \[(\psi_{2n}^{2k})^n = (\psi_{2n}^{2n})^k = 1^k = 1\] <p>ì´ë¯€ë¡œ $\mathbb{Z}<em>q[x] / (x^n-1)$ì˜ ê·¼ì´ ë˜ê³ , $\psi</em>{2n}^{2k+1}$ì€</p> \[(\psi_{2n}^{2k+1})^n = (\psi_{2n}^{2n})^k \cdot \psi_{2n}^n = 1 \cdot (-1) = -1\] <p>ì´ë¯€ë¡œ $\mathbb{Z}_q[x] / (x^n+1)$ì˜ ê·¼ì´ ëœë‹¤.</p> </li> </ul> <p>Take $\omega_n = \psi_{2n}^2 \bmod q$, and write</p> \[\boldsymbol{\psi} = (1, \psi_{2n}, \psi_{2n}^2, \dots, \psi_{2n}^{n-1}),\quad \boldsymbol{\psi}^{-1} = (1, \psi_{2n}^{-1}, \psi_{2n}^{-2}, \dots, \psi_{2n}^{-(n-1)}).\] <p>Define</p> \[\bar{\boldsymbol{a}} = \boldsymbol{\psi} \circ \boldsymbol{a},\text{ where } \bar{a}_i = \psi_{2n}^i a_i\] <p>in detail, which implies</p> \[\boldsymbol{a} = \boldsymbol{\psi}^{-1} \circ \bar{\boldsymbol{a}},\text{ where } a_i = \psi_{2n}^{-i} \bar{a}_i.\] <p>$n$-point NWC-based NTT is to integrate $\boldsymbol{\psi}$ (resp., $\boldsymbol{\psi}^{-1}$) into NTT (resp., INTT), and denote them by $\text{NTT}^\psi$ (resp., $\text{INTT}^{\psi^{-1}}$), that is</p> \[\hat{\boldsymbol{a}} = \text{NTT}^\psi(\boldsymbol{a}) = \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a}),\] \[\boldsymbol{a} = \text{INTT}^{\psi^{-1}}(\hat{\boldsymbol{a}}) = \boldsymbol{\psi}^{-1} \circ \text{INTT}(\hat{\boldsymbol{a}}).\] <p><code class="language-plaintext highlighter-rouge">matrix í‘œí˜„ì€ CCì™€ ë™ì¼ (psiê°€ ì•„ë‹Œ omega ì‚¬ìš©)</code></p> <p>More specifically, the forward transform $\hat{\boldsymbol{a}} = \text{NTT}^\psi(\boldsymbol{a})$ can be written as</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \psi_{2n}^i \omega_n^{ij} \bmod q \quad (j = 0, 1, \dots, n - 1).\] <p>The inverse transform $\boldsymbol{a} = \text{INTT}^{\psi^{-1}}(\hat{\boldsymbol{a}})$ can be written as</p> \[a_i = n^{-1} \psi_{2n}^{-i} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q \quad (i = 0, 1, \dots, n - 1).\] <h5 id="prop-1">Prop)</h5> <p>It always holds that $\boldsymbol{a} = \text{INTT}^{\psi^{-1}}(\text{NTT}^\psi(\boldsymbol{a}))$.</p> <h5 id="prop-negative-wrapped-convolution-property">Prop) Negative Wrapped Convolution Property</h5> <p>Let $\boldsymbol{c}$ be the negative wrapped convolution of $\boldsymbol{a}$ and $\boldsymbol{b}$, then it holds that</p> \[\begin{aligned} \text{NTT}^\psi(\boldsymbol{c}) &amp; = \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})\\[.3em] &amp;=\text{NTT}(\boldsymbol{\psi} \circ (\underbrace{\boldsymbol{a}\cdot\boldsymbol{b}}_\text{NWC}))\\[.3em] &amp;=\text{NTT}(\underbrace{(\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b})}_{\text{CC\; }\because\ \psi_{wn}^{2k+1}\,\to\ \psi_{wn}^{2k+2}})\\[.3em] &amp;=\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{a})\circ\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{b})\\[.3em] &amp;=\text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b}). \end{aligned}\] <ul> <li> <p>Example</p> <p><strong>Initialization</strong></p> <ul> <li>$\mathbb{Z}_q[x] / (x^n+1)$ <ul> <li>$n=2$, modulus $x^2 + 1$ (ì¦‰, $x^2 \equiv -1$)</li> <li>$q=5$ ($q \equiv 1 \pmod{2n}$ ë§Œì¡±)</li> </ul> </li> <li> <p>$\psi=2$</p> <p>$2^1=2,\; 2^2=4,\; 2^3=8\equiv3,\; 2^4=16\equiv1$, $\psi^n \equiv -1 \pmod q$</p> </li> <li>$\omega=4$</li> <li>NTT matrix $N = \begin{bmatrix} 1 &amp; 1 \ 1 &amp; \omega \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 4 \end{bmatrix}$</li> <li>$\boldsymbol{a} = [1, 1]$ (ì¦‰, $x+1$)</li> <li>$\boldsymbol{b} = [2, 1]$ (ì¦‰, $x+2$)</li> </ul> <p><strong>Calculation</strong> (ë²¡í„°í‘œí˜„ê³¼ ë§ì¶”ê¸° ìœ„í•´ ë‹¤í•­ì‹ì„ ì €ì°¨í•­ë¶€í„° í‘œê¸°)</p> <p>$\boldsymbol{\psi}=[ \psi^0, \psi^1 ] = [1, 2]$</p> <ol> <li> <p>$\text{NTT}^\psi(\boldsymbol{c}) :=\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})=\text{NTT}(\boldsymbol{\psi} \circ (\boldsymbol{a}\cdot\boldsymbol{b}))$</p> <p>$\boldsymbol{c}=(1+x)(2+x) = 2 + 3x + x^2\equiv 2 + 3x + (-1) = 1+3x \implies[1,3]$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{c}=[1,2]\circ[1,3]=[1,6]\equiv[1,1]$</p> \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})=N([1,1])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 1 \end{bmatrix}=\begin{bmatrix} 2 \\ 5 \end{bmatrix}\equiv\begin{bmatrix} 2 \\ 0 \end{bmatrix}=[2,0]\] <p>$\boldsymbol{a}\cdot \boldsymbol{b}=\boldsymbol{c}=[1,3]$</p> <p>$\text{NTT}(\boldsymbol{\psi} \circ (\boldsymbol{a}\cdot \boldsymbol{b}))=[2,0]$</p> </li> <li> <p>$\text{NTT}((\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}))$</p> <p>â€» $\boldsymbol{\psi}$ë¥¼ ê³±í•´ì¤¬ê¸° ë•Œë¬¸ì— Cyclic convolution ê³µê°„ì´ ë¨ â‡’ $x^2\equiv 1$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{a}=[1,2]\circ[1,1]=[1,2]\implies1+2x$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{b}=[1,2]\circ[2,1]=[2,2]\implies 2+2x$</p> \[\begin{aligned} (\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}) &amp;=(1+2x)(2+2x)=2+4x+2x+4x^2\\ &amp;=2+6x+4(1)=6+6x\\ &amp;\equiv 1+x\implies [1,1] \end{aligned}\] \[\text{NTT}((\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}))=N([1,1])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 1 \end{bmatrix}=\begin{bmatrix} 2 \\ 5 \end{bmatrix}\equiv\begin{bmatrix} 2 \\ 0 \end{bmatrix}=[2,0]\] </li> <li> <p>$\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{a})\circ\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{b}) := \text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b})$</p> \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a})=N([1,2])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 2 \end{bmatrix}=\begin{bmatrix} 3 \\ 9 \end{bmatrix}\equiv\begin{bmatrix} 3 \\ 4 \end{bmatrix}=[3,4]\] \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{b})=N([2,2])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 2 \\ 2 \end{bmatrix}=\begin{bmatrix} 4 \\ 10 \end{bmatrix}\equiv\begin{bmatrix} 4 \\ 0 \end{bmatrix}=[4,0]\] \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a})\circ \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{b})=[3,4]\circ[4,0]=[12,0]=[2,0]\] </li> </ol> </li> </ul> <h4 id="ntt-based-polynomial-multiplication">NTT-based Polynomial Multiplication</h4> <p>NTT can be used to compute inear/cyclic/negative-wrapped convolutioLns.</p> <h5 id="linear-convolution-based-polynomial-multiplication">Linear convolution-based polynomial multiplication</h5> <p>To compute the linear convolution $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}q[x]$,</p> <p>first, pad them to the length of $2n$ with zeros, resulting with</p> \[\boldsymbol{a}' = (a_0, \dots, a_{n-1}, \underbrace{0, \dots, 0}_{\# \,0\ =\ n}) \;\text{ and }\; \boldsymbol{b}' = (b_0, \dots, b_{n-1}, \underbrace{0, \dots, 0}_{\# \,0\ =\ n}).\] <p>Second, use $2n$-point NTT/INTT for</p> \[\boldsymbol{c}=\text{INTT}(\text{NTT}(\boldsymbol{a}')\circ \text{NTT}(\boldsymbol{b}')).\] <p>Moreover, to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (\phi(x))$, one can compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]$ with $2n$-point NTT/INTT, followed by computing</p> \[\boldsymbol{c}=\boldsymbol{c}'\bmod\phi(x).\] <h5 id="cyclic-convolution-based-polynomial-multiplication">Cyclic convolution-based polynomial multiplication</h5> <p>To compute the cyclic convolution $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n - 1)$,</p> <p>one can straightly use $n$-point NTT/INTT, according to cyclic convolution property</p> \[\boldsymbol{c} = \text{INTT}(\text{NTT}(\boldsymbol{a}) \circ \text{NTT}(\boldsymbol{b})).\] <h5 id="negative-wrapped-convolution-based-polynomial-multiplication">Negative wrapped convolution-based polynomial multiplication</h5> <p>To compute the negative wrapped convolution $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n + 1)$, one can use the negative wrapped convolution property</p> \[\boldsymbol{c} = \text{INTT}^{\psi^{-1}}\left(\text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b})\right).\] <h5 id="complexity">Complexity</h5> <p>The complexity of directly computing NTT/INTT is $O(n^2)$.</p> <p>There are</p> <ul> <li>two NTTs,</li> <li>one point-wise multiplication and</li> <li>one INTT for NTT-based multiplication.</li> </ul> <p>Therefore, the complexity of NTT-based multiplication without fast algorithms is $O(n^2)$.</p> <h5 id="advantages-of-ntt">Advantages of NTT</h5> <p>Here, let NTT/INTT be any kind of forward/inverse transforms.</p> <ul> <li> <p>Firstly, both NTT and INTT are linear transformations, based on which it can save INTTs in lattice-based schemes (e.g., Kyber and Dilithium), i.e.,</p> \[\begin{aligned} \sum_{i=0}^l \boldsymbol{a}_i \boldsymbol{b}_i &amp;= \sum_{i=0}^l \text{INTT}(\text{NTT}(\boldsymbol{a}_i) \circ \text{NTT}(\boldsymbol{b}_i)) \\ &amp;= \text{INTT}(\sum_{i=0}^l \text{NTT}(\boldsymbol{a}_i) \circ \text{NTT}(\boldsymbol{b}_i)). \end{aligned}\] </li> <li>Additionally, consider $\boldsymbol{c} = \text{INTT}(\text{NTT}(\boldsymbol{a}) \circ \text{NTT}(\boldsymbol{b}))$, where $\boldsymbol{a}$ is random. Since the NTT transforms keep the randomness of a random polynomial, i.e., $\hat{\boldsymbol{a}} = \text{NTT}(\boldsymbol{a})$ is also random, one can directly generate a random polynomial, and view it as random $\hat{\boldsymbol{a}}$ already in the NTT domain, and compute $\boldsymbol{c} = \text{INTT}(\hat{\boldsymbol{a}} \circ \text{NTT}(\boldsymbol{b}))$, thus eliminating the need for the forward transform.</li> <li>Besides, NTT and INTT preserve the dimension and bit length of all individual coefficients of a polynomial, i.e., $\hat{\boldsymbol{a}}$ and $\boldsymbol{a}$ share the same dimension and bit length of any coefficient. Thus, $\hat{\boldsymbol{a}}$ can be stored where $\boldsymbol{a}$ is originally placed.</li> <li>Finally, in some cases where $\boldsymbol{a}$ is involved in multiple multiplications, $\hat{\boldsymbol{a}}$ is computed once and stored for its use in subsequent multiplications, which can save forward transforms without any extra requirement of storage.</li> </ul> <h4 id="some-tricks-for-polynomial-multiplication">SOME TRICKS FOR POLYNOMIAL MULTIPLICATION</h4> <h5 id="def-one-iteration-karatsuba-algorithm">Def) One-iteration Karatsuba algorithm</h5> <p>Let $a, b, c, d$ be any numbers or polynomials.</p> <ul> <li> <p>The one-iteration Karatsuba algorithm</p> <p>1 wordë¥¼ $X$ë¼ê³  í•  ë•Œ</p> <p>\(f=aX+b,\quad g=cX+d\) \(\begin{aligned} fg &amp;= (aX+b)(cX+d)\\ &amp;= acX^2 + (ad+bc)X + bd\\ &amp;= t_1 X^2 + t_2 X + t_3 \end{aligned}\)</p> </li> </ul> <p>implies that, to compute</p> \[t_1 = a \cdot c,\; t_2 = a \cdot d + b \cdot c \text{\quad and\quad } t_3 = b \cdot d,\] <p>first compute $t_1$ and $t_3$, and then compute $t_2$ by</p> \[t_2 = (a + b) \cdot (c + d) - t_1 - t_3.\] <ul> <li> <p>One-iteration Karatsuba algorithm saves one multiplication at the cost of three extra additions (subtractions).</p> \[\begin{aligned} t_2 &amp;= ad+bc &amp; \quad \text{2 multiplications}\\ &amp;= ad+bc+ac-ac+bd-bd\\ &amp;= ac+bc+ad+bd-ac-bd &amp; \downarrow\qquad\quad\,\\ &amp;= (a+b)(c+d)-ac-bd\\ &amp;= (a+b)(c+d)-t_1-t_2 &amp; \quad \text{1 multiplication\,} \end{aligned}\] </li> </ul> <h5 id="def-goods-trick">Def) Goodâ€™s trick</h5> <p>As for the ring $\mathbb{Z}_q[x] / (x^{h \cdot 2^k} - 1)$ where $h$ is an odd number, Goodâ€™s trick maps</p> \[\mathbb{Z}_q[x] / (x^{h \cdot 2^k} - 1) \xrightarrow{\phi\,} \left(\mathbb{Z}_q[z] / (z^{2^k} - 1)\right)[y] / (y^h - 1),\] \[\begin{aligned} \text{where }\; \boldsymbol{a} = \sum_{l=0}^{h \cdot 2^k - 1} a_l x^l \mapsto &amp;\sum_{l=0}^{h \cdot 2^k - 1} a_l y^{(l \bmod h)} z^{(l \bmod 2^k)} \\ &amp;= \sum_{i=0}^{h-1} \sum_{j=0}^{2^k-1} \tilde{a}_{i,j} y^i z^j. \end{aligned}\] <ul> <li> <p>ì›ë¦¬: ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬</p> <p>Goodâ€™s trickì˜ ê°€ì¥ ì¤‘ìš”í•œ ì¡°ê±´ì€ $N = h \cdot 2^k$ì—ì„œ $h$ê°€ í™€ìˆ˜ë¼ëŠ” ì ìœ¼ë¡œ, $\gcd(h, 2^k) = 1$ì´ë‹¤.</p> <p>CRTì— ì˜í•´, ì„œë¡œì†Œì¸ ë‘ ì •ìˆ˜ $h, 2^k$ì— ëŒ€í•´ ë‹¤ìŒ Group Isomorphismì´ ì„±ë¦½í•œë‹¤.</p> \[\mathbb{Z}_{h \cdot 2^k} \cong \mathbb{Z}_h \times \mathbb{Z}_{2^k}\] <p>ì´ ë™í˜• ì‚¬ìƒì„ í†µí•´ $l$ì„ ë‹¤ìŒê³¼ ê°™ì´ ë§¤í•‘í•œë‹¤.</p> \[l \mapsto (l \bmod h, \ l \bmod 2^k)=(i,j)\] \[l = \underbrace{i \cdot [2^k \cdot ((2^k)^{-1} \bmod h)]}_{i \text{ component}} + \underbrace{j \cdot [h \cdot (h^{-1} \bmod 2^k)]}_{j \text{ component}} \pmod{h \cdot 2^k}\] <p>$i = l \bmod h$ë¥¼ ì°¨ìˆ˜ë¡œ ê°–ëŠ” ë³€ìˆ˜(formal variable)ë¥¼ $y$, $j = l \bmod 2^k$ë¥¼ ì°¨ìˆ˜ë¡œ ê°–ëŠ” ë³€ìˆ˜ë¥¼ $z$ë¼ê³  í•˜ë©´, $x$ë¼ëŠ” í•˜ë‚˜ì˜ ë³€ìˆ˜ê°€ $y, z$ë¼ëŠ” ë‘ ê°œì˜ ë³€ìˆ˜ë¡œ ë¶„ë¦¬ë˜ë©´ì„œ, 1ì°¨ì› ë‹¤í•­ì‹ì´ í–‰ë ¬ í˜•íƒœì˜ 2ì°¨ì› ë‹¤í•­ì‹ìœ¼ë¡œ ë³€í™˜ëœë‹¤.</p> <p>\(\phi(x^l)= y^{(l \bmod h)} \!\cdot\! z^{(l \bmod 2^k)}\) \(a_l = \tilde{a}_{i,j}\)</p> <p>ì´ ë°©ì‹ì€ í° 1ì°¨ì› ë‹¤í•­ì‹ í™˜ $\mathbb{Z}_q[x] / (x^N-1)$ì„ ë‹¤ë£¨ê¸° ì‰¬ìš´ ì‘ì€ ë‘ ê°œì˜ ë§ì˜ Tensor Product í˜•íƒœì¸ $(\mathbb{Z}_q[z] / (z^{2^k} - 1)) \otimes (\mathbb{Z}_q[y] / (y^h - 1))$ë¡œ decompositioní•˜ëŠ” ì¥ì ì´ ìˆë‹¤.</p> <p>ì´ ë¶„í•´ë¥¼ í†µí•´ $N$-point NTTë¥¼ ìˆ˜í–‰í•˜ëŠ” ëŒ€ì‹ , $h$ê°œì˜ $2^k$-point NTTì™€ $2^k$ê°œì˜ $h$-point NTTë¡œ ìª¼ê°œì„œ ë³‘ë ¬ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•´ì§„ë‹¤.</p> </li> </ul> <p>Write the coefficients $\tilde{a}_{i,j}$ into a matrix $\tilde{A} = (\tilde{a}_{i,j})_{h \times 2^k}$, and do $h$ parallel $2^k$-point NTT over $\mathbb{Z}_q[z] / (z^{2^k} - 1)$ with each row.</p> <p>The corresponding point-wise multiplications are $2^k$ parallel degree-$(h - 1)$ polynomial multiplications in the ring $\mathbb{Z}_q[y] / (y^h - 1)$ with each column from $\tilde{A}$. Then we do $h$ parallel $2^k$-point INTT with each row. Denote the resulting matrix by $\tilde{C} = (\tilde{c}_{i,j})_{h \times 2^k}$.</p> <p>Map $\sum_{i=0}^{h-1} \sum_{j=0}^{2^k-1} \tilde{c}_{i,j} y^i z^j$ back to $c = \sum_{l=0}^{h \cdot 2^k - 1} c_l x^l \in \mathbb{Z}_q[x] / (x^{h \cdot 2^k} - 1)$ according to the CRT formula</p> \[l = ((2^k)^{-1} \bmod h) \cdot 2^k \cdot i + (h^{-1} \bmod 2^k) \cdot h \cdot j \bmod h \cdot 2^k\] <p>to obtain $c_l x^l$ from $\tilde{c}_{i,j} y^i z^j$.</p> <h5 id="def-schÃ¶nhages-trick">Def) SchÃ¶nhageâ€™s trick</h5> <p>Map the multiplicand</p> \[\begin{aligned} &amp; a = \sum_{i=0}^{2mn-1} a_i x^i \in \mathbb{Z}_q[x] / (x^{2mn} - 1) \\[1.5em] &amp; \to\; \sum_{j=0}^{2n-1} (\sum_{i=0}^{m-1} a_{m \cdot j + i} x^i) y^j \in \left(\mathbb{Z}_q[x][y] / (y^{2n} - 1)\right)/(x^m - y) \text{ with } y = x^m. \end{aligned}\] <p>To compute multiplication in $(\mathbb{Z}_q[x][y] / (y^{2n} - 1))/(x^m - y)$,</p> <p>one can first compute that in $\mathbb{Z}_q[x][y] / (y^{2n} - 1)$, and then obtain the result modulo $(x^m - y)$.</p> <p>And to compute multiplication in $\mathbb{Z}_q[x]$ with multiplicands of degree less than $m$,</p> <p>we can do it in $\mathbb{Z}_q[x] / (x^{2m} + 1)$ without modulo $(x^{2m} + 1)$.</p> <p>Therefore, multiplication in $\mathbb{Z}_q[x][y] / (y^{2n} - 1)$ can be computed in $(\mathbb{Z}_q[x] / (x^{2m} + 1))[y] / (y^{2n} - 1)$.</p> <p>Note that it is an NTT-friendly ring and $x$ is the primitive $4m$-th root of unity in $\mathbb{Z}_q[x] / (x^{2m} + 1)$.</p> <ul> <li> <p>ì›ë¦¬: ë¸”ë¡í™”</p> \[a(x) = a_0 + a_1 x + \dots + a_{2mn-1} x^{2mn-1}\] <p>$x^m = y$ë¼ê³  í•˜ê³ , ë‹¤í•­ì‹ $a(x)$ë¥¼ $m$ê°œ í•­ì”© ë¸”ë¡ìœ¼ë¡œ ë‚˜ëˆˆë‹¤ê³  í•˜ì.</p> <p>$x$ì˜ ì§€ìˆ˜ $l$ì„ $m$ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ëª«($j$)ê³¼ ë‚˜ë¨¸ì§€($i$)ë¡œ ë³´ë©´</p> \[l = m \cdot j + i \quad (0 \le i &lt; m)\] <p>ì´ë¯€ë¡œ</p> \[A(y) = \sum_{j=0}^{2n-1} \left( \sum_{i=0}^{m-1} a_{m \cdot j + i} x^i \right) y^j\] <p>ì´ê³  $A(y)$ëŠ” $y$ì— ëŒ€í•œ ë‹¤í•­ì‹ì´ë‹¤.</p> <p>ì´ë•Œ ê³„ìˆ˜ëŠ” ìƒìˆ˜ê°€ ì•„ë‹Œ, $x$ì— ëŒ€í•œ (ì°¨ìˆ˜ $m$ ë¯¸ë§Œì˜) ë‹¤í•­ì‹ì´ë‹¤.</p> <p>ë”°ë¼ì„œ $y$ì— ëŒ€í•˜ì—¬ $2n$-point NTTë¥¼ ìˆ˜í–‰í•´ì•¼ í•˜ë©°, ê³„ìˆ˜ë¼ë¦¬ ë§ì…ˆ/ê³±ì…ˆì„ í•  ë•Œ modulus $x^{2m}+1$ìœ¼ë¡œ ë‹¤í•­ì‹ ì—°ì‚°ì„ ìˆ˜í–‰í•´ì•¼ í•œë‹¤.</p> <p>ì´ ê¸°ë²•ì€ NTTë¥¼ ì ìš©í•˜ê³  ì‹¶ì€ë° ì ì ˆí•œ $q$ê°€ ì—†ì„ ë•Œ í™œìš©ëœë‹¤.</p> <p>NTTë¥¼ í•˜ë ¤ë©´ $N$-th root of Unity)ê°€ $\mathbb{Z}_q$ ì•ˆì— ìˆì–´ì•¼ í•˜ì§€ë§Œ , $q$ê°€ ì‘ê±°ë‚˜ ì¡°ê±´ì´ ì•ˆ ë§ìœ¼ë©´ ì´ëŸ¬í•œ ê·¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.</p> <p>SchÃ¶nhageâ€™s Trickì€ $q$ë¥¼ ì°¾ëŠ” ëŒ€ì‹  ë³€ìˆ˜ $x$ ìì²´ë¥¼ root of Unityë¡œ ì‚¬ìš©í•œë‹¤.</p> <p>ê³„ì‚°í•˜ëŠ” ringì˜ modulusê°€ $x^{2m} + 1$ì´ë¯€ë¡œ, $x^{2m} \equiv -1$ì´ê³  ë”°ë¼ì„œ $x^{4m} \equiv 1$ì´ ëœë‹¤.</p> <p>ì¦‰, $x$ë¼ëŠ” ë‹¤í•­ì‹ ìì²´ê°€ $4m$-th root of Unity ì—­í• ì„ í•˜ë¯€ë¡œ,</p> <p>$\mathbb{Z}_q$ì— $N$-th root of unityê°€ ì—†ì–´ë„, ringì„ í™•ì¥í•¨ìœ¼ë¡œì¨ ì–µì§€ë¡œ NTTê°€ ê°€ëŠ¥í•˜ê²Œ ë§Œë“  ê²ƒì´ë‹¤.</p> <p>ë˜í•œ, Goodâ€™s Trickì€ $N = h \cdot 2^k$ì²˜ëŸ¼ ì„œë¡œì†Œì¸ ê²½ìš°ì—ë§Œ êµ¬ì¡°ë¥¼ ë¶„í•´í•  ìˆ˜ ìˆëŠ” ë°˜ë©´, SchÃ¶nhageâ€™s Trickì€ ì„œë¡œì†Œê°€ ì•„ë‹ˆë”ë¼ë„ $N = m \cdot n$ì´ê¸°ë§Œ í•˜ë©´ ì–¸ì œë“  ringê³¼ ì—°ì‚° ë‹¨ìœ„ë¥¼ ë¶„í•´í•  ìˆ˜ ìˆë‹¤.</p> </li> </ul> <h5 id="nussbaumers-trick">Nussbaumerâ€™s trick</h5> <p>Nussbaumerâ€™s trick is similar to SchÃ¶nhageâ€™s trick.</p> <p>It maps</p> \[\begin{aligned} &amp;a = \sum_{i=0}^{2mn-1} a_i x^i \in \mathbb{Z}_q[x] / (x^{2mn} + 1) \\[1.5em] &amp;\to \sum_{i=0}^{m-1} (\sum_{j=0}^{2n-1} a_{m \cdot j + i} y^j) x^i \in \left(\mathbb{Z}_q[y] / (y^{2n} + 1)\right)[x] / (x^m - y) \; \text{ with } \; y = x^m. \end{aligned}\] <p>To compute multiplication in $(\mathbb{Z}_q[y] / (y^{2n} + 1))[x] / (x^m - y)$,</p> <p>first compute multiplication in $(\mathbb{Z}_q[y] / (y^{2n} + 1))[x]$,</p> <p>and then obtain the result modulo $(x^m - y)$.</p> <p>And to compute multiplication in $(\mathbb{Z}_q[y] / (y^{2n} + 1))[x]$ with multiplicands of degree less than $n$,</p> <p>one can do it in $(\mathbb{Z}_q[y] / (y^{2n} + 1))[x] / (x^{2n} - 1)$ for $n \ge m$ without modulo $(x^{2n} - 1)$.</p> <p>Note that it is an NTT-friendly ring and $y$ is the primitive $4n$-th root of unity in $\mathbb{Z}_q[y] / (y^{2n} + 1)$.</p> <ul> <li> <p>ì›ë¦¬: ì¶• ë³€í™˜</p> <p>ì´ ê¸°ë²•ì€ ë‘ ë‹¨ê³„ì˜ ì¶• ë³€í™˜ì„ ì—°ì†ì ìœ¼ë¡œ ìˆ˜í–‰í•œë‹¤.</p> <p>ë¨¼ì € SchÃ¶nhageì™€ ë™ì¼í•˜ê²Œ, ì›ë˜ ë‹¤í•­ì‹ $a$ê°€ $\mathbb{Z}_q[x] / (x^{2mn} + 1)$ì— ìˆì„ ë•Œ</p> <p>ì´ë¥¼ $m$ê°œ í•­ ë‹¨ìœ„ë¡œ ë‚˜ëˆ  $y=x^m$ìœ¼ë¡œ ì¹˜í™˜í•˜ì—¬ 2ì°¨ì› í˜•íƒœë¡œ ë§Œë“ ë‹¤.</p> \[a = \sum_{l=0}^{2mn-1} a_l x^l \;\mapsto\; \sum_{j=0}^{2n-1} \left(\sum_{i=0}^{m-1} a_{m \cdot j + i} x^i \right) y^j \in (\mathbb{Z}_q[x] / (x^m - y))[y] / (y^{2n} + 1)\] <p>ê²°ê³¼ì ìœ¼ë¡œ, $y$ì— ëŒ€í•œ ë‹¤í•­ì‹ì´ ë˜ë©°, ê³„ìˆ˜ëŠ” $x$ì— ëŒ€í•œ ë‹¤í•­ì‹ì´ ëœë‹¤.</p> <p>ìµœì¢…ì ìœ¼ë¡œ ì–»ê³ ì í•˜ëŠ” ringì€ $\mathbb{Z}_q[y] / (y^{2n} + 1)$ì´ ê³„ìˆ˜ê°€ ë˜ê³ ,</p> <p>$x$ê°€ ë³€ìˆ˜ê°€ ë˜ëŠ” ring $(\mathbb{Z}_q[y] / (y^{2n} + 1))[x] / (x^m - y)$ì´ë‹¤.</p> \[\sum_{j=0}^{2n-1} \underbrace{\left(\, \sum_{i=0}^{m-1} a_{m j + i} x^i \right)}_{\text{Coefficient } C_j(x)} y^j \;\,=\;\; \sum_{i=0}^{m-1} \underbrace{\left(\, \sum_{j=0}^{2n-1} a_{m j + i} y^j \right)}_{\text{Coefficient } D_i(y)} x^i\] <p>ì´ ringì€ $x$ì˜ ì°¨ìˆ˜ê°€ $m$ ë¯¸ë§Œ, $y$ì˜ ì°¨ìˆ˜ê°€ $2n$ ë¯¸ë§Œì´ë©°, $y$ê°€ $4n$-th root of unity ì—­í• ì„ í•˜ê²Œ ëœë‹¤.</p> <p>Nussbaumerâ€™s TrickëŠ” ê³„ì‚°ì˜ íš¨ìœ¨ì„± ê·¹ëŒ€í™”í•œë‹¤.</p> <p>ì´ ê¸°ë²•ì€ $\mathbb{Z}_q$ì— $N$-th root of unityê°€ ì—†ì„ ë•Œë„ ë³€ìˆ˜ $y$ë‚˜ $x$ ìì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ NTTì™€ ìœ ì‚¬í•œ ê³ ì† ë³€í™˜(Polynomial Transform)ì„ ê°•ì œë¡œ ì ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤.</p> <p>ë˜í•œ, ì „ì²´ $2mn$-ì°¨ìˆ˜ ë‹¤í•­ì‹ì˜ ê³±ì…ˆì„ $y$ì— ëŒ€í•œ $2n$-point NTTë¡œ ë°”ê¾¸ë©°, ì´ ê³¼ì •ì—ì„œ $2n$ê°œì˜ ì‘ì€ ê³±ì…ˆì„ ë³‘ë ¬ë¡œ ìˆ˜í–‰í•˜ê²Œ ëœë‹¤.</p> <p>ê°€ì¥ í° ì´ì ì€ ì‘ì€ ê³±ì…ˆì„ í•  ë•Œ $\text{modulo } (x^{2m} + 1)$ ëŒ€ì‹  $\text{modulo } (x^{2n} - 1)$ê³¼ ê°™ì€ ë‹¨ìˆœí•œ moduloë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë³€í™˜í•œë‹¤ëŠ” ì ì´ë‹¤.</p> </li> </ul> <h4 id="-number-theoretic-transform-over-mathbbz_qx--xn-xn2-1">[+] NUMBER THEORETIC TRANSFORM OVER $\mathbb{Z}_Q[X] / (X^N-x^{N/2} +1)$</h4> <p>In this section, introduce some progresses about relaxing the requirement of $n$ being power-of-two such that NTT can be utilized over non-power-of-two rings.</p> <h5 id="incomplete-fft-trick-over-mathbbz_qx--xn--xn2-1">Incomplete FFT trick over $\mathbb{Z}_q[x] / (x^n -x^{n/2} +1)$</h5> <p>Some progress about relaxing the requirement of $n$ being a power-of-two is made by Lyubashevsky and Seiler.</p> <p>They first introduced a special incomplete NTT to lattice-based cryptographic schemes,</p> <p>by offering a new non-power-of-two ring structure $\mathbb{Z}_q[x] / (x^n - x^{n/2} + 1)$ where $n = 3 \cdot 2^e$</p> <p>instead of a power of two and $q$ is a prime number satisfying $q \equiv 1 \pmod n$ such that $\psi_n$ exits.</p> <ul> <li> <p>Actually, $x^n - x^{n/2} + 1$ is the $3n$-th cyclotomic polynomial of degree $n$, where $n = 3^l \cdot 2^e\; (l \ge 0, e \ge 1)$, not a power-of-two cyclotomic polynomial anymore.</p> <p>\(\Phi_{3n}(x) = x^n - x^{n/2} + 1\) \(\Phi_{3n}(x) = \Phi_{6(n/2)}(x) = \Phi_6(x^{n/2}) = (x^{n/2})^2 - (x^{n/2}) + 1\) \(\therefore \Phi_{3n}(x) = x^n - x^{n/2} + 1\)</p> <p>ì´ë•Œ $\Phi_{3n}(x)$ì˜ ë‘ ê·¼ì˜ í•©ì€ $-(-1)/1=1$, ê³±ì€ $1/1=1$.</p> <p>$\zeta_1$ì˜ orederê°€ $3^l \cdot 2^e$ ê¼´ì´ì–´ì•¼ í•˜ë¯€ë¡œ $\zeta_1 = \psi_n^{n/6}$ ì´ë¼ í•˜ê³ ,</p> <p>orderê°€ ìµœì†Œì¸ 6ì¼ ë•Œ</p> \[\zeta_1^6 = 1 \implies \zeta_1\cdot \zeta_2 = \zeta_1\cdot\zeta_1^5 = 1\] <p>ì´ë¯€ë¡œ ë‚˜ë¨¸ì§€ í•˜ë‚˜ì˜ ê·¼ì€ $\zeta_2 = \zeta_1^5$ ë¼ í•œë‹¤.</p> </li> </ul> <p>The main observation they use is the CRT map, as follows</p> \[\mathbb{Z}_q[x] / (x^n - x^{n/2} + 1) \;\cong\; \mathbb{Z}_q[x] / (x^{n/2} - \zeta_1) \times \mathbb{Z}_q[x] / (x^{n/2} - \zeta_2),\] \[\text{where \; } \zeta_1 + \zeta_2 = 1\text{ and }\zeta_1 \cdot \zeta_2 = 1.\] <p>In their instantiation, they choose $\zeta_1 = \psi_n^{n/6}$ and $\zeta_2 = \zeta_1^5$.</p> <p>As for its forward transform, $\boldsymbol{a} \in \mathbb{Z}q[x] / (x^n - x^{n/2} + 1)$ from the $0$-th level generates its images</p> \[\boldsymbol{a}_l = \boldsymbol{a} \bmod x^{n/2} - \zeta_1 \in \mathbb{Z}q[x] / (x^{n/2} - \zeta_1)\] <p>and</p> \[\boldsymbol{a}_r = \boldsymbol{a} \bmod x^{n/2} - (1 - \zeta_1) \in \mathbb{Z}q[x] / (x^{n/2} - \zeta_2)\] <p>respectively in the first level, by using the fact that $\zeta_2 = 1 - \zeta_1$. In order to get the coefficients, one can compute</p> \[\quad a_{l,i} = a_i + \zeta_1 a_{i+n/2}, \;\; a_{r,i} = a_i + a_{i+n/2} - \zeta_1 a_{i+n/2}\quad (i = 0, 1, \dots, n/2 - 1).\] <p>Different from the radix-2 Cooley-Tukey algorithm, there are extra $n/2$ additions in this case.</p> <p>These additional additions donâ€™t cost much.</p> <p>For a fast NTT algorithm, one can continue with a similar radix-2 ($\log \frac{n}{3}$)-level FFT trick in $\mathbb{Z}_q[x] / (x^{n/2} - \zeta_1)$ and $\mathbb{Z}_q[x] / (x^{n/2} - \zeta_2)$, as in the power-of-two cyclotomic rings above,</p> <p>until the leaf nodes are of the form $\mathbb{Z}_q[x] / (x^3 - \psi_n^j)$ instead of linear terms.</p> <p>The inverse transform can be obtained by inverting the trick mentioned above, where Gentleman-Sande butterflies are used in the radix-2 steps.</p> <p>The point-wise multiplication is performed about the corresponding polynomials of degree 2 in each $\mathbb{Z}_q[x] / (x^3 - \psi_n^j)$. Detailedly, the CRT map can be described as follows</p> \[\mathbb{Z}_q[x] / (x^n - x^{n/2} + 1) \;\cong\; \prod_{j \in \mathbb{Z}_n^\times} \mathbb{Z}_q[x] / (x^3 - \psi_n^j),\] <p>where $\mathbb{Z}_n^\times$ is the group of invertible elements of $\mathbb{Z}_n$.</p> <h5 id="splitting-polynomial-ring-over-mathbbz_qx--xn--xn2-1">Splitting Polynomial Ring over $\mathbb{Z}_q[x] / (x^n -x^{n/2} +1)$</h5> <p>The method based on splitting the polynomial ring can be generalized to the ring $\mathbb{Z}_q[x] / (x^n - x^{n/2} + 1)$ where $n = 3 \cdot 2^e$ and $q$ is a prime number, based on which Liang et al. proposed a generalized, modular, and parallelizable NTT method referred to as Generalized 3-NTT (G3-NTT for simplicity).</p> <p>Similarly, let $\alpha, \beta$ be non-negative integers. The general $\alpha$-round G3-NTT with $\beta$ levels cropped is essentially based on the following isomorphism.</p> \[\Psi_{\alpha, 3} : \mathbb{Z}_q[x] / (x^n - x^{n/2} + 1) \;\cong\; \left(\mathbb{Z}_q[y] / (y^{\frac{n}{3 \cdot 2^\alpha}} - y^{\frac{n}{3 \cdot 2^{\alpha+1}}} + 1)\right)[x] / (x^{3 \cdot 2^\alpha} - y)\] \[\boldsymbol{a} = \sum_{i=0}^{n-1} a_i x^i \;\mapsto\; \Psi_{\alpha, 3}(\boldsymbol{a}) =\!\!\! \sum_{i=0}^{3 \cdot 2^\alpha - 1}\!\! \left( \sum_{j=0}^{({n}/{3 \cdot 2^\alpha}) - 1 \!\!\!\!\!\!} a_{3 \cdot 2^\alpha \cdot j + i} y^j \right)\! x^i\] <p>where $y^{ {n}/{3 \cdot 2^\alpha}} - y^{ {n}/{3 \cdot 2^{\alpha+1}}} + 1$ is the ${n}/{2^\alpha}$-th cyclotomic polynomial of degree ${n}/{3 \cdot 2^\alpha}$.</p> <p>Similar to NTRU, there is a CRT map as follows</p> \[\mathbb{Z}_q[y] / (y^{ {n}/{3 \cdot 2^\alpha}\!\!\!} - y^{ {n}/{3 \cdot 2^{\alpha+1}}\!\!\!} + 1) \;\cong\; \mathbb{Z}_q[y] / (y^{ {n}/{3 \cdot 2^{\alpha+1}}\!\!\!} - \zeta_1) \times \mathbb{Z}_q[y] / (y^{ {n}/{3 \cdot 2^{\alpha+1}}\!\!\!} - \zeta_2)\] <p>where $\zeta_1 + \zeta_2 = 1,\ \zeta_1 \cdot \zeta_2 = 1$.</p> <p>It turns out that radix-2 truncated-NTTs can be performed in $\mathbb{Z}_q[y] / (y^{ {n}/{3 \cdot 2^{\alpha+1}}} - \zeta_1)$ and $\mathbb{Z}_q[y] / (y^{ {n}/{3 \cdot 2^{\alpha+1}}} - \zeta_2)$.</p> <p>If there are $\beta$ levels to be cropped, $\beta = 0, 1, \dots, \log \frac{n}{3 \cdot 2^\alpha} - 1$, the modulus $q$ can be chosen to satisfy only $q \equiv 1 \bmod{ n/2{\alpha+\beta}}$ such that the primitive ${n}/{2^{\alpha+\beta}}$-th root of unity $\psi_{n/2^{\alpha+\beta}}$ exits.</p> <p>The leaf nodes of the CRT tree map are degree-$2^\beta$ polynomials, e.g., $\mathbb{Z}_q[y] / (y^{2^\beta} - \psi_{n/2^{\alpha+\beta}}^j)$.</p> <p>They choose $\zeta_1 = \psi_{n/2^{\alpha+\beta}}^{n/(6 \cdot 2^{\alpha+\beta})}$ and $\zeta_2 = \zeta_1^5$.</p> <p>One-iteration Karatsuba algorithm can be used in a same way as H-NTT.</p> <p>Given appropriate and fixed $(n, q)$, the computational complexity of G3-NTT can reach its optimization if $\alpha = 0, \beta = 0$.</p> <h3 id="basic-radix-2-fast-number-theoretic-transform">BASIC RADIX-2 FAST NUMBER THEORETIC TRANSFORM</h3> <p>Here, â€œradix-2â€ means the length $n$ of NTT has a factor as a power of two, resulting that original algorithm can be divided into two parts of less length.</p> <table> <thead> <tr> <th>Transforms</th> <th>Cooley-Tukey algorithm</th> <th>Gentleman-Sande algorithm</th> </tr> </thead> <tbody> <tr> <td>$\text{NTT}$</td> <td>$\text{NTT}_{bo\to no}^{CT}, \text{NTT}_{no\to bo}^{CT}$</td> <td>$\text{NTT}_{bo\to no}^{GS}, \text{NTT}_{no\to bo}^{GS}$</td> </tr> <tr> <td>$\text{INTT}$</td> <td>$\text{INTT}_{bo\to no}^{CT}, \text{INTT}_{no\to bo}^{CT}$</td> <td>$\text{INTT}_{bo\to no}^{GS}, \text{INTT}_{no\to bo}^{GS}$</td> </tr> <tr> <td>$\text{NTT}^\psi$</td> <td>$\text{NTT}_{bo\to no}^{CT, \psi}, \text{NTT}_{no\to bo}^{CT, \psi}$</td> <td>â€”</td> </tr> <tr> <td>$\text{INTT}^{\psi^{-1}}$</td> <td>â€”</td> <td>$\text{INTT}_{bo\to no}^{GS, \psi^{-1}}, \text{INTT}_{no\to bo}^{GS, \psi^{-1}}$</td> </tr> </tbody> </table> <h4 id="fft-trick">FFT Trick</h4> <h5 id="thm-chinese-remainder-theorem-in-ring-form">Thm. Chinese Remainder Theorem in ring form</h5> <p>Let $R$ be a commutative ring with multiplicative identity,</p> <p>$I_1, I_2,\,â€¦\,,I_k$ be ideals in $R$ that are pairwise co-prime, and $I$ be their intersection.</p> <p>Then there is a ring isomorphism</p> \[\Phi:R/I\cong R/I_1 \times R/I_2 \times \cdots \times R/I_k.\] <p>FFT trick means that according to Theorem,</p> <p>for polynomial rings $\mathbb{Z}_q[x] / (x^{2m}-\omega^2)$ where $m&gt;0$ and invertible $\omega\in\mathbb{Z}_q$,</p> \[\Phi: \mathbb{Z}_q[x] / (x^{2m} - \omega^2) \;\cong\; \mathbb{Z}_q[x] / (x^m - \omega) \times \mathbb{Z}_q[x] / (x^m + \omega)\] \[\boldsymbol{a} \mapsto (\boldsymbol{a}' = \boldsymbol{a} \bmod x^m - \omega, \boldsymbol{a}'' = \boldsymbol{a} \bmod x^m + \omega)\] <p>and the detailed mapping process</p> \[\Phi\left(\sum_{i=0}^{2m-1} a_i x^i\right) = \left(\sum_{i=0}^{m-1} (a_i + \omega \cdot a_{i+m}) x^i,\;\ \sum_{i=0}^{m-1} (a_i - \omega \cdot a_{i+m}) x^i\right)\] \[\Phi^{-1}\left(\sum_{i=0}^{m-1} a'_i x^i,\;\ \sum_{i=0}^{m-1} a''_i x^i\right) =\; \sum_{i=0}^{m-1} \frac{1}{2}(a'_i + a''_i) x^i + \sum_{i=0}^{m-1} \frac{\omega^{-1}}{2}(a'_i - a''_i) x^{i+m}.\] <p>As for the forward FFT trick, it is very effective to compute $\boldsymbol{a}â€™$ and $\boldsymbol{a}â€™â€™$.</p> <p>Their $i$-th coefficient can be computed via</p> \[a'_i = a_i + \omega \cdot a_{i+m},\;\; a''_i = a_i - \omega \cdot a_{i+m},\] <p>where $\omega \cdot a_{i+m}$ is computed once but used twice, $i = 0, 1, \dots, m-1$.</p> <p>This type of operation is known as the Cooley-Tukey butterfly or CT butterfly<code class="language-plaintext highlighter-rouge">Multiplication â†’ Addition</code> for short.</p> <p><img src="/june.github.io/assets/img/post/ntt/image.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>The forward FFT trick totally takes $m$ multiplications, $m$ additions, and $m$ subtractions.</p> <p>As for the inverse FFT trick, the $i$-th and $(i + \frac{n}{2})$-th coefficient of $\boldsymbol{a}$ can be derived from the $i$-th coefficient of $\boldsymbol{a}â€™$ and $\boldsymbol{a}â€™â€™$.</p> \[a_i = (a'_i + a''_i)/2,\quad a_{i+m} = \omega^{-1}(a'_i - a''_i)/2\quad (i = 0, 1, \dots, m-1).\] <p>In the practical applications, the scale factor 2 can be omitted, with multiplying a total factor in the end.</p> <p>This type of operation is known as Gentlemen-Sande butterfly or GS butterfly<code class="language-plaintext highlighter-rouge">Addition â†’ Multiplication</code> for short.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_1.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Based on the FFT trick, introduce the fast algorithms to compute NTT and INTT over $\mathbb{Z}_q[x] / (x^n - 1)$, as well as $\text{NTT}^\psi$ and $\text{INTT}^{\psi^{-1}}$ over $\mathbb{Z}_q[x] / (x^n + 1)$ in the subsequent two subsections.</p> <h4 id="fft-trick-for-cc-based-ntt-over-mathbbz_qx--xn---1">FFT Trick for CC-based NTT over $\mathbb{Z}_q[x] / (x^n - 1)$</h4> <p>How to use the FFT trick to compute NTT and INTT over $\mathbb{Z}_q[x] / (x^n - 1)$,</p> <p>where $n$ is a power of two and $q$ is a prime number satisfying $q \equiv 1 \pmod n$.</p> <p>Denote by $\omega_n$ the primitive $n$-th root of unity in $\mathbb{Z}_q$.</p> \[\mathbb{Z}_q[x] / (x^n - 1) \;\cong\; \mathbb{Z}_q[x] / (x^{\frac{n}{2} } - 1) \times \mathbb{Z}_q[x] / (x^{\frac{n}{2} } + 1)\] <p>Notice that the forward FFT trick can be applied repeatedly to map $\mathbb{Z}_q[x] / (x^{\frac{n}{2} } \pm 1)$, according to the fact $x^{\frac{n}{2} } + 1 = x^{\frac{n}{2} } - \omega_n^{\frac{n}{2} }$.</p> <p>In fact, $x^n - 1$ has $n$ distinct roots in $\mathbb{Z}_q$, i.e., $\omega_n^i\ (i = 0, 1, \dots, n-1)$.</p> <p>Therefore, forward FFT trick can be applied recursively from $\mathbb{Z}_q[x] / (x^n - 1)$ all the way down to linear terms,</p> \[\mathbb{Z}_q[x] / (x^n - 1) \cong \prod_{i=0}^{n-1} \mathbb{Z}_q[x] / (x - \omega_n^{\text{brv}_n(i)}).\] <p>Finally, $\boldsymbol{a}$ generates its images in $\mathbb{Z}_q[x] / (x - \omega_n^{\text{brv}_n(i)})$, i.e., $\hat{a}_{\text{brv}_n(i)}$, which turns out to be the coefficient of $\hat{\boldsymbol{a}}$ indexed by $\text{brv}_n(i)$.</p> <p>Notice that using the Cooley-Tukey algorithm, the coefficients of the input polynomials are indexed under natural order, while the coefficients of the output polynomials are indexed under bit-reversed order.</p> <p>This Cooley-Tukey NTT algorithm is denoted by $\text{NTT}^{CT}_{no \to bo}$,</p> <p>where the subscripts $no \to bo$ indicate that the input coefficients are under natural order and the output coefficients are under bit-reversed order.</p> <p>The signal flow of $\text{NTT}^{CT}_{no \to bo}$ for $n=8$ can be seen in Figure (c).</p> <p><img src="/june.github.io/assets/img/post/ntt/image_2.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Adjust the input to bit-reversed order, then the Cooley-Tukey butterflies in the signal flow are changed elsewhere, as in Figure (a). The output will be under natural order. This type of NTT is denoted by $\text{NTT}^{CT}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_3.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Figure 2 shows the detailed process of using FFT trick to map $\mathbb{Z}_q[x] / (x^n - 1)$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_4.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>The mapping process takes on the shape of a binary tree, with the root node being the $0$-th level and the leaf nodes being the $(\log n)$-th level. <code class="language-plaintext highlighter-rouge">(x^n-1) â†’ (x-1) * (x+1) *â€¦* (x-w^{(n/2)-1} * (x+w^{(n/2)-1})</code></p> <p>After the $k$-th level, $0 \le k &lt; \log n$, there are $2^{k+1}$ nodes.</p> <p>The fast algorithm to compute INTT can be obtained by iteratively inverting the CRT mappings.</p> <p>In this case, the coefficients of the input polynomials are indexed under bit-reversed order, i.e., $\hat{a}_{\text{brv}_n(i)}\ (i = 0, 1, \dots, n-1)$.</p> <p>Apply the inverse FFT trick to the computation from the $(k+1)$-th level to the $k$-th level, where $1 \le k &lt; \log n$. <code class="language-plaintext highlighter-rouge">(x-1) * (x+1) *â€¦* (x-w^{(n/2)-1} * (x+w^{(n/2)-1}) -&gt; (x^n-1)</code></p> <p><img src="/june.github.io/assets/img/post/ntt/image_5.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p><img src="/june.github.io/assets/img/post/ntt/image_6.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Note that the scale factor 2 in each level of the Gentleman-Sande butterfly can be omitted,</p> <p>with multiplying the final result by $n^{-1}$ in the end.</p> <p>The coefficients of the output polynomials are indexed under natural order.</p> <p>This type of Gentleman-Sande INTT algorithm is denoted by $\text{INTT}^{GS}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_7.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Adjust its input/output order and we can obtain $\text{INTT}^{GS}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_8.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <ul> <li> <p>$\text{NTT}^{GS}$</p> <p><img src="/june.github.io/assets/img/post/ntt/image_9.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p><img src="/june.github.io/assets/img/post/ntt/image_10.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> </li> </ul> <h4 id="fft-trick-for-nwc-based-ntt-over-mathbbz_qx--xn--1">FFT Trick for NWC-based NTT over $\mathbb{Z}_q[x] / (x^n + 1)$</h4> <p>The FFT trick to compute $\text{NTT}^\psi$ and $\text{INTT}^{\psi^{-1}}$ over $\mathbb{Z}_q[x] / (x^n + 1)$,</p> <p>where $n$ is a power of two and $q$ is a prime number satisfying $q \equiv 1 \pmod{2n}$.</p> <p>Since $\psi_{2n}^{n/2} \equiv -1 \pmod q$, it holds that</p> \[x^n + 1 = x^n - \psi_{2n}^{n/2} = (x^{n/2} - \psi_{2n}^{n/2})(x^{n/2} + \psi_{2n}^{n/2}) \pmod q.\] <p>As for $\text{NTT}^\psi$, the forward FFT trick implies that we have the following isomorphism</p> \[\mathbb{Z}_q[x] / (x^n + 1) \;\cong\; \mathbb{Z}_q[x] / (x^{\frac{n}{2} } - \psi_{2n}^{\frac{n}{2} }) \times \mathbb{Z}_q[x] / (x^{\frac{n}{2} } + \psi_{2n}^{\frac{n}{2} })\] <p>FFT trick can be applied repeatedly.</p> <p>Notice that $x^n + 1$ has $n$ distinct roots in $\mathbb{Z}<em>q$, i.e., $\psi</em>{2n}^{2i+1}, i = 0, 1, \dots, n-1$.</p> <p>Therefore, there is a CRT isomorphism similarly.</p> \[\mathbb{Z}_q[x] / (x^n + 1) \;\cong\; \prod_{i=0}^{n-1} \mathbb{Z}_q[x] / (x - \psi_{2n}^{2\text{brv}_n(i)+1}).\] <p>Figure 3 shows the detailed process of using FFT trick to map $\mathbb{Z}_q[x] / (x^n + 1)$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_11.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>After the $k$-th level, where $0 \le k &lt; \log n$, it produces</p> \[\qquad\mathbb{Z}_q[x] / (x^{n/2^{k+1}} \pm \psi_{2n}^{\text{brv}_n(2^k+i)})\qquad (i = 0, 1, \dots, 2^k - 1 )\] <p>with pairs of rings.</p> <p>Such fast algorithm of $\text{NTT}^\psi$ is denoted by $\text{NTT}^{CT, \psi}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_12.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Similarly, by adjusting its input/output order, we can get $\text{NTT}^{CT, \psi}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_13.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Similarly, the fast algorithm to compute $\text{INTT}^{\psi^{-1}}$ can be obtained by iteratively inverting the CRT mapping process.</p> <p>This type of fast algorithm for $\text{INTT}^{\psi^{-1}}$ is denoted by $\text{INTT}^{GS, \psi^{-1}}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_14.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Adjust the input/output order and get $\text{INTT}^{GS, \psi^{-1}}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_15.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Omitting the scale factor 2 in each level can multiply the final result by $n^{-1}$ in the end.</p> <p>There is an alternative way to deal with the total factor $n^{-1}$.</p> <p>Zhang et al. noticed that $n^{-1}$ can both be integrated into the computing process of each level, based on the fact that the scale factor 2 will be dealt with directly, by using addition and displacement<code class="language-plaintext highlighter-rouge">shifting</code> to compute $x/2 \bmod q$.</p> \[x/2 \equiv \begin{cases} (x \gg 1) \mod q,&amp; x\text{ is even}\\ (x \gg 1) + (q+1)/2 \mod q, &amp; x\text{ is odd} \end{cases}\] <h4 id="twisted-fft-trick">Twisted FFT Trick</h4> <p>The Gentleman-Sande algorithm can be applied to compute NTT,</p> <p>and the Cooley-Tukey algorithm can be applied to compute INTT.</p> <p>It means, mapping</p> \[\mathbb{Z}_q[x] / (x^n - 1) \;\cong\; \mathbb{Z}_q[x] / (x^{\frac{n}{2} } - 1) \times \mathbb{Z}_q[x] / (x^{\frac{n}{2} } + 1)\] <p>by CRT, followed by mapping $\mathbb{Z}_q[x] / (x^{ n/2 } + 1)$ via following isomorphism</p> \[\Psi: \mathbb{Z}_q[x] / (x^{ n/2 } + 1) \;\cong\; \mathbb{Z}_q[x] / (x^{ n/2 } - 1)\] \[x \mapsto \omega_n x\] <p>Thus, as for $\mathbb{Z}_q[x] / (x^n - 1)$, there is</p> \[\Psi\Phi: \mathbb{Z}_q[x] / (x^n - 1) \;\cong\; \mathbb{Z}_q[x] / (x^{ n/2 } - 1) \times \mathbb{Z}_q[x] / (x^{ n/2 } - 1)\] \[\boldsymbol{a} \mapsto (\boldsymbol{a}', \boldsymbol{a}'')\] <p>and the detailed functioning process</p> \[\begin{aligned} (\Psi\Phi)\left(\sum_{i=0}^{n-1} a_i x^i\right) \ &amp; = \ \left(\sum_{i=0}^{ n/2\,-1\!} (a_i + a_{i+{n}/{2} }) x^i, \sum_{i=0}^{ n/2\,-1\!\!} \omega_n^i \!\cdot\! (a_i - a_{i+{n}/{2} }) x^i\right) \\[2.5em] (\Psi\Phi)^{-1}\!\!\left(\sum_{i=0}^{ n/2\,-1\!\!} a'_i x^i, \sum_{i=0}^{ n/2\,-1\!\!} a''_i x^i\!\right)\ &amp; = \ \sum_{i=0}^{ n/2\,-1\!} \frac{a'_i + \omega_n^{-i} \cdot a''_i}{2} x^i + \sum_{i=0}^{ n/2\,-1\!} \frac{a'_i - \omega_n^{-i} \cdot a''_i}{2} x^{i+{n}/{2} }. \end{aligned}\] <p>As for the forward twisted FFT trick, for example, $\boldsymbol{a} \in \mathbb{Z}_q[x] / (x^n - 1)$ in the $0$-th level generates $\boldsymbol{a}â€™$ and $\boldsymbol{a}â€™â€™$, where</p> \[\qquad a'_i = a_i + a_{i+\frac{n}{2} },\;\, a''_i = \omega_n^i \cdot (a_i - a_{i+\frac{n}{2} })\qquad (i = 0, 1, \dots, n/2 - 1),\] <p>where Gentleman-Sande algorithm are used.</p> <p>It can be applied repeatedly to map $\mathbb{Z}_q[x] / (x^{ n/2 } - 1)$, and down to linear terms such as $\mathbb{Z}_q[x] / (x \mp 1)$.</p> <p>Specifically, in the $k$-th level, the similar isomorphism $\Psi: x \mapsto \omega_n^{2^{k-1}} x$ is applied from $\mathbb{Z}_q[x] / (x^{n/2^k} + 1)$ to $\mathbb{Z}_q[x] / (x^{n/2^k} - 1)$, $1 \le k &lt; \log n$.</p> <p>The complete process of twisted FFT trick on mapping $\mathbb{Z}_q[x] / (x^n - 1)$ is shown in Figure 4.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_16.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Such GS NTT algorithm is denoted by $\text{NTT}^{GS}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_17.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Adjust the input/output order, and we obtain $\text{NTT}^{GS}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_18.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>The inverse twisted FFT trick is computed in much the same way by iteratively inverting the above process. For example, the process of computing $\boldsymbol{a}$ in the $0$-th level from $\boldsymbol{a}â€™$ and $\boldsymbol{a}â€™â€™$ in the first level with Cooley-Tukey butterflies is as follows</p> \[a_i = (a'_i + \omega_n^{-i} \cdot a''_i)/2,\;\, a_{i+{n}/{2} } = (a'_i - \omega_n^{-i} \cdot a''_i)/2\qquad (i = 0, 1, \dots, n/2 - 1).\] <p>Such computing from the $(k+1)$-th level to the $k$-th level can be achieved in the same way, where $1 \le k &lt; \log n$. The scale factor 2 in each level can be omitted, with multiplying the final result by $n^{-1}$ in the end. We denote this type of CT INTT by $\text{INTT}^{CT}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_6.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Adjust its input/output order and the new transform is denoted by $\text{INTT}^{CT}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_5.png" style="max-width: 50%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Notice that there only exists fast algorithm based on Cooley-Tukey butterfly for $\text{NTT}^\psi$, and that based on Gentleman-Sande butterfly for $\text{INTT}^{\psi^{-1}}$. This is because, once we use Gentleman-Sande butterfly to compute $\text{NTT}^\psi$ or use Cooley-Tukey butterfly to compute $\text{INTT}^{\psi^{-1}}$, the $\psi_{2n}$ term can not be further processed.</p> <h4 id="radix-2-fast-number-theoretic-transform-from-fft-perspectives">RADIX-2 FAST NUMBER THEORETIC TRANSFORM FROM FFT PERSPECTIVES</h4> <p>This section describes NTT algorithms from FFT perspectives.</p> <p>The basic principle of fast NTT algorithms is using â€œdivide and conquerâ€ skill to divide the $n$-point NTT into two $n/2$-point NTTs, based on the periodicity and symmetry of the primitive root of unity.</p> <p>The properties of primitive roots of unity in NTT are similar to those of twiddle factors in FFT.</p> <p>The primitive $n$-th root of unity $\omega_n$ in $\mathbb{Z}_q$ has the following properties</p> \[\text{periodicity: } \omega_n^{k+n} = \omega_n^k\] \[\text{symmetry: } \omega_n^{k+n/2} = -\omega_n^k\] <p>where $k$ is a non-negative integer.</p> <p>It is trivial that the primitive $2n$-th root of unity $\psi_{2n}$ shares similar properties if $\psi_{2n}$ exists.</p> <h5 id="cooley-tukey-algorithm-for-cc-based-ntt">Cooley-Tukey Algorithm for CC-based NTT</h5> <ol> <li> <p><strong>NTT</strong></p> <p>Based on the parity of the indexes of the coefficients $a_i$ in $\boldsymbol{a}$, the terms can be separated into two parts, for $j = 0, 1, \dots, n-1$,</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} \omega_n^{2ij} + \sum_{i=0}^{n/2-1} a_{2i+1} \omega_n^{(2i+1)j} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} + \omega_n^j \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, for $j = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} + \omega_n^j \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} \bmod q \\[1.5em] \hat{a}_{j+n/2} &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} - \omega_n^j \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} \hat{a}'_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} \bmod q,\\[1.5em] \hat{a}''_j &amp;= \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} \bmod q,\quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>Formula can be rewritten as</p> \[\begin{aligned} \hat{a}_j &amp;= \hat{a}'_j + \omega_n^j \hat{a}''_j \bmod q, \\[.7em] \hat{a}_{j+n/2} &amp;= \hat{a}'_j - \omega_n^j \hat{a}''_j \bmod q, \quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>One can learn from the definition of NTT that, $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$ can be computed by $n/2$-point NTT, from the even-indexed and the odd-indexed coefficients of $\boldsymbol{a}$, respectively.</p> <p>Formula shows that, the original $n$-point NTT can be divided into two $n/2$-point NTTs by â€œdivide-and-conquerâ€ method.</p> <p>After getting the $n/2$-point NTT results $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$, the original $n$-point $<br/> \hat{\boldsymbol{a}}$ can be easily achieved by multiplying $\omega_n^j$ and simple additions/subtractions.</p> <p>This kind of â€œdivide and conquerâ€ skill can also be applied to compute $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$.</p> <p>Since $n$ is a power of two, it can be separated down to 2-point NTTs.</p> <p>Note that, the coefficients of the input polynomials are indexed under bit-reversed order, while the coefficients of the output polynomials are indexed under natural order.</p> </li> <li> <p><strong>INTT</strong></p> <p>Cooley-Tukey butterfly can also be applied to compute INTT. In contrast to NTT, there is extra multiplications by a scale factor $n^{-1}$ in INTT.</p> <p>With neglecting $n^{-1}$, the terms in the summation are the same as those in NTT formula, except replacing $\omega_n$ with $\omega_n^{-1}$.</p> <p>For the convenience of understanding, its brief computing process is given here.</p> \[a_i = \sum_{j=0}^{n/2-1} \hat{a}_{2j} (\omega_n^2)^{-ij} + \omega_n^{-i} \sum_{j=0}^{n/2-1} \hat{a}_{2j+1} (\omega_n^2)^{-ij} \bmod q. \quad i = 0, 1, \dots, n-1\] <p>Let</p> \[\begin{aligned} a'_i &amp;= \sum_{j=0}^{n/2-1} \hat{a}_{2j} (\omega_n^2)^{-ij} \bmod q,\\[1.5em] a''_i &amp;= \sum_{j=0}^{n/2-1} \hat{a}_{2j+1} (\omega_n^2)^{-ij} \bmod q,\quad i = 0, 1, \dots, n/2 - 1. \end{aligned}\] \[\begin{aligned} a_i &amp;= a'_i + \omega_n^{-i} a''_i \bmod q \\[1em] a_{i+n/2} &amp;= a'_i - \omega_n^{-i} a''_i \bmod q, \quad i = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>Therefore, the computing of $n$-point INTT can be divided into two $n/2$-point INTTs, which can be done down to 2-point INTTs finally.</p> </li> </ol> <h5 id="gentlemen-sande-algorithm-for-cc-based-ntt">Gentlemen-Sande Algorithm for CC-based NTT</h5> <ol> <li> <p><strong>NTT</strong></p> <p>Gentlemen-Sande algorithm separates the coefficients of $\boldsymbol{a}$ into the upper half and the lower half. Specifically, for $j = 0, 1, \dots, n-1$,</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_i \omega_n^{ij} + \sum_{i=n/2}^{n-1} a_i \omega_n^{ij} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} a_i \omega_n^{ij} + \sum_{i=0}^{n/2-1} a_{i+n/2} \omega_n^{(i+n/2)j} \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, the terms $\hat{a}_j$ continue to be dealt with according to the parity of index $j$. For $j = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} \hat{a}_{2j} &amp;= \sum_{i=0}^{n/2-1} a_i \omega_n^{2ij} + (-1)^{2j} \cdot \sum_{i=0}^{n/2-1} a_{i+n/2} \omega_n^{2ij} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} (a_i + a_{i+n/2}) (\omega_n^2)^{ij} \bmod q, \\[1.5em] \hat{a}_{2j+1} &amp;= \sum_{i=0}^{n/2-1} a_i \omega_n^{(2j+1)i} + (-1)^{2j+1} \cdot \sum_{i=0}^{n/2-1} a_{i+n/2} \omega_n^{(2j+1)i} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} \left[ (a_i - a_{i+n/2}) \cdot \omega_n^i \right] (\omega_n^2)^{ij} \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} b'_i &amp;= a_i + a_{i+n/2} \bmod q,\\[1em] b''_i &amp;= (a_i - a_{i+n/2}) \cdot \omega_n^i \bmod q, i = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>The above formula can be rewritten as</p> \[\begin{aligned} \hat{a}_{2j} &amp;= \sum_{i=0}^{n/2-1} b'_i (\omega_n^2)^{ij} \bmod q, \\[1.5em] \hat{a}_{2j+1} &amp;= \sum_{i=0}^{n/2-1} b''_i (\omega_n^2)^{ij} \bmod q, \quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>One can learn from the definition of NTT that, formula is exact the $n/2$-point NTTs with respect to $bâ€™_i, bâ€™â€˜_i\, (i = 0, 1, \dots, n/2 - 1)$.</p> <p>Thus, after deriving $bâ€™_i, bâ€™â€˜_i$ from $a_i$, the original $n$-point NTT is transformed into $n/2$-point NTTs with respect to $bâ€™_i, bâ€™â€˜_i$.</p> <p>Similarly, the $n/2$-point NTT can be transformed into $n/4$-point NTTs, and down to 2-point NTTs.</p> </li> <li> <p><strong>INTT</strong></p> <p>Gentleman-Sande butterfly can be similarly applied to compute INTT, by neglecting $n^{-1}$ and replacing $\omega_n$ with $\omega_n^{-1}$ in NTT. That is, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= \sum_{j=0}^{n/2-1} (\hat{a}_j + \hat{a}_{j+n/2}) (\omega_n^2)^{-ij} \bmod q \\[1.5em] a_{2i+1} &amp;= \sum_{i=0}^{n/2-1} \left[ (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \omega_n^{-j} \right] (\omega_n^2)^{-ij} \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} \hat{b}'_j &amp;= \hat{a}_j + \hat{a}_{j+n/2} \bmod q,\\[1em] \hat{b}''_j &amp;= (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \omega_n^{-j} \bmod q,\quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>Formula can be rewritten as:</p> \[\begin{aligned} a_{2i} &amp;= \sum_{j=0}^{n/2-1} \hat{b}'_j (\omega_n^2)^{-ij} \bmod q \\ a_{2i+1} &amp;= \sum_{j=0}^{n/2-1} \hat{b}''_j (\omega_n^2)^{-ij} \bmod q, \quad i = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>Similarly, $n$-point INTT can be divided into two $n/2$-point INTTs, and down to 2-point INTTs.</p> </li> </ol> <h5 id="radix-2-fast-nwc-based-ntt">Radix-2 Fast NWC-based NTT</h5> <p>The process of multiplying the coefficients by $\psi_{2n}^i$ before forward transform is referred to as pre-processing,</p> <p>while the process of multiplying the coefficients by $\psi_{2n}^{-i}$ after inverse transform is referred to as post-processing.</p> <p>Fast algorithms for NWC-based NTT, such as $\text{NTT}^\psi$ and $\text{INTT}^{\psi^{-1}}$, can be constructed by using radix-2 CT/GS NTT/INTT algorithm with pre-processing and post-processing.</p> <p>However, such construction requires extra point-wise multiplication with $\boldsymbol{\psi}/\boldsymbol{\psi}^{-1}$ besides radix-2 algorithms, resulting with $n$ extra multiplications. In fact, these additional multiplications are not necessary.</p> <ul> <li>Roy et al. integrate the pre-processing about $\boldsymbol{\psi}$ into $\text{NTT}^{CT}_{bo \to no}$.</li> <li>PÃ¶ppelmann et al. integrate the post-processing about $\boldsymbol{\psi}^{-1}$ into $\text{INTT}^{GS}_{bo \to no}$.</li> <li>Furthermore, Zhang et al. integrate $\boldsymbol{\psi}^{-1}$ and $n^{-1}$ into $\text{INTT}^{GS}_{bo \to no}$. <ol> <li><strong>Cooley-Tukey algorithm for $\text{NTT}^\psi$</strong></li> </ol> <p>According to the definition of $\text{NTT}^\psi$, the coefficients of $\hat{\boldsymbol{a}}$ can be written as</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \psi_{2n}^i \omega_n^{ij} \bmod q, \quad j = 0, 1, \dots, n - 1.\] <p>Divide the summation into two parts based on the parity of the index of $a_i$, and for $j = 0, 1, \dots, n - 1$, we get</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} \omega_n^{2ij} \psi_{2n}^{2i} + \sum_{i=0}^{n/2-1} a_{2i+1} \omega_n^{(2i+1)j} \psi_{2n}^{2i+1} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i + \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, for $j = 0, 1, \dots, n/2 - 1$, we get</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i + \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q \\[1.5em] \hat{a}_{j+n/2} &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i - \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} \hat{a}'_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q,\\[1.5em] \hat{a}''_j &amp;= \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q,\quad j = 0, 1, \dots, n/2 - 1 . \end{aligned}\] <p>With $\omega_n^j \psi_{2n} = \psi_{2n}^{2j+1}$, the above formula can be rewritten as, for $j = 0, 1, \dots, n/2 - 1$:</p> \[\hat{a}_j = \hat{a}'_j + \psi_{2n}^{2j+1} \hat{a}''_j \bmod q, \quad \hat{a}_{j+n/2} = \hat{a}'_j - \psi_{2n}^{2j+1} \hat{a}''_j \bmod q.\] <p>One can see that, $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$ can be obtained via exact $n/2$-point $\text{NTT}^\psi$s.</p> </li> </ul> <ol> <li> <p><strong>Gentleman-Sande algorithm for $\text{INTT}^{\psi^{-1}}$</strong></p> <p>According to the definition of $\text{INTT}^{\psi^{-1}}$, the coefficients of $\boldsymbol{a}$ can be written as</p> \[a_i = n^{-1} \psi_{2n}^{-i} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q, \quad i = 0, 1, \dots, n - 1.\] <p>With neglecting $n^{-1}$, the summation can be divided into the upper half and the lower half with respect to the index of $\hat{a}_j$.</p> <p>For $i = 0, 1, \dots, n - 1$,</p> \[\begin{aligned} a_i &amp;= \psi_{2n}^{-i} \left( \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-ij} + \sum_{j=n/2}^{n-1} \hat{a}_j \omega_n^{-ij} \right) \\[1.5em] &amp;= \psi_{2n}^{-i} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-ij} + \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-i(j+n/2)} \right] \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= \psi_{2n}^{-2i} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-2ij} + (-1)^{2i} \cdot \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-2ij} \right] \bmod q \\[1.5em] &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} (\hat{a}_j + \hat{a}_{j+n/2}) (\omega_n^2)^{-ij} \bmod q, \\[2em] a_{2i+1} &amp;= \psi_{2n}^{-(2i+1)} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-(2i+1)j} + (-1)^{2i+1} \cdot \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-(2i+1)j} \right] \bmod q \\[1.5em] &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \left[ (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \omega_n^{-j} \psi_{2n}^{-1} \right] (\omega_n^2)^{-ij} \bmod q. \end{aligned}\] <p>Since $\omega_n^{-j} \psi_{2n}^{-1} = \psi_{2n}^{-(2j+1)}$, letting</p> \[\begin{aligned} \hat{b}'_j &amp;= \hat{a}_j + \hat{a}_{j+n/2} \bmod q,\\[1em] \hat{b}''_j &amp;= (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \psi_{2n}^{-(2j+1)} \bmod q,\quad j = 0, 1, \dots, n/2 - 1, \end{aligned}\] <p>the above formula can be rewritten as, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}'_j (\omega_n^2)^{-ij} \bmod q, \\[1.5em] a_{2i+1} &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}''_j (\omega_n^2)^{-ij} \bmod q. \end{aligned}\] <p>Computing $n$-point $\text{INTT}^{\psi^{-1}}$ can be transformed into two $n/2$-point $\text{INTT}^{\psi^{-1}}$s with respect to $\hat{b}â€™_j, \hat{b}â€™â€˜_j$.</p> <p>Forthermore, $\boldsymbol{\psi}^{-1}$ and $n^{-1}$ can both be integrated into $\text{INTT}^{GS}_{bo \to no}$.</p> <p>Thus, $n^{-1}$ is no longer neglected, and for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= \left(\frac{n}{2}\right)^{-1} (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}'_j (\omega_n^2)^{-ij} \bmod q, \\[1.5em] a_{2i+1} &amp;= \left(\frac{n}{2}\right)^{-1} (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}''_j (\omega_n^2)^{-ij} \bmod q, \end{aligned}\\[.7em]\] \[\begin{aligned} \text{where }\; &amp; \hat{b}'_j = (\hat{a}_j + \hat{a}_{j+n/2})/2 \mod q,\\[.5em]&amp; \hat{b}''_j = (\hat{a}_j - \hat{a}_{j+n/2})/2 \cdot \psi_{2n}^{-(2j+1)} \bmod q, \quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>When computing $\hat{b}â€™_j$ and $\hat{b}â€™â€˜_j$, the scale factor 2 will be dealt with directly, by using addition and displacement (i.e., â€œ$\gg$â€) to compute $x/2 \bmod q$.</p> \[x/2 \equiv \begin{cases} (x \gg 1) \bmod q, &amp; x\text{ is even},\\ (x \gg 1) + (q+1)/2 \bmod q, &amp; x\text{ is odd}. \end{cases}\] </li> </ol> <h4 id="in-place-operation-reordering-and-complexity">In-place Operation, Reordering and Complexity</h4> <h5 id="in-place-operation">In-place operation</h5> <p>The Cooley-Tukey butterfly and Gentleman-Sande butterfly store the input and output data in the same address before and after the computing process, i.e., read data from some storage address for the computation, where the computing results are stored. This kind of operation is referred to as in-place operation. Obviously, there is no need of extra storage for in-place operation.</p> <h5 id="reordering">Reordering</h5> <p>The input and output order of the polynomial coefficients have to be taken into consideration.</p> <p>Although the coefficients of the practical input polynomial are under natural order,</p> <p>the output after $\text{NTT}^{CT}<em>{no \to bo}/\text{NTT}^{GS}</em>{no \to bo}$ will end under bit-reversed order,</p> <p>which is the required order for input of $\text{INTT}^{CT}<em>{bo \to no}/\text{INTT}^{GS}</em>{bo \to no}$,</p> <p>but not the required one for input of $\text{INTT}^{CT}<em>{no \to bo}/\text{INTT}^{GS}</em>{no \to bo}$.</p> <p>In this case, extra reordering is needed from bit-reversed order to natural order.</p> <p>Besides, if NTT is conducted via $\text{NTT}^{CT}<em>{bo \to no}$ and $\text{NTT}^{GS}</em>{bo \to no}$, the input polynomial is supposed to be reordered from natural order to bit-reversed order.</p> <p>Similarly, there is a requirement on reordering the output polynomial of $\text{INTT}^{CT}<em>{no \to bo}$ and $\text{INTT}^{GS}</em>{no \to no}$.</p> <p>In a word, there is a way for cyclic convolution-based polynomial multiplication without reordering, i.e., for $\ddagger, \natural \in {CT, GS}$</p> \[\boldsymbol{c} = \text{INTT}^{\ddagger}_{bo \to no} \left( \text{NTT}^{\natural}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{\natural}_{no \to bo}(\boldsymbol{b}) \right).\] <p>Similarly, there is a way for NWC-based polynomial multiplication without extra reordering:</p> \[\boldsymbol{c} = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right).\] <h5 id="complexity-1">Complexity</h5> <p>The complexities of NTT/INTT are given in Table.</p> <p>Each Cooley-Tukey butterfly consumes one multiplication and two additions (subtractions), where $\omega b$ is computed once and can be used twice.</p> <p>Similar analysis can also be applied to Gentleman-Sande butterfly.</p> <p>All the fast algorithms consist of $\log n$ levels, where there are ${n}/{2}$ butterfly operations on each level. As for the inverse transforms, their complexities require extra $n$ multiplications because of dealing with the scale factor $n^{-1}$.</p> <p>All the complexity of the polynomial multiplication based on these NTT fast algorithms is $O(n \log n)$, which has a significant advantage over that of polynomial multiplication based on directly-computing NTT/INTT, or any other polynomial multiplication algorithms such as the schoolbook algorithm and Karatsuba/Toom-Cook algorithm.</p> <table> <thead> <tr> <th><strong>NTT algorithms</strong></th> <th><strong>Multiplication complexities</strong></th> </tr> </thead> <tbody> <tr> <td>$\text{NTT}, \text{INTT}, \text{NTT}^\psi, \text{INTT}^{\psi^{-1}}$</td> <td>$O(n^2)$</td> </tr> <tr> <td>$\text{NTT}^{\natural}_{no \to bo}, \text{NTT}^{\natural}_{bo \to no}, \text{NTT}^{CT, \psi}_{no \to bo}, \text{NTT}^{CT, \psi}_{bo \to no}$</td> <td>$\frac{1}{2} n \log n$</td> </tr> <tr> <td>$\text{INTT}^{\ddagger}_{no \to bo}, \text{INTT}^{\ddagger}_{bo \to no}, \text{INTT}^{GS, \psi^{-1}}_{no \to bo}, \text{INTT}^{GS, \psi^{-1}}_{bo \to no}$</td> <td>$\frac{1}{2} n \log n + n$</td> </tr> <tr> <td>$\text{NTT}^{\natural}_{no \to bo} \circ \psi, \text{NTT}^{\natural}_{bo \to no} \circ \psi_{bo}$</td> <td>$\frac{1}{2} n \log n + n$</td> </tr> <tr> <td>$\psi^{-1}_{bo} \circ \text{INTT}^{\ddagger}_{no \to bo}, \psi^{-1} \circ \text{INTT}^{\ddagger}_{bo \to no}$</td> <td>$\frac{1}{2} n \log n + 2n$</td> </tr> </tbody> </table> <p>$\ddagger, \natural \in {CT, GS}$. $\psi_{bo}$ and $\psi^{-1}_{bo}$ mean that the coefficients are under bit-reversed order. $n$ is the length of NTT.</p> <h3 id="methods-to-weaken-restrictions-on-parameter-conditions-of-ntt">METHODS TO WEAKEN RESTRICTIONS ON PARAMETER CONDITIONS OF NTT</h3> <p>The full CC-based NTT requires that the parameter $n$ is a power of two and $q$ is prime satisfying $q\equiv 1\pmod n$, while the full NWC-based NTT requires that the parameter $n$ is a power of two and $q$ is prime satisfying $q\equiv 1\pmod {2n}$</p> <p>Traditionally, NTT puts some restrictions on its parameters. In recent years, many research efforts are made for NTTâ€™s restrictions on parameters and a series of methods have been proposed to weaken them.</p> <p>This section introduces the recent advances of weakening parameter restrictions with respect to $\mathbb{Z}_q[x] / (x^n\pm 1)$ where $n$ is a power of two. Those methods can be mainly classified into the following three categories.</p> <ul> <li>Method based on incomplete FFT trick</li> <li>Method based on splitting polynomial ring</li> <li>Method based on large modulus</li> </ul> <p>The first two methods are applied for the case that the modulus $q$ is an NTT-friendly prime of the form $q=qâ€™\cdot 2^e +1$ but $q$ can not lead to a full NTT.</p> <p>The last method is applied for the case that the modulus $q$ is an NTT-unfriendly prime.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_19.png" style="max-width: 90%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <h4 id="method-based-on-incomplete-fft-trick">Method Based on Incomplete FFT trick</h4> <p>Introduce the method based on the incomplete FFT trick over $\mathbb{Z}_q[x] / (x^n + 1)$ where $n$ is a power of two and $q$ is NTT-friendly prime but does not satisfy $q \equiv 1 \pmod{2n}$.</p> <p>Then extend the ring to $\mathbb{Z}_q[x] / (x^n - 1)$ where $n$ is a power of two and $q$ is NTT-friendly prime but does not satisfy $q \equiv 1 \pmod n$.</p> <h5 id="method-based-on-incomplete-fft-trick-over-mathbbz_qx--xn--1">Method based on incomplete FFT trick over $\mathbb{Z}_q[x] / (x^n + 1)$</h5> <p>Fully-mapping FFT trick means to map $\mathbb{Z}_q[x] / (x^n + 1)$ down to linear terms, e.g., $\mathbb{Z}_q[x] / (x - \psi_{2n}^{2i+1})$. The condition $q \equiv 1 \pmod{2n}$ is required such that the primitive $2n$-th root of unity $\psi_{2n}$ exits.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_11.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Moenck noticed that FFT trick does not have to map down to linear terms, and one can stop its mapping before the last $\beta$ level, $\beta = 0, 1, \dots, \log n - 1$.</p> <p>In detail, its CRT map of $\mathbb{Z}_q[x] / (x^n + 1)$ is as follows.</p> \[\mathbb{Z}_q[x] / (x^n + 1) \cong \prod_{i=0}^{n/2^\beta - 1} \mathbb{Z}_q[x] / (x^{2^\beta} - \psi_{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1}).\] <p>It is referred to as â€œIncomplete NTTâ€ or â€œTruncated-NTTâ€.</p> <p>The reason is that its CRT tree map is obtained by cropping the last $\beta$ levels from fully-mapping $(\log n)$-level FFT trick tree map.</p> <p>Note that after forward transforms, $\boldsymbol{a}$â€™s images in $\mathbb{Z}_q[x] / (x^{2^\beta} - \psi_{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1})$ are degree-$(2^\beta - 1)$ polynomials.</p> <p>The point-wise multiplication is performed about the corresponding degree-$(2^\beta - 1)$ polynomials in $\mathbb{Z}_q[x] / (x^{2^\beta} - \psi_{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1})$.</p> <p>As for the inverse transforms, the scale factor 2 is omitted in every level, followed by multiplying by a total scalar $(n/2^\beta)^{-1}$ in the end. The forward/inverse transforms with $\beta$ levels cropped are denoted by $\text{NTT}^{CT, \psi}_{no \to bo, \beta} / \text{INTT}^{GS, \psi^{-1}}_{bo \to no, \beta}$ respectively, where $\beta = 0, 1, \dots, \log n - 1$.</p> <p>Obviously, they are exactly $\text{NTT}^{CT, \psi}_{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}_{bo \to no}$ if $\beta = 0$.</p> <p>The restriction on $n$ and $q$ can be weakened to $q \equiv 1 \pmod{2n/{2^\beta}}$.</p> <p>The way to compute polynomial multiplication is the general form of formula</p> \[\boldsymbol{c} = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right),\] <p>that is</p> \[\boldsymbol{c} = \text{INTT}^{GS, \psi^{-1}}_{bo \to no, \beta} \left( \text{NTT}^{CT, \psi}_{no \to bo, \beta}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo, \beta}(\boldsymbol{b}) \right).\] <p><strong>A high-level description of incomplete FFT trick over $\mathbb{Z}_q[x] / (x^n + 1)$</strong></p> \[\mathbb{Z}_q[x] / (x^n + 1) \to (\mathbb{Z}_q[x] / (x^{2^\beta} - y))[y] / (y^{\frac{n}{2^\beta}} + 1),\] <p>along with rewriting $\boldsymbol{a} \in \mathbb{Z}<em>q[x] / (x^n + 1)$ as $\boldsymbol{a} = \sum</em>{i=0}^{ n/2\beta -1} \tilde{a}_i y^i$,</p> <p>where $y = x^{2^\beta}$ and $\tilde{a}<em>i = \sum</em>{j=0}^{2^\beta-1} a_{2^\beta \cdot i + j} x^j \in \mathbb{Z}_q[x] / (x^{2^\beta} - y)$.</p> <p>Thus, $\boldsymbol{a}$ can be seen as a polynomial of degree $({n}/{2^\beta} - 1)$ with respect to $y$.</p> <p>FFT trick will map</p> \[(\mathbb{Z}_q[x] / (x^{2^\beta} - y))[y] / (y^{\frac{n}{2^\beta}} + 1) \cong \prod_{i=0}^{n/2^\beta - 1} (\mathbb{Z}_q[x] / (x^{2^\beta} - y))[y] / (y - \psi_{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1}).\] <p>Its forward transform (resp., inverse transform) is treated as radix-2 ${n}/{2^\beta}$-point full NWC-based $\text{NTT}^{CT, \psi}_{no \to bo}$ (resp., $\text{INTT}^{GS, \psi^{-1}}_{bo \to no}$) with respect to $y$.</p> <p>And the point-wise multiplication is performed in $(\mathbb{Z}_q[x] / (x^{2^\beta} - y))[y] / (y - \psi_{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1})$.</p> <h5 id="method-based-on-incomplete-fft-trick-over-mathbbz_qx--xn---1">Method based on incomplete FFT trick over $\mathbb{Z}_q[x] / (x^n - 1)$</h5> <p>The method based on incomplete FFT trick over$\mathbb{Z}_q[x] / (x^n - 1)$ achieves its CRT map as follows.</p> \[\mathbb{Z}_q[x] / (x^n - 1) \cong \prod_{i=0}^{n/2^\beta - 1} \mathbb{Z}_q[x] / (x^{2^\beta} - \omega_{n/2^\beta}^{\text{brv}_{n/2^\beta}(i)}).\] <p>where $\beta = 0, 1, \dots, \log n - 1$.</p> <p>Similarly, denote by $\text{NTT}^{CT}_{no \to bo, \beta}$ and $\text{INTT}^{GS}_{bo \to no, \beta}$ the forward and the inverse transform.</p> <p>The restriction on $q$ can be weakened to $q \equiv 1 \pmod{\frac{n}{2^\beta}}$.</p> <p>Its way to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n - 1)$ is</p> \[\boldsymbol{c} = \text{INTT}^{GS}_{bo \to no, \beta} \left( \text{NTT}^{CT}_{no \to bo, \beta}(\boldsymbol{a}) \circ \text{NTT}^{CT}_{no \to bo, \beta}(\boldsymbol{b}) \right).\] <p>Its high-level description can be written as</p> \[\mathbb{Z}_q[x] / (x^n - 1) \to (\mathbb{Z}_q[x] / (x^{2^\beta} - y))[y] / (y^{\frac{n}{2^\beta}} - 1),\] <p>followed by CRT isomorphism.</p> \[(\mathbb{Z}_q[x] / (x^{2^\beta} - y))[y] / (y^{\frac{n}{2^\beta}} - 1) \cong \prod_{i=0}^{n/2^\beta - 1} (\mathbb{Z}_q[x] / (x^{2^\beta} - y))[y] / (y - \omega_{n/2^\beta}^{\text{brv}_{n/2^\beta}(i)}).\] <h4 id="method-based-on-splitting-polynomial-ring">Method Based on Splitting Polynomial Ring</h4> <p>The computing strategies of Pt-NTT, K-NTT, and H-NTT are similarly dependent on splitting the initial polynomial ring, based on which they are classified as the method based on splitting the polynomial ring. And their basic idea can be traced back to Nussbaumerâ€™s trick. Following the description of Nussbaumerâ€™s trick, they can essentially be described by the following isomorphism. Let $\alpha$ be a non-negative integer.</p> \[\Psi_\alpha : \mathbb{Z}_q[x] / (x^n \pm 1) \cong \left( \mathbb{Z}_q[y] / (y^{\frac{n}{2^\alpha}} \pm 1) \right)[x] / (x^{2^\alpha} - y)\] \[a = \sum_{i=0}^{n-1} a_i x^i \mapsto \Psi_\alpha(a) = \sum_{i=0}^{2^\alpha-1} \left( \sum_{j=0}^{\frac{n}{2^\alpha}-1} a_{2^\alpha \cdot j + i} y^j \right) x^i .\] <p>Obviously, the isomorphism $\Psi_\alpha$ and its inverse $\Psi_\alpha^{-1}$ only perform simple reordering of the polynomial coefficients. $\Psi_\alpha$ is the identity mapping if $\alpha = 0$.</p> <p>Briefly speaking, the general form of $\alpha$-round method based on splitting polynomial ring to compute $c = a \cdot b \in \mathbb{Z}_q[x] / (x^n \pm 1)$ mainly contains the following three steps, where $n$ is a power of two and $q$ is a prime number (more details about $q$ can be seen below).</p> <ul> <li> <p><strong>Step 1, Splitting.</strong></p> <p>The polynomials $a$ and $b$ are split by $\Psi_\alpha$ into</p> \[\Psi_\alpha(a) = \sum_{i=0}^{2^\alpha-1} \tilde{a}_i \cdot x^i, \quad \Psi_\alpha(b) = \sum_{i=0}^{2^\alpha-1} \tilde{b}_i \cdot x^i \in \left( \mathbb{Z}_q[y] / (y^{\frac{n}{2^\alpha}} \pm 1) \right)[x] / (x^{2^\alpha} - y),\] <p>where $y = x^{2^\alpha}$, and</p> \[\tilde{a}_i = \sum_{j=0}^{\frac{n}{2^\alpha}-1} a_{2^\alpha \cdot j + i} y^j, \quad \tilde{b}_i = \sum_{j=0}^{\frac{n}{2^\alpha}-1} b_{2^\alpha \cdot j + i} y^j \in \mathbb{Z}_q[y] / (y^{\frac{n}{2^\alpha}} \pm 1).\] </li> <li> <p><strong>Step 2, Multiplication.</strong></p> <p>The product of $\Psi_\alpha(a)$ and $\Psi_\alpha(b)$ is obtained by $(\sum_{i=0}^{2^\alpha-1} \tilde{a}<em>i \cdot x^i)(\sum</em>{i=0}^{2^\alpha-1} \tilde{b}_i \cdot x^i) \pmod{x^{2^\alpha} - y}$,</p> <p>which means that one need to compute $\tilde{c}_i \in \mathbb{Z}_q[y] / (y^{ n/2\alpha} \pm 1)$ for $i = 0, 1, \dots, 2^\alpha - 1$ as follows.</p> \[\tilde{c}_i = \sum_{l=0}^{i} \tilde{a}_l \cdot \tilde{b}_{i-l} + \sum_{l=i+1}^{2^\alpha-1} y \cdot \tilde{a}_l \cdot \tilde{b}_{2^\alpha+i-l} \in \mathbb{Z}_q[y] / (y^{ n/2\alpha} \pm 1).\] </li> <li> <p><strong>Step 3, Gatheration.</strong></p> <p>Gather all the $\tilde{c}_i$ by $\Psi_\alpha^{-1}$, and obtain $c = \Psi_\alpha^{-1} \left( \sum_{i=0}^{2^\alpha-1} \tilde{c}_i \cdot x^i \right)$.</p> </li> </ul> <p>Step 1 and Step 3 are simple and easy.</p> <p>Essentially, $\Psi_\alpha$ transforms NTT/INTT over $\mathbb{Z}_q[x] / (x^n \pm 1)$ into those over $\mathbb{Z}_q[y] / (y^{ n/2\alpha} \pm 1)$ which requires only ${n}/{2^\alpha}$-point NTT/INTT with arbitrary appropriate modulus $q$, but the point-wise multiplication needs to be adapted to NTT/INTT.</p> <p>There are three variants based on the method based on splitting polynomial ring, including Pt-NTT, K-NTT, H-NTT. The main difference between them is that they use different skills and NTTs to compute $\tilde{c}_i$ of Step 2.</p> <h5 id="621-pt-ntt">6.2.1 Pt-NTT</h5> <p>Preprocess-then-NTT (Pt-NTT) improves formula as follows.</p> \[\begin{aligned} \tilde{c}_i &amp;= \sum_{l=0}^{i} \tilde{a}_l \cdot \tilde{b}_{i-l} + \sum_{l=i+1}^{2^\alpha-1} \vec{a}_l \cdot \tilde{b}_{2^\alpha+i-l} \\ &amp;= \text{INTT} \left( \sum_{l=0}^{i} \text{NTT}(\tilde{a}_l) \circ \text{NTT}(\tilde{b}_{i-l}) + \sum_{l=i+1}^{2^\alpha-1} \text{NTT}(\vec{a}_l) \circ \text{NTT}(\tilde{b}_{2^\alpha+i-l}) \right), \end{aligned}\] <p>where â€œ$\circ$â€ is the corresponding point-wise multiplication, and for $\mathbb{Z}_q[y] / (y^{ n/2\alpha} + 1)$, there is</p> \[\tilde{\tilde{a}}_l = y \cdot \tilde{a}_l = -a_{n-2^\alpha+l} + \sum_{j=0}^{ n/2\alpha-2} a_{2^\alpha \cdot j + l} y^{j+1} \in \mathbb{Z}_q[y] / (y^{ n/2\alpha} + 1),\] <p>or, for $\mathbb{Z}_q[y] / (y^{ n/2\alpha} - 1)$, there is</p> \[\tilde{\tilde{a}}_l = y \cdot \tilde{a}_l = a_{n-2^\alpha+l} + \sum_{j=0}^{ n/2\alpha-2} a_{2^\alpha \cdot j + l} y^{j+1} \in \mathbb{Z}_q[y] / (y^{ n/2\alpha} - 1).\] <p>Here, Pt-NTT uses ${n}/{2^\alpha}$-point full NWC-based NTT/INTT over $\mathbb{Z}_q[y] / (y^{ n/2\alpha} + 1)$, or ${n}/{2^\alpha}$-point full CC-based NTT/INTT over $\mathbb{Z}_q[y] / (y^{ n/2\alpha} - 1)$.</p> <h5 id="622-k-ntt">6.2.2 K-NTT</h5> <p>Later, Karatsuba-NTT (K-NTT) is proposed based on Pt-NTT, equipping with one-iteration Karatsuba algorithm. Its Step 2 is given as</p> \[\begin{aligned} \tilde{c}_i &amp;= \sum_{l=0}^{i} \tilde{a}_l \cdot \tilde{b}_{i-l} + \sum_{l=i+1}^{2^\alpha-1} y \cdot \tilde{a}_l \cdot \tilde{b}_{2^\alpha+i-l} \\ &amp;= \text{INTT} \left( \sum_{l=0}^{i} \text{NTT}(\tilde{a}_l) \circ \text{NTT}(\tilde{b}_{i-l}) + \sum_{l=i+1}^{2^\alpha-1} \text{NTT}(y) \circ \text{NTT}(\tilde{a}_l) \circ \text{NTT}(\tilde{b}_{2^\alpha+i-l}) \right). \end{aligned}\] <p>Here, K-NTT uses ${n}/{2^\alpha}$-point full NWC-based NTT/INTT over $\mathbb{Z}_q[y] / (y^{ n/2\alpha} + 1)$, or ${n}/{2^\alpha}$-point full CC-based NTT/INTT over $\mathbb{Z}_q[y] / (y^{ n/2\alpha} - 1)$.</p> <p>Since $y$ has been known, $\text{NTT}(y)$ can be computed and stored offline in advance. In Step 2, one-iteration Karatsuba algorithm is used in such a manner.</p> <p>First compute and store $\text{NTT}(\tilde{a}_i) \circ \text{NTT}(\tilde{b}_i)$ for any $i = j$,</p> <p>and then</p> \[\begin{aligned} &amp;\text{NTT}(\tilde{a}_i) \circ \text{NTT}(\tilde{b}_j) + \text{NTT}(\tilde{a}_j) \circ \text{NTT}(\tilde{b}_i) \\[.5em] &amp;= (\text{NTT}(\tilde{a}_i) + \text{NTT}(\tilde{a}_j)) \circ (\text{NTT}(\tilde{b}_i) + \text{NTT}(\tilde{b}_j)) \\&amp;\quad\;\ - \text{NTT}(\tilde{a}_i) \circ \text{NTT}(\tilde{b}_i) - \text{NTT}(\tilde{a}_j) \circ \text{NTT}(\tilde{b}_j) \end{aligned}\] <p>for any $i \neq j$.</p> <h5 id="623-h-ntt">6.2.3 H-NTT</h5> <p>Furthermore, Hybrid-NTT (H-NTT) is proposed as an improved K-NTT and a new variant of NTT, by applying truncated-NTT in Step 2 and one-iteration Karatsuba algorithm in its point-wise multiplication.</p> <p>H-NTT uses truncated-NTT with $\beta$ levels cropped, instead of those full NTT in K-NTT. Its Step 2 is given as</p> \[\begin{aligned} \tilde{c}_i &amp;= \sum_{l=0}^{i} \tilde{a}_l \cdot \tilde{b}_{i-l} + \sum_{l=i+1}^{2^\alpha-1} y \cdot \tilde{a}_l \cdot \tilde{b}_{2^\alpha+i-l} \\ &amp;= \text{INTT}_\beta\! \left( \sum_{l=0}^{i} \text{NTT}_\beta(\tilde{a}_l) \circ \text{NTT}_\beta(\tilde{b}_{i-l}) +\! \sum_{l=i+1}^{2^\alpha-1} \text{NTT}_\beta(y) \circ \text{NTT}_\beta(\tilde{a}_l) \circ \text{NTT}_\beta(\tilde{b}_{2^\alpha+i-l}) \right), \end{aligned}\] <p>where $\text{NTT}_\beta/\text{INTT}_\beta$ means NWC-based $\text{NTT}^{CT, \psi}_{no \to bo, \beta}/\text{INTT}^{GS, \psi^{-1}}_{bo \to no, \beta}$ over $\mathbb{Z}_q[y] / (y^{ n/2\alpha} + 1)$, or CC-based $\text{NTT}^{CT}_{no \to bo, \beta}/\text{INTT}^{GS}_{bo \to no, \beta}$ over $\mathbb{Z}_q[y] / (y^{ n/2\alpha} - 1)$.</p> <p>One-iteration Karatsuba algorithm is also used in its point-wise multiplication.</p> <p>For example, to compute $(\sum_{i=0}^{2^\beta-1} \hat{a}_i x^i)(\sum_{i=0}^{2^\beta-1} \hat{b}_i x^i) \pmod{x^{2^\beta} - \psi}$,</p> <p>one can compute $\hat{a}_i \hat{b}_j$ for any $i = j$ first</p> <p>and then compute $\hat{a}_i \hat{b}_j + \hat{a}_j \hat{b}_i = (\hat{a}_i + \hat{a}_j)(\hat{b}_i + \hat{b}_j) - \hat{a}_i \hat{b}_i - \hat{a}_j \hat{b}_j$ for any $i \neq j$.</p> <h5 id="624-comparisons-and-discussions">6.2.4 Comparisons and discussions</h5> <p>Based on the high-level description of incomplete FFT trick, it shares some similarities with the method based on splitting polynomial ring.</p> <p>In fact, there is an isomorphism between $(\mathbb{Z}_q[x] / (x^{2^\beta} - y))[y] / (y^{ n/2\beta} \pm 1)$ and $(\mathbb{Z}_q[y] / (y^{ n/2\alpha} \pm 1))[x] / (x^{2^\alpha} - y)$ for any $\alpha = \beta$. And they have been proved computationally equivalent, which implies that their efficiencies are the same theoretically.</p> <p>These two methods can expand the value range of modulus $q$, because $q$ can only satisfy $q \equiv 1 \pmod{2n/{2^{\alpha+\beta}}}$ for some $\alpha, \beta$, instead of $q \equiv 1 \pmod{2n}$ when $n$ is fixed, for NWC-based NTT; besides, $q$ can only satisfy $q \equiv 1 \pmod{ n/2{\alpha+\beta}}$ for some $\alpha, \beta$, instead of $q \equiv 1 \pmod{n}$ when $n$ is fixed, for CC-based NTT.</p> <p>However, the limitations on $q$ can not be ignored, since $q$ must be an NTT-friendly prime such that $\mathbb{Z}_q$ is a finite field and $x^n \pm 1$ can be split into polynomials of small degree over $\mathbb{Z}_q$.</p> <p>In addition, as for the method based on splitting polynomial ring, the polynomial operations over $\mathbb{Z}_q[x] / (x^n \pm 1)$ can be transformed into those over a smaller ring $\mathbb{Z}_q[y] / (y^{ n/2\alpha} \pm 1)$. It leads to more modular implementation, since NTT over $\mathbb{Z}_q[y] / (y^{ n/2\alpha} \pm 1)$ can be implemented as a â€œblack boxâ€, and be re-called when required in Step 2.</p> <p>Both Pt-NTT and K-NTT use ${n}/{2^\alpha}$-point full NTT in their Step 2. It requires that the primitive ${n}/{2^{\alpha-1}}$-th root of unity exits for NWC-based NTT, or the primitive ${n}/{2^\alpha}$-th root of unity exits for CC-based NTT.</p> <p>Therefore, the parameter condition of Pt-NTT and K-NTT can be weakened to $q \equiv 1 \pmod{2n/{2^\alpha}}$ for the initial ring $\mathbb{Z}_q[x] / (x^n + 1)$, or $q \equiv 1 \pmod{ n/2\alpha}$ for the initial ring $\mathbb{Z}_q[x] / (x^n - 1)$. H-NTT can further weaken the parameter condition to $q \equiv 1 \pmod{2n/{2^{\alpha+\beta}}}$ for the ring $\mathbb{Z}_q[x] / (x^n + 1)$ by using truncated-NTT, or $q \equiv 1 \pmod{ n/2{\alpha+\beta}}$ for the ring $\mathbb{Z}_q[x] / (x^n - 1)$.</p> <p>By comparison, it can be seen that $\alpha$-round K-NTT and truncated-NTT are the special cases of H-NTT when $\beta = 0$ and $\alpha = 0$ respectively.</p> <p>More specially, $\text{NTT}^{CT, \psi}_{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}_{bo \to no}$ are the cases of H-NTT over $\mathbb{Z}_{q}[x] / (x^n + 1)$ when $\alpha = 0, \beta = 0$,</p> <p>and $\text{NTT}^{CT}_{no \to bo}$ and $\text{INTT}^{GS}_{bo \to no}$ are the cases of H-NTT over $\mathbb{Z}_{q}[x] / (x^n - 1)$ when $\alpha = 0, \beta = 0$.</p> <h4 id="method-based-on-large-modulus">Method Based on Large Modulus</h4> <p>Here we consider $\mathbb{Z}_q[x] / (x^n \pm 1)$, where $n$ is a power of two and the modulus $q$ is an NTT-unfriendly prime, but $q$ can be actually any positive integer.</p> <p>The process of $c = a \cdot b \in \mathbb{Z}_q[x] / (x^n \pm 1)$ is divided into two steps.</p> <ul> <li> <p><strong>Step 1.</strong></p> <p>Compute $câ€™ = a \cdot b \in \mathbb{Z}_N[x] / (x^n \pm 1)$, where $N$ is a positive integer and larger than the maximum absolute value of the coefficients during the computation over $\mathbb{Z}$.</p> </li> <li> <p><strong>Step 2.</strong></p> <p>One can recover the result in $\mathbb{Z}_q[x] / (x^n \pm 1)$ through reduction module $q$, i.e., $c = câ€™ \bmod q$.</p> </li> </ul> <p>It is called the method based on large modulus in this paper, because its key step is to select a large enough modulus $N$ in Step 1.</p> <p>Obviously, $N$ could be chosen such that $N &gt; nq^2$. When $N$ is large enough, the product of $a$ and $b$ in $\mathbb{Z}[x] / (x^n \pm 1)$ is identical to that in $\mathbb{Z}_N[x] / (x^n \pm 1)$.</p> <p>In order to apply NTTs, we consider two sub-cases of the values of $N$. One is that $N$ is an NTT-friendly prime. The other is that $N$ is the product of some NTT-friendly primes. When $N$ is the product of some NTT-friendly primes, i.e., $N = \prod_{i=1}^l q_i$ where each $q_i$ is an NTT-friendly prime, in this case, it can further be classified into two sub-methods.</p> <p>One is the method based on residue number system (RNS). The other is the method based on composite-modulus ring.</p> <h5 id="631-method-based-on-ntt-friendly-large-prime">6.3.1 Method based on NTT-friendly large prime.</h5> <p>When $N$ is an NTT-friendly prime, NTT can be performed in $\mathbb{Z}_N[x] / (x^n \pm 1)$ directly in Step 1.</p> <p>Notice that if $N$ is set sufficiently large and NTT-friendly, this method always works regardless of the value of the original modulus $q$.</p> <p>For example, if $N$ is a prime satisfying $N &gt; nq^2$ and $N \equiv 1 \pmod{2n}$, $n$-point full NWC-based NTT of modulus $N$ can always be used over $\mathbb{Z}_N[x] / (x^n + 1)$. Besides, if $N$ is a prime satisfying $N &gt; nq^2$ and $N \equiv 1 \pmod{n}$, $n$-point full CC-based NTT of modulus $N$ can always be used over $\mathbb{Z}_N[x] / (x^n - 1)$.</p> <h5 id="632-method-based-on-residue-number-system">6.3.2 Method based on residue number system.</h5> <p>Residue number system (RNS) is widely used in the context of homomorphic encryption for computing NTTs over many primes.</p> <p>Based on RNS, negative wrapped convolution with a modulus that is the product of some primes, can be transformed into ones with smaller moduli by Chinese Remainder Theorem, that is</p> \[\mathbb{Z}_N[x] / (x^n \pm 1) \cong \prod_{i=1}^l \mathbb{Z}_{q_i}[x] / (x^n \pm 1).\] <p>Denote by $c_i$ the product of $a$ and $b$ in $\mathbb{Z}_{q_i}[x] / (x^n \pm 1)$ for $i = 1, \dots, l$.</p> <p>After using NTTs to compute $c_i, i = 1, \dots, l$, the original product $c$ in $\mathbb{Z}_N[x] / (x^n \pm 1)$ can be recovered from $c_i, i = 1, \dots, l$, by Chinese Remainder Theorem in number theoretic.</p> <h5 id="633-method-based-on-composite-modulus-ring">6.3.3 Method based on composite-modulus ring.</h5> <p>The NTT can be performed over a polynomial ring with a composite modulus directly.</p> <p>Specifically, generalizes the concepts of NTT from a finite field to an integer ring, the basic idea of which was first developed in terms of FFT.</p> <p>Consider $\mathbb{Z}_N[x] / (x^n + 1)$, where $N = \prod_{i=1}^l q_i$ and each $q_i$ is NTT-friendly prime. If $2n \mid \gcd(q_1 - 1, \dots, q_l - 1)$, there exits a principal $2n$-th root of unity $\psi_{2n}$ in $\mathbb{Z}_N$.</p> <p>$\psi_{2n}$ is a principle $2n$-th root of unity in $\mathbb{Z}_N$, iff $(\psi_{2n} \bmod q_i)$ is a principle $2n$-th root of unity in $\mathbb{Z}_{q_i}$ for any $i$.</p> \[\mathbb{Z}_N[x] / (x^n + 1) \cong \prod_{i=0}^{n-1} \mathbb{Z}_N[x] / (x - \psi_{2n}^{2brv_n(i)+1}).\] <p>Its forward transform and inverse transform are illustrated as $\text{NTT}^{CT, \psi}_{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}_{bo \to no}$ over $\mathbb{Z}_{N}[x] / (x^n + 1)$.</p> <p>The CRT map of truncated-NTT with $\beta$ levels cropped is as follows.</p> \[\mathbb{Z}_N[x] / (x^n + 1) \cong \prod_{i=0}^{n/2^\beta - 1} \mathbb{Z}_N[x] / (x^{2^\beta} - \psi_{2n/2^\beta}^{2brv_{n/2^\beta}(i)+1}),\] <p>where $\psi_{2n/2^\beta}$ is a principal $2n/2^\beta$-th root of unity in $\mathbb{Z}_N$.</p> <p>Its forward transform and inverse transform are illustrated as $\text{NTT}^{CT, \psi}<em>{no \to bo, \beta}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no, \beta}$ over $\mathbb{Z}_N[x] / (x^n + 1)$, respectively.</p> <p>As for $\mathbb{Z}<em>N[x] / (x^n - 1)$, where $N = \prod</em>{i=1}^l q_i$ and each $q_i$ is NTT-friendly prime.</p> <p>If $n \mid \gcd(q_1 - 1, \dots, q_l - 1)$, there exits a principal $n$-th root of unity $\omega_n$ in $\mathbb{Z}_N$.</p> <p>$\omega_n$ is a principle $n$-th root of unity in $\mathbb{Z}_N$, iff $(\omega_n \bmod q_i)$ is a principle $n$-th root of unity in $\mathbb{Z}_{q_i}$ for any $i$.</p> <p>The CRT map of full-mapping FFT trick and truncated-NTT with $\beta$ levels cropped over $\mathbb{Z}_N[x] / (x^n - 1)$ can be derived similarly to those over $\mathbb{Z}_N[x] / (x^n + 1)$.</p> <h5 id="634-comparisons-and-discussions">6.3.4 Comparisons and discussions.</h5> <p>Compare the method based on large modulus and those based on incomplete FFT trick/splitting polynomial ring.</p> <p>The three sub-methods of the method based on large modulus are valid for any original modulus $q$ (including NTT-friendly ones), and can completely remove the restriction on $q$. But, their shortcomings are also obvious.</p> <p>Specifically, the method based on incomplete FFT trick and based on splitting polynomial ring still choose original $q$ as the modulus. But, the modulus $N$ used in the method based on NTT-friendly large prime and method based on composite-modulus ring, is much larger than original modulus $q$.</p> <p>For examples, $N$ could be chosen as $nq^2$. Although $N$ be smaller if one of the multiplicands is small, it will still be several orders of magnitude larger than $q$.</p> <p>It causes that the storage of coefficients and the computing-resource consume will be more than the cases of $q$ during the computation. Besides, as for the method based on residue number system, there are more than one NTT computation needed to be computed. Traditionally, it is more time-consuming and resource-consuming, because full NWC-based NTT, the method based on incomplete FFT trick and the method based on splitting polynomial ring only need one NTT computation.</p> <p>Therefore, if $q$ is an NTT-friendly prime number, the methods based on incomplete FFT trick and based on splitting polynomial ring are recommended strongly for an efficient implementation, instead of the method based on large modulus. But, when $q$ is an NTT-unfriendly prime number, one can turn to the method based on large modulus.</p> <p>Note that, there are some connections between the method based on residue number system and composite-modulus ring.</p> <p>Here review $\mathbb{Z}_N[x] / (x^n \pm 1)$. Both of them could choose $N = \prod_{i=1}^l q_i$ where each $q_i$ is NTT-friendly prime. If one split $N$ via CRT and keep $x^n \pm 1$ unchanged, it implies the method based on residue number system.</p> <p>If one split $x^n \pm 1$ via CRT and keep $N$ unchanged, it implies the method based on composite-modulus ring.</p> <p>Therefore, these two methods are derived from different splitting forms of moduli via CRT.</p> <h3 id="choosing-number-theoretic-transform-for-given-rings">CHOOSING NUMBER THEORETIC TRANSFORM FOR GIVEN RINGS</h3> <p>This section introduces how to choose an appropriate NTT for the given polynomial ring, mainly classifying the rings into three categories for the convenience of understanding.</p> <ul> <li>$\mathbb{Z}_q[x] / (x^n \pm 1)$ with respect to power-of-two $n$</li> <li>$\mathbb{Z}_q[x] / (x^n \pm 1)$ with respect to non-power-of-two $n$</li> <li>$\mathbb{Z}_q[x] / (\phi(x))$ with respect to general $\phi(x)$ of degree $n$.</li> </ul> <p>Mainly focus on the special rings of the form $\mathbb{Z}_q[x] / (x^n \pm 1)$ in the first two categories, and then extend the results to the general rings of the form $\mathbb{Z}_q[x] / (\phi(x))$ with respect to general $\phi(x)$ of degree $n$.</p> <h4 id="mathbbz_qx--xn-pm-1-with-respect-to-power-of-two-n">$\mathbb{Z}_q[x] / (x^n \pm 1)$ with Respect to Power-of-two $n$</h4> <h5 id="ntt-friendly-q">NTT-friendly $q$</h5> <p>In this case, $q$ is an NTT-friendly prime of the form $q = qâ€™ \cdot 2^e + 1$.</p> <p>Furthermore, classify it into two sub-cases, the first sub-case is that $q$ can lead to a full NTT.</p> <p>The another sub-case is that $q$ can not lead to a full NTT.</p> <p>First consider the first sub-case of $n$ being a power of two and $q$ leading to a full NTT.</p> <p>As for $\mathbb{Z}_q[x] / (x^n + 1)$, there exits $q \equiv 1 \pmod{2n}$, then full NWC-based NTT (e.g., $\text{NTT}^{CT, \psi}_{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}_{bo \to no}$) can be used to multiply two polynomials in $\mathbb{Z}_q[x] / (x^n + 1)$.</p> <p>Restate that one can compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n + 1)$ by</p> \[\boldsymbol{c} = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right).\] <p>As for $\mathbb{Z}_q[x] / (x^n - 1)$, there exits $q \equiv 1 \pmod n$, then full CC-based NTT (e.g., $\text{NTT}^{CT}_{no \to bo}$ and $\text{INTT}^{GS}_{bo \to no}$) can be used to multiply two polynomials in $\mathbb{Z}_q[x] / (x^n - 1)$.</p> <p>Restate that one can compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n - 1)$ by</p> \[\boldsymbol{c} = \text{INTT}^{GS}_{bo \to no} \left( \text{NTT}^{CT}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT}_{no \to bo}(\boldsymbol{b}) \right).\] <p>Then consider the another sub-case of $n$ being a power of two and $q$ not leading to a full NTT.</p> <p>It means that, for $\mathbb{Z}_q[x] / (x^n + 1)$, $q$ does not satisfy $q \equiv 1 \pmod{2n}$,</p> <p>or, for $\mathbb{Z}_q[x] / (x^n - 1)$, $q$ does not satisfy $q \equiv 1 \pmod n$.</p> <p>In this sub-case, the method based on incomplete FFT trick and the method splitting polynomial ring are highly recommended.</p> <p>For example, as for $\mathbb{Z}_q[x] / (x^n + 1)$, if $q$ only satisfies $q \equiv 1 \pmod{2n/{2^\alpha}}$ (resp., $q \equiv 1 \pmod{2n/{2^\beta}}$), then one can use $\alpha$-round method based on splitting polynomial ring (resp., method based on incomplete FFT trick with $\beta$ levels cropped) can be used to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n + 1)$.</p> <p>Besides, as for $\mathbb{Z}_q[x] / (x^n - 1)$, if $q$ only satisfies $q \equiv 1 \pmod{ n/2\alpha}$ (resp., $q \equiv 1 \pmod{ n/2\beta}$), then one can use $\alpha$-round method based on splitting polynomial ring (resp., method based on incomplete FFT trick with $\beta$ levels cropped) can be used to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n - 1)$.</p> <p>Furthermore, if $q$ only satisfies $q \equiv 1 \pmod{2n/{2^{\alpha+\beta}}}$ for $\mathbb{Z}_q[x] / (x^n + 1)$, one can use H-NTT with $\alpha$-round splitting and $\beta$ levels cropped;</p> <p>similarly, if $q$ only satisfies $q \equiv 1 \pmod{ n/2{\alpha+\beta}}$ for $\mathbb{Z}_q[x] / (x^n - 1)$, one can use H-NTT with $\alpha$-round splitting and $\beta$ levels cropped.</p> <h5 id="ntt-unfriendly-q">NTT-unfriendly $q$</h5> <p>In this case, $q$ is an NTT-unfriendly prime.</p> <p>In order to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n \pm 1)$, one can use the method based on large modulus.</p> <p>Firstly, compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_N[x] / (x^n \pm 1)$, where $N$ is a positive integer and larger than the maximum absolute value of the coefficients during the computation over $\mathbb{Z}$, and then compute $\boldsymbol{c} = \boldsymbol{c}â€™ \bmod q$.</p> <p>To compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_N[x] / (x^n \pm 1)$, one can use the method based on NTT-friendly large prime, the method based on residue number system or the method based on composite-modulus ring.</p> <h4 id="mathbbz_qx--xn-pm-1-with-respect-to-non-power-of-two-n">$\mathbb{Z}_q[x] / (x^n \pm 1)$ with Respect to Non-power-of-two $n$</h4> <p>Consider the case of non-power-of-two $n$, but actually $n$ can be a general integer.</p> <p>The essential idea about the computation of $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^n \pm 1)$ is described through two steps as follows.</p> <ol> <li> <p><strong>Step 1.</strong></p> <p>Compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^{nâ€™} \pm 1)$, where $nâ€™$ is a larger integer and $nâ€™ \ge 2n$.</p> </li> <li> <p><strong>Step 2.</strong></p> <p>One can recover the result in $\mathbb{Z}_q[x] / (x^n \pm 1)$ through reduction modulo $x^{nâ€™} \pm 1$, i.e., $\boldsymbol{c} = \boldsymbol{c}â€™ \bmod x^{nâ€™} \pm 1$.</p> <p>As for the ring $\mathbb{Z}_q[x] / (x^{nâ€™} \pm 1)$</p> <ol> <li>The first case is that $nâ€™$ is a power of two, which is denoted by $2^k$.</li> <li>The other case is that $nâ€™$ is of the form $h \cdot 2^k$, where $h$ is an odd number.</li> </ol> </li> </ol> <h5 id="power-of-two-n">Power-of-two $nâ€™$</h5> <p>As for the first case, the computation is transformed into that with respect to $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^{nâ€™} \pm 1)$, where $nâ€™$ is a power of two.</p> <h5 id="use-goods-trick">Use Goodâ€™s trick</h5> <p>As for the other case, the computation is transformed into that with respect to $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (x^{nâ€™} \pm 1)$, where $nâ€™ = h \cdot 2^k$ and $h$ is an odd number.</p> <p>One can use Goodâ€™s trick to compute polynomial multiplication over $\mathbb{Z}_q[x] / (x^{h \cdot 2^k} - 1)$. In this paper, Goodâ€™s trick is recommended, since there are more freedom to select an odd number $h$ and power-of-two $2^k$. If one expand the length to power-of-two $nâ€™$, it is inconvenient to find a suitable polynomial of some particular degree up to the next power of two.</p> <h4 id="mathbbz_qx--phix-with-respect-to-general-phix-of-degree-n">$\mathbb{Z}_q[x] / (\phi(x))$ with Respect to General $\phi(x)$ of Degree $n$</h4> <p>Here we consider the more general ring $\mathbb{Z}_q[x] / (\phi(x))$ where $\phi(x)$ is an arbitrary polynomial of degree $n$. In order to apply fast NTT algorithm, there are complex but efficient methods.</p> <p>The computation of $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (\phi(x))$ can be described through two steps as follows.</p> <ol> <li> <p><strong>Step 1.</strong></p> <p>Compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_N[x] / (x^{nâ€™} \pm 1)$, where $N$ is a positive integer and larger than the maximum absolute value of the coefficients during the computation over $\mathbb{Z}$, $nâ€™$ is a larger integer and $nâ€™ \ge 2n$.</p> </li> <li> <p><strong>Step 2.</strong></p> <p>And then compute $\boldsymbol{c} = (\boldsymbol{c}â€™ \bmod \phi(x)) \bmod q$.</p> </li> </ol> <p>Therefore, the computation of $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x] / (\phi(x))$ is transformed into that of $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_N[x] / (x^{nâ€™} \pm 1)$.</p> <h3 id="number-theoretic-transform-in-nist-pqc">NUMBER THEORETIC TRANSFORM IN NIST PQC</h3> <p>NIST PQC Round 3 candidatesâ€™ schemes mainly focus on their NTT-based implementations over their underlying rings $\mathbb{Z}_q[x] / (\phi(x))$, where $\mathbb{Z}_q[x] / (\phi(x))$ is instantiated as in Table.</p> <table> <thead> <tr> <th>Schemes</th> <th>n</th> <th>q</th> <th>Rings</th> <th>Types</th> <th>Methods &amp; Algorithms</th> </tr> </thead> <tbody> <tr> <td>Kyber Round 1</td> <td>256</td> <td>7681</td> <td>$\mathbb{Z}_q[x] / (x^n + 1)$</td> <td>NTT-friendly $q \equiv 1 \pmod{2n}$</td> <td>$n$-point full NWC-based NTT</td> </tr> <tr> <td>Kyber Round 2, Kyber Round 3</td> <td>256</td> <td>3329</td> <td>$\mathbb{Z}_q[x] / (x^n + 1)$</td> <td>NTT-friendly $q \equiv 1 \pmod{n}$</td> <td>Incomplete FFT trick, Splitting polynomial ring</td> </tr> <tr> <td>Dilithium Round 3</td> <td>256</td> <td>8380417</td> <td>$\mathbb{Z}_q[x] / (x^n + 1)$</td> <td>NTT-friendly $q \equiv 1 \pmod{2n}$</td> <td>$n$SS-point full NWC-based NTT</td> </tr> </tbody> </table> <p><img src="/june.github.io/assets/img/post/ntt/image_20.png" style="max-width: 100%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>Notice that not all the schemes can directly use full NTT to multiply polynomials. For example, full NWC-based NTT over $\mathbb{Z}_q[x] / (x^n + 1)$ further requires that the prime $q$ satisfies $q \equiv 1 \pmod{2n}$. Only Dilithium and Falcon can meet the situation. Besides, full NTT can not be directly used in those lattice-based schemes with power-of-two moduli, such as Saber and NTRU.</p> <h4 id="kyber">Kyber</h4> <p>Kyber is an IND-CCA secure MLWE-based KEM from the lattice-based cryptography suite called â€œCryptographic Suite for Algebraic Lattices (CRYSTALS)â€.</p> <p>The Kyber submission in NIST PQC Round 1, named Kyber Round 1, uses $n = 256$ and $q = 7681$ which satisfies $q \equiv 1 \pmod{2n}$.</p> <p>Its way to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathcal{R}_q$ in C reference implementation is elaborated as</p> \[c = \psi^{-1} \circ \text{INTT}^{GS}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right),\] <p>where the inverse transform is $\psi^{-1} \circ \text{INTT}^{GS}_{bo \to no}$, the output of which is the same as that of $\text{INTT}^{GS, \psi^{-1} }_{bo \to no}$.</p> <p>As for its AVX2 optimized implementation, Kyber Round 1 uses $\text{NTT}^{CT, \psi}_{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1} }_{bo \to no}$, and the computation is restated as</p> \[c = \text{INTT}^{GS, \psi^{-1} }\_{bo \to no} \left( \text{NTT}^{CT, \psi}\_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}\_{no \to bo}(\boldsymbol{b}) \right).\] <p>The Kyber submissions in the second and third round of NIST PQC competition use a smaller prime number $q = 3329$ which no longer satisfies $q \equiv 1 \pmod{2n}$, but $q \equiv 1 \pmod{n}$.</p> <p>Kyber Round 2 and Round 3 use truncated-NTT with one level cropped: $\text{NTT}^{CT, \psi}_{no \to bo, \beta=1}$ and $\text{INTT}^{GS, \psi^{-1} }_{bo \to no, \beta=1}$.</p> <p>The point-wise multiplication is treated as the corresponding polynomial multiplications in $\mathbb{Z}_{q}[x] / (x^2 - \omega_{n}^{2brv_{n/2}(i)+1})$.</p> <p>Its way to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathcal{R}_q$ is restated as</p> \[c = \text{INTT}^{GS, \psi^{-1}}_{bo \to no, \beta=1} \left( \text{NTT}^{CT, \psi}_{no \to bo, \beta=1}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo, \beta=1}(\boldsymbol{b}) \right).\] <p>Further, Liang et al. improve its truncated-NTT by using H-NTT with $\alpha = 0$, which can be seen as $\text{NTT}^{CT, \psi}_{no \to bo, \beta=1}$ and $\text{INTT}^{GS, \psi^{-1} }_{bo \to no, \beta=1}$ with one-iteration Karatsuba algorithm in its point-wise multiplication.</p> <p>Different from truncated-NTT used in Kyber Round 2 and Round 3, they used 1-round Pt-NTT with ${n}/{2}$-point full NWC-based NTT for â€œsmall-Kyberâ€. But, their implementation had a slightly worse performance than the initial one.</p> <h4 id="dilithium">Dilithium</h4> <p>Dilithium is a signature scheme based on module lattice and is one of the algorithms from CRYSTALS.</p> <p>Its parameter sets satisfy the condition $q \equiv 1 \pmod{2n}$ such that $n$-point full NWC-based $\text{NTT}^{CT, \psi}_{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1} }_{bo \to no}$ can be utilized.</p> <p>Its way to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathcal{R}_q$ is restated as</p> \[c = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right).\] <h5 id="c-some-skills">C SOME SKILLS</h5> <p>Those lattice-based schemes fully utilizes the advantages of NTT to improve their efficiency.</p> <p>As for MLWE-based schemes such as Kyber, Dilithium, etc, at a high level, their basic operations can be described as matrix-vector polynomial multiplication $\mathbf{A}^T \mathbf{r}$ and vector-vector polynomial multiplication $\mathbf{s}^T \mathbf{u}$, where $\mathbf{A} \in \mathcal{R}_q^{k \times k}$, $\mathbf{r}, \mathbf{s}, \mathbf{u} \in \mathcal{R}_q^{k \times 1}$.</p> <p>Those schemes directly generate the public key term $\hat{\mathbf{A}}$ already in the NTT domain by rejection sampling, instead of generating $\mathbf{A}$ followed by applying forward transform on each element. It can save $k^2$ forward transforms.</p> <p>The linearity of NTT can lead to $\text{INTT}\left( \hat{\mathbf{A}}^T \circ \text{NTT}(\mathbf{r}) \right)$ where there are only $k$ forward transforms and $k$ inverse transforms.</p> <p>Once the forward transform result $\hat{\mathbf{s}}$ is computed, $\hat{\mathbf{s}}$ can be stored or transmitted without any extra requirement of storage, for following use in multiple polynomial multiplications.</p> <p>Using $\hat{\mathbf{s}}$ that is stored or transmitted in advance, one can compute $\mathbf{s}^T \mathbf{u}$ by $\text{INTT}\left( \hat{\mathbf{s}}^T \circ \text{NTT}(\mathbf{u}) \right)$, within only $k$ forward transforms and $k$ inverse transforms.</p> <p>As for MLWR-based schemes, the linearity of NTT is helpful in the NTT-based implementation of MLWR-based schemes such as Saber. The number of forward transforms and inverse transforms in Saberâ€™s matrix-vector multiplication $\mathbf{As}$ can be reduced from $2k^2$ and $k^2$ to $k^2 + k$ and $k$, respectively, while the number of inverse transforms $\mathbf{b}^T \mathbf{s}$ in vector-vector multiplication can be reduced from $k$ to 1, where $\mathbf{A} \in \mathcal{R}_q^{k \times k}, \mathbf{b}, \mathbf{s} \in \mathcal{R}_q^{k \times 1}$.</p>]]></content><author><name></name></author><category term="Study"/><category term="MATH"/><category term="PQC"/><category term="Cryptography"/><summary type="html"><![CDATA[NTT(Number Theoretic Transform) for ML-KEM, ML-DSA]]></summary></entry><entry><title type="html">PQC ë™í–¥ (~ â€˜24.10)</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2025/pqc-updates/" rel="alternate" type="text/html" title="PQC ë™í–¥ (~ â€˜24.10)"/><published>2025-09-18T00:00:00+00:00</published><updated>2025-09-18T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2025/pqc-updates</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2025/pqc-updates/"><![CDATA[<h3 id="250924-26-6th-pqc-standardization-conference">25.09.24-26 <a href="https://csrc.nist.gov/events/2025/6th-pqc-standardization-conference">6th PQC Standardization Conference</a></h3> <h4 id="nist-pqc-standardization-project-dustin-moody-september-24-2025"><a href="https://csrc.nist.gov/Presentations/2025/nist-pqc-project">NIST PQC Standardization Project</a> Dustin Moody (September 24, 2025)</h4> <h4 id="sp-800-227-recommendations-for-key-encapsulation-mechanisms-gorjan-alagic-september-25-2025"><a href="https://csrc.nist.gov/Presentations/2025/sp-800-227-recommendations-for-key-encapsulation-m">SP 800-227: Recommendations for Key-Encapsulation Mechanisms</a> Gorjan Alagic (September 25, 2025)</h4> <h3 id="250918-nist-publishes-sp-800-227">25.09.18. <a href="https://csrc.nist.gov/News/2025/nist-publishes-sp-800-227">NIST Publishes SP 800-227</a></h3> <p>â€œRecommendations for Key-Encapsulation Mechanismsâ€</p> <h4 id="250729-pqc-hybrid-ê²€ì¦-ì•ˆë‚´-ë°œí‘œ">25.07.29 PQC Hybrid ê²€ì¦ ì•ˆë‚´ <a href="https://www.ncsc.go.kr/main/cop/bbs/selectBoardArticle.do?bbsId=CryptoNotice_main&amp;nttId=213309&amp;pageIndex=1&amp;searchCnd2=">ë°œí‘œ</a></h4> <ul> <li><a href="https://www.ncsc.go.kr/main/cop/bbs/selectBoardArticle.do?bbsId=CryptoNotice_main&amp;nttId=221869&amp;pageIndex=1&amp;searchCnd2=">ì•”í˜¸ëª¨ë“ˆ êµ¬í˜„ ì•ˆë‚´ì„œ</a> C.5 ì–‘ìë‚´ì„± ì•”í˜¸ë¥¼ í™œìš©í•œ í•˜ì´ë¸Œë¦¬ë“œ ë°©ì‹</li> </ul> <h4 id="800-227-46-multi-algorithm-kems-and-pqt-hybrids">800-227 4.6. Multi-Algorithm KEMs and PQ/T Hybrids</h4> <ul> <li><a href="https://www.etsi.org/deliver/etsi_tr/103900_103999/103966/01.01.01_60/tr_103966v010101p.pdf">ETSI TR 103 966 v1.1.1.</a> ë¶€ë¡ A.3 êµì°¨ í™•ì¸</li> </ul> <h3 id="250311-nistir-8545">25.03.11. <a href="https://csrc.nist.gov/pubs/ir/8545/final">NISTIR 8545</a></h3> <p>â€œStatus Report on the Fourth Round of the NIST Post-Quantum Cryptography Standardization Processâ€</p> <h4 id="ê³µì‹-íƒ€ì„ë¼ì¸">ê³µì‹ íƒ€ì„ë¼ì¸</h4> <p><img src="/june.github.io/assets/img/post/pqc_updates/250311_nistir_8545.png" alt="timeline"/> </p> <h4 id="hqc-ì„ ì •">HQC ì„ ì •</h4> <ul> <li>4ë¼ìš´ë“œ í›„ë³´ë¡œ ì„ ì •ëœ ì•Œê³ ë¦¬ì¦˜ë“¤ì€ NISTì—ì„œ íŒë‹¨í•˜ê¸°ì— ëª¨ë‘ ë°”ë¡œ í‘œì¤€ìœ¼ë¡œì¨ ì‚¬ìš© ê°€ëŠ¥í•œ ì•Œê³ ë¦¬ì¦˜ë“¤ì´ì—ˆìŒ</li> <li>ì£¼ìš” í‰ê°€ ê¸°ì¤€ì€ (1) ì•ˆì „ì„± (2) ë¹„ìš© ë° ì„±ëŠ¥ (3) ì•Œê³ ë¦¬ì¦˜ ë° êµ¬í˜„ íŠ¹ì„±ìœ¼ë¡œ í•´ë‹¹ ê¸°ì¤€ì— ë”°ë¥¸ ìì„¸í•œ í‰ê°€ ë‚´ìš©ì€ ë‹¤ìŒê³¼ ê°™ìŒ</li> <li>(1) ì•ˆì „ì„±: ê° ì•Œê³ ë¦¬ì¦˜ì€ ì„œë¡œ ë‹¤ë¥¸ ì•ˆì „ì„± ìˆ˜ì¤€ì„ ê°€ì§€ë©°, NISTëŠ” HQCì˜ ì•ˆì „ì„±ì´ BIKEì˜ ì•ˆì „ì„±ë³´ë‹¤ ë” ë†’ì€ ì‹ ë¢°ë„ë¥¼ ê°€ì§„ë‹¤ê³  ë´„</li> <li>(2) ë¹„ìš© ë° ì„±ëŠ¥: ìº¡ìŠí™” í‚¤ì™€ ì•”í˜¸ë¬¸ í¬ê¸° &amp; ê° ì•Œê³ ë¦¬ì¦˜ì˜ ê³„ì‚° íš¨ìœ¨ì„±(ì†ë„). HQCê°€ BIKEë³´ë‹¤ ë” ë¹ ë¥´ê²Œ ë™ì‘í•˜ë©°, McEileceëŠ” êµ¬ì„± ì•Œê³ ë¦¬ì¦˜ê°„ ì†ë„ì˜ ì°¨ì´ê°€ ë§¤ìš° í¬ê¸° ë•Œë¬¸ì— ë²”ìš©ì„±ì´ ë–¨ì–´ì§. í‚¤ì™€ ì•”í˜¸ë¬¸ì˜ í¬ê¸°ëŠ” HQCë³´ë‹¤ BIKEê°€ íš¨ìœ¨ì ì´ë©°, ì´ëŠ” McEileceë³´ë‹¤ë„ ë‚˜ì€ ì„±ëŠ¥ì„. McElieceëŠ” ì•”í˜¸ë¬¸ì€ ì‘ì§€ë§Œ ìº¡ìŠí™” í‚¤ê°€ ë§¤ìš° ì»¤ TLS 1.3ì— ì ì ˆí•˜ì§€ ì•ŠìŒ</li> <li>(3) êµ¬í˜„ íŠ¹ì„±: McElieceë¥¼ ì†”ë£¨ì…˜ìœ¼ë¡œ í™œìš© ê°€ëŠ¥í•œ í™˜ê²½ì— ëŒ€í•˜ì—¬ ìš”ì²­í–ˆìœ¼ë‚˜, ê²°ê³¼ ë³´ê³ ê°€ ë§ì§€ ì•Šì•˜ìœ¼ë©°, í•´ë‹¹ í™˜ê²½ì„ ìœ„í•œ ë³„ë„ì˜ ì•”í˜¸ ìì‚° ëª©ë¡ì„ êµ¬ì„±í•˜ëŠ” ë°©ì‹ì€ PQC ì „í™˜ ì¸¡ë©´ì—ì„œ ì•”í˜¸í™” ë¯¼ì²©ì„±ì„ ì œê³µí•˜ê¸° ì–´ë µê²Œ ë§Œë“¦</li> <li>NISTì˜ í‘œì¤€í™” ëª©ì ì€ ì¼ë°˜ì ì¸ í™˜ê²½ì—ì„œ í™œìš© ê°€ëŠ¥í•œ KEMì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê²ƒìœ¼ë¡œ ê°•ë ¥í•œ ì•ˆì „ì„±ê³¼ ë²”ìš©ì„±ì„ ê³ ë ¤í•˜ì—¬ HQCë¥¼ í‘œì¤€ìœ¼ë¡œ ì„ ì •í•¨</li> </ul> <p>ê²°ë¡ </p> <ul> <li>NISTëŠ” HQCê°€ ML-KEMê³¼ ì¶©ë¶„í•œ ìƒí˜¸ ë³´ì™„ì„±ì„ ê°€ì§„ë‹¤ê³  íŒë‹¨í•¨. HQCëŠ” ML-KEMê³¼ ë‹¤ë¥¸ ë¬¸ì œì— ì•ˆì „ì„±ì„ ê¸°ë°˜í•˜ëŠ” ë™ì‹œì— ë²”ìš© ì•±ì— ëŒ€í•œ í•©ë¦¬ì  ì„±ëŠ¥ì„ ìœ ì§€í•¨</li> <li>BIKE ì—­ì‹œ ë¹„ìŠ·í•œ ì„±ì§ˆì„ ê³ ë ¤í•˜ì—¬ í‘œì¤€í™” í›„ë³´ë¡œ ì„ ì •ë˜ì—ˆìœ¼ë‚˜, HQCì™€ ìœ ì‚¬í•œ ê¸°ë°˜ ë¬¸ì œë¥¼ ë‹¤ë£¨ë©´ì„œë„ ì•ˆì „ì„±ì€ ë” ë‚®ë‹¤ê³  íŒë‹¨ë˜ì–´ í‘œì¤€ìœ¼ë¡œ í•¨ê»˜ ì„ ì •í•˜ì§€ ì•ŠìŒ</li> <li>HQCì˜ í‘œì¤€í™”ëŠ” ì•½ 2ë…„ì •ë„ ì†Œìš”ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒí•¨</li> </ul> <h3 id="241112-nistir-8547">24.11.12. <a href="https://csrc.nist.gov/pubs/ir/8547/ipd">NISTIR 8547</a></h3> <p>â€œTransition to Post-Quantum Cryptography Standardsâ€</p> <h4 id="41-nist-cryptographic-algorithm-standards-and-guidelines">4.1. NIST Cryptographic Algorithm Standards and Guidelines</h4> <ul> <li>Acceptable: FIPS ë˜ëŠ” SPì— ì •ì˜ëœ ì•Œê³ ë¦¬ì¦˜ ë° í‚¤ ê¸¸ì´/ê°•ë„ê°€ ê´€ë ¨ ì§€ì¹¨ì— ë”°ë¼ ì‚¬ìš©ì´ ìŠ¹ì¸ë¨</li> <li>Deprecated: ì•Œê³ ë¦¬ì¦˜ê³¼ í‚¤ ê¸¸ì´/ê°•ë„ë¥¼ ì‚¬ìš©í•  ìˆ˜ëŠ” ìˆìœ¼ë‚˜ ì¼ë¶€ ë³´ì•ˆ ìœ„í—˜ì´ ì¡´ì¬í•¨ (ë°ì´í„° ì¤‘ìš”ë„ì— ë”°ë¼ ì‚¬ìš© ê²°ì •)</li> <li>Disallowed: í•´ë‹¹ ì•Œê³ ë¦¬ì¦˜, í‚¤ ê¸¸ì´/ê°•ë„, ë§¤ê°œë³€ìˆ˜ ì§‘í•© ë˜ëŠ” ì²´ê³„ê°€ ëª…ì‹œëœ ëª©ì ì— ë” ì´ìƒ í—ˆìš©ë˜ì§€ ì•ŠìŒ</li> <li>Legacy use: ì•Œê³ ë¦¬ì¦˜, ì²´ê³„ ë˜ëŠ” ë§¤ê°œë³€ìˆ˜ ì§‘í•©ì´ ì´ë¯¸ ë³´í˜¸ëœ ì •ë³´(ì˜ˆ: ì•”í˜¸ë¬¸ ë°ì´í„°ì˜ ë³µí˜¸í™” ë˜ëŠ” ë””ì§€í„¸ ì„œëª…ì˜ ê²€ì¦)ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë°ì—ë§Œ ì‚¬ìš©ë  ìˆ˜ ìˆìŒ</li> </ul> <p>Table 1: Post-Quantum Security Categories</p> <table> <thead> <tr> <th><strong>Security Category</strong></th> <th><strong>Attack Type</strong></th> <th><strong>Example</strong></th> </tr> </thead> <tbody> <tr> <td>1</td> <td>Key search on a block cipher with a 128-bit key</td> <td>AES-128</td> </tr> <tr> <td>2</td> <td>Collision search on a 256-bit hash function</td> <td>SHA-256</td> </tr> <tr> <td>3</td> <td>Key search on a block cipher with a 192-bit key</td> <td>AES-192</td> </tr> <tr> <td>4</td> <td>Collision search on a 384-bit hash function</td> <td>SHA3-384</td> </tr> <tr> <td>5</td> <td>Key search on a block cipher with a 256-bit key</td> <td>AES-256</td> </tr> </tbody> </table> <p>Table 2: Quantum-vulnerable digital signature algorithms</p> <table> <thead> <tr> <th><strong>Digital Signature Algorithm Family</strong></th> <th><strong>Parameters</strong></th> <th><strong>Transition</strong></th> </tr> </thead> <tbody> <tr> <td><strong>ECDSA</strong> [FIPS186]</td> <td>112 bits of security strength</td> <td><em>Deprecated</em> after 2030 <em>Disallowed</em> after 2035</td> </tr> <tr> <td>Â </td> <td>â‰¥ 128 bits of security strength</td> <td><em>Disallowed</em> after 2035</td> </tr> <tr> <td><strong>EdDSA</strong> [FIPS186]</td> <td>â‰¥ 128 bits of security strength</td> <td><em>Disallowed</em> after 2035</td> </tr> <tr> <td><strong>RSA</strong> [FIPS186]</td> <td>112 bits of security strength</td> <td><em>Deprecated</em> after 2030 <em>Disallowed</em> after 2035</td> </tr> <tr> <td>Â </td> <td>â‰¥ 128 bits of security strength</td> <td><em>Disallowed</em> after 2035</td> </tr> </tbody> </table> <p>Table 3: Post-quantum digital signature algorithms</p> <table> <thead> <tr> <th><strong>Digital Signature Algorithm Family</strong></th> <th><strong>Parameter Sets</strong></th> <th><strong>Security Strength</strong></th> <th><strong>Security Category</strong></th> </tr> </thead> <tbody> <tr> <td><strong>ML-DSA</strong> [FIPS204]</td> <td>ML-DSA-44</td> <td>128 bits</td> <td>2</td> </tr> <tr> <td>Â </td> <td>ML-DSA-65</td> <td>192 bits</td> <td>3</td> </tr> <tr> <td>Â </td> <td>ML-DSA-87</td> <td>256 bits</td> <td>5</td> </tr> <tr> <td><strong>SLH-DSA</strong> [FIPS205]</td> <td>SLH-DSA-SHA2-128[s/f], SLH-DSA-SHAKE-128[s/f]</td> <td>128 bits</td> <td>1</td> </tr> <tr> <td>Â </td> <td>SLH-DSA-SHA2-192[s/f], SLH-DSA-SHAKE-192[s/f]</td> <td>192 bits</td> <td>3</td> </tr> <tr> <td>Â </td> <td>SLH-DSA-SHA2-256[s/f], SLH-DSA-SHAKE-256[s/f]</td> <td>256 bits</td> <td>5</td> </tr> <tr> <td><strong>LMS, HSS</strong> [SP800208]</td> <td>With SHA-256/192, With SHAKE256/192</td> <td>192 bits</td> <td>3</td> </tr> <tr> <td>Â </td> <td>With SHA-256, With SHAKE256</td> <td>256 bits</td> <td>5</td> </tr> <tr> <td><strong>XMSS, XMSS^MT</strong> [SP800208]</td> <td>With SHA-256/192, With SHAKE256/192</td> <td>192 bits</td> <td>3</td> </tr> <tr> <td>Â </td> <td>With SHA-256, With SHAKE256</td> <td>256 bits</td> <td>5</td> </tr> </tbody> </table> <p>Table 4: Quantum-vulnerable key-establishment schemes</p> <table> <thead> <tr> <th><strong>Key Establishment Scheme</strong></th> <th><strong>Parameters</strong></th> <th><strong>Transition</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Finite Field DH and MQV</strong> [SP80056A]</td> <td>112 bits of security strength</td> <td><em>Deprecated</em> after 2030 <em>Disallowed</em> after 2035</td> </tr> <tr> <td>Â </td> <td>â‰¥ 128 bits of security strength</td> <td><em>Disallowed</em> after 2035</td> </tr> <tr> <td><strong>Elliptic Curve DH and MQC</strong> [SP80056A]</td> <td>112 bits of security strength</td> <td><em>Deprecated</em> after 2030 <em>Disallowed</em> after 2035</td> </tr> <tr> <td>Â </td> <td>â‰¥ 128 bits of security strength</td> <td><em>Disallowed</em> after 2035</td> </tr> <tr> <td><strong>RSA</strong> [SP80056B]</td> <td>112 bits of security strength</td> <td><em>Deprecated</em> after 2030 <em>Disallowed</em> after 2035</td> </tr> <tr> <td>Â </td> <td>â‰¥ 128 bits of security strength</td> <td><em>Disallowed</em> after 2035</td> </tr> </tbody> </table> <p>Table 5: Post-quantum key-establishment schemes</p> <table> <thead> <tr> <th><strong>Key Establishment Scheme</strong></th> <th><strong>Parameter Sets</strong></th> <th><strong>Security Strength</strong></th> <th><strong>Security Category</strong></th> </tr> </thead> <tbody> <tr> <td><strong>ML-KEM</strong> [FIPS203]</td> <td>ML-KEM-512</td> <td>128 bits</td> <td>1</td> </tr> <tr> <td>Â </td> <td>ML-DSA-768</td> <td>192 bits</td> <td>3</td> </tr> <tr> <td>Â </td> <td>ML-DSA-1024</td> <td>256 bits</td> <td>5</td> </tr> </tbody> </table> <p>Table 6: Block ciphers</p> <table> <thead> <tr> <th><strong>Block Cipher</strong></th> <th><strong>Parameter Sets</strong></th> <th><strong>Security Strength</strong></th> <th><strong>Security Category</strong></th> </tr> </thead> <tbody> <tr> <td><strong>AES</strong> [FIPS197]</td> <td>AES-128</td> <td>128 bits</td> <td>1</td> </tr> <tr> <td>Â </td> <td>AES-192</td> <td>192 bits</td> <td>3</td> </tr> <tr> <td>Â </td> <td>AES-256</td> <td>256 bits</td> <td>5</td> </tr> </tbody> </table> <p>Table 7: Hash functions and XOFs</p> <table> <thead> <tr> <th><strong>Hash/XOF Algorithm Family</strong></th> <th><strong>Variants</strong></th> <th><strong>Collision Security Strength</strong></th> <th><strong>Collision Security Category</strong></th> <th><strong>Preimage Security Strength</strong></th> <th><strong>Preimage Security Category</strong></th> </tr> </thead> <tbody> <tr> <td><strong>SHA-1</strong> [FIPS180]</td> <td>SHA-1</td> <td>80 bits</td> <td>&lt; 1</td> <td>160 bits</td> <td>1</td> </tr> <tr> <td><strong>SHA-2</strong> [FIPS180]</td> <td>SHA-224, SHA-512/224</td> <td>112 bits</td> <td>&lt; 1</td> <td>224 bits</td> <td>3</td> </tr> <tr> <td>Â </td> <td>SHA-256, SHA-512/256</td> <td>128 bits</td> <td>2</td> <td>256 bits</td> <td>5</td> </tr> <tr> <td>Â </td> <td>SHA-384</td> <td>192 bits</td> <td>4</td> <td>384 bits</td> <td>5</td> </tr> <tr> <td>Â </td> <td>SHA-512</td> <td>256 bits</td> <td>5</td> <td>512 bits</td> <td>5</td> </tr> <tr> <td><strong>SHA-3</strong> [FIPS202]</td> <td>SHA3-224</td> <td>112 bits</td> <td>&lt; 1</td> <td>224 bits</td> <td>3</td> </tr> <tr> <td>Â </td> <td>SHA3-256</td> <td>128 bits</td> <td>2</td> <td>256 bits</td> <td>5</td> </tr> <tr> <td>Â </td> <td>SHAKE128</td> <td>128 bits</td> <td>2</td> <td>128 bits</td> <td>2</td> </tr> <tr> <td>Â </td> <td>SHA3-384</td> <td>192 bits</td> <td>4</td> <td>384 bits</td> <td>5</td> </tr> <tr> <td>Â </td> <td>SHA3-512</td> <td>256 bits</td> <td>5</td> <td>512 bits</td> <td>5</td> </tr> <tr> <td>Â </td> <td>SHAKE256</td> <td>256 bits</td> <td>5</td> <td>512 bits</td> <td>5</td> </tr> </tbody> </table> <h3 id="241024-nistir-8528">24.10.24. <a href="https://csrc.nist.gov/pubs/ir/8528/final">NISTIR 8528</a></h3> <p>â€œStatus Report on the First Round of the Additional Digital Signature Schemes for the NIST Post-Quantum Cryptography Standardization Processâ€</p> <h5 id="table-1">[Table 1]</h5> <p>22.07, ì„œëª… í¬íŠ¸í´ë¦¬ì˜¤ ë‹¤ì–‘í™”ë¥¼ ìœ„í•´ ì¶”ê°€ ì „ìì„œëª… ëª¨ì§‘í•¨ì„ ê³µê³ .</p> <p>ì´ë¯¸ ê²©ì ê¸°ë°˜ ì„œëª… ë°©ì‹ ë‘ ê°€ì§€ê°€ í‘œì¤€í™”ë˜ì—ˆê¸° ë•Œë¬¸ì—, ê²©ìë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì¶”ê°€ ë²”ìš© ì„œëª… ë°©ì‹ê³¼ ì§§ì€ ì„œëª…ê³¼ ë¹ ë¥¸ ê²€ì¦ ì†ë„ë¥¼ ê°–ì¶˜ ì„œëª… ë°©ì‹ì— íŠ¹ë³„í•œ ê´€ì‹¬ì„ í‘œëª…</p> <p>22.09, call for proposal ë°œí‘œ</p> <p>23.06, 50ê°œ íŒ¨í‚¤ì§€ ì ‘ìˆ˜</p> <p>23.07, 40ê°œê°€ 1ì°¨ ë¼ìš´ë“œ í›„ë³´ë¡œ ìŠ¹ì¸</p> <ul> <li>*1ì°¨ í›„ë³´ ê²°ì • ê¸°ì¤€: C ì½”ë“œ êµ¬í˜„, KAT, ì„œë©´ ì‚¬ì–‘ì„œ, í•„ìˆ˜ ì§€ì  ì¬ì‚°ê¶Œ ì§„ìˆ ì„œ ë“± (ì•ˆì „ì„±, ì„±ëŠ¥, ì•Œê³ ë¦¬ì¦˜ ë° êµ¬í˜„ ë“±ì€ ê³ ë ¤í•˜ì§€ ì•ŠìŒ)**</li> </ul> <p>24.04, 5ì°¨ NIST PQC í‘œì¤€í™” ì»¨í¼ëŸ°ìŠ¤</p> <p>24.10, 14ê°œì˜ ì„œëª… ì•Œê³ ë¦¬ì¦˜ì„ 2ì°¨ ë¼ìš´ë“œ í›„ë³´ë¡œ ì„ ì •</p> <ul> <li>2<em>ì°¨ í›„ë³´ ê²°ì • ê¸°ì¤€: ì•ˆì „ì„±, ì„±ëŠ¥, ê¸°ë°˜ ë¬¸ì œ ë“±ì˜ ì•Œê³ ë¦¬ì¦˜ íŠ¹ì„±</em></li> <li><em>ê²©ì ê¸°ë°˜ì€ CRYSTALS-Dilithiumê³¼ Falcon ëª¨ë‘ë³´ë‹¤</em></li> </ul> <p><em>ì ì–´ë„ í•˜ë‚˜ì˜ ì••ë„ì  ì„±ëŠ¥ ìš°ìœ„ ì œê³µ</em></p> <ul> <li><em>ë¹„ê²©ì ê¸°ë°˜ì€ SPHINCS+ë³´ë‹¤ ì ì–´ë„ í•˜ë‚˜ì˜ ì••ë„ì  ì„±ëŠ¥ ìš°ìœ„ ì œê³µ</em></li> </ul> <p>25.01.17 ê°œì„  íŒ¨í‚¤ì§€ ì œì¶œ ë§ˆê° (í•´ë‹¹ íŒ¨í‚¤ì§€ë¡œ í‰ê°€)</p> <p>25.09 NIST PQC í‘œì¤€í™” ì»¨í¼ëŸ°ìŠ¤ ì˜ˆì •</p> <p>2026 3ë¼ìš´ë“œ í‰ê°€ë¥¼ ìœ„í•œ ê²°ì„  ì§„ì¶œì ì„ ì •</p> <h4 id="table-2-êµµì€-ê¸€ì”¨ê°€-2ë¼ìš´ë“œ-ì„ ì •-ì•Œê³ ë¦¬ì¦˜">[Table 2] êµµì€ ê¸€ì”¨ê°€ 2ë¼ìš´ë“œ ì„ ì • ì•Œê³ ë¦¬ì¦˜</h4> <table> <thead> <tr> <th>ê¸°ë°˜ë¬¸ì œ</th> <th>ì•Œê³ ë¦¬ì¦˜</th> <th>Â </th> </tr> </thead> <tbody> <tr> <td>Code-Based</td> <td><strong>CROSS</strong></td> <td><strong>LESS</strong></td> </tr> <tr> <td>Â </td> <td>Enhanced pqsigRM</td> <td>MEDS</td> </tr> <tr> <td>Â </td> <td>FuLeeca</td> <td>WAVE</td> </tr> <tr> <td>Lattice-Based</td> <td>EagleSign</td> <td><strong>HAWK</strong></td> </tr> <tr> <td>Â </td> <td>EHTv4</td> <td>HuFu</td> </tr> <tr> <td>Â </td> <td>HAETAE</td> <td>Raccoon</td> </tr> <tr> <td>Â </td> <td>Â </td> <td>SQUIRRELS</td> </tr> <tr> <td>MPC-in-the-Head</td> <td>Biscuit</td> <td><strong>PERK</strong></td> </tr> <tr> <td>Â </td> <td><strong>Mirath</strong>(MIRA + MiRitH)</td> <td><strong>RYDE</strong></td> </tr> <tr> <td>Â </td> <td><strong>MQOM</strong></td> <td><strong>SDitH</strong></td> </tr> <tr> <td>Multivariate</td> <td>3WISE</td> <td><strong>QR-UOV</strong></td> </tr> <tr> <td>Â </td> <td>DME-Sign</td> <td><strong>SNOVA</strong></td> </tr> <tr> <td>Â </td> <td>HPPC</td> <td>TUOV</td> </tr> <tr> <td>Â </td> <td><strong>MAYO</strong></td> <td><strong>UOV</strong></td> </tr> <tr> <td>Â </td> <td>PROV</td> <td>VOX</td> </tr> <tr> <td>Other</td> <td>ALTEQ</td> <td>PREON</td> </tr> <tr> <td>Â </td> <td>eMLE-Sig 2.0</td> <td>Xifrat1-Sign.I</td> </tr> <tr> <td>Â </td> <td>KAZ-SIGN</td> <td>Â </td> </tr> <tr> <td>Symmetric-Based</td> <td>AIMer</td> <td><strong>FAEST</strong></td> </tr> <tr> <td>Â </td> <td>Ascon-Sign</td> <td>SPHINCS-alpha</td> </tr> <tr> <td>Isogeny-Based</td> <td><strong>SQIsign</strong></td> <td>Â </td> </tr> </tbody> </table> <p><em>ì œì¶œ ë¬¸ì„œ ê¸°ì¤€ìœ¼ë¡œ í‰ê°€í•¨</em></p> <h4 id="ì„ ì •ê¸°ì¤€"><strong>ì„ ì •ê¸°ì¤€</strong></h4> <p><strong>ì„ ì •ê¸°ì¤€1. ì•ˆì „ì„±</strong></p> <p>EUF-CMA ì•ˆì „ì„±, ë³´ì•ˆ ê°•ë„ 1,2ì™€ ê°€ëŠ¥í•œ 3 ì¶©ì¡± ë° 4,5 ì¤‘ í•˜ë‚˜ ì´ìƒ ë§Œì¡±, ë¶€ì±„ë„ ê³µê²©ê³¼ ì˜¤ë¥˜ì£¼ì… ê³µê²©ë“±ì— ëŒ€í•œ ì €í•­ì„±, í”„ë¡œí† ì½œ í˜¸í™˜ì„±</p> <p><strong>ì„ ì •ê¸°ì¤€2. ì„±ëŠ¥ ë° ë¹„ìš©</strong></p> <ul> <li>ê³µê°œ í‚¤ì™€ ì„œëª…ì˜ í¬ê¸°</li> <li>ì„œëª… ë° ê²€ì¦ ì—°ì‚°ì˜ ê³„ì‚° íš¨ìœ¨ì„±, í‚¤ ìƒì„±ì˜ ê³„ì‚° íš¨ìœ¨ì„± (= ì†ë„)</li> <li>ë©”ëª¨ë¦¬: SW êµ¬í˜„ì„ ìœ„í•œ RAM ì‚¬ìš©ëŸ‰ê³¼ HW êµ¬í˜„ì„ ìœ„í•œ ê²Œì´íŠ¸ ìˆ˜</li> </ul> <p><strong>ì„ ì •ê¸°ì¤€3. í™œìš© ìœ ì—°ì„±</strong></p> <p>í”Œë«í¼ í˜¸í™˜ì„±, ë³‘ë ¬ì²˜ë¦¬ ê°€ëŠ¥ì„±</p> <p><strong>ì„ ì •ê¸°ì¤€4. ì§€ì  ì¬ì‚°ê¶Œ</strong></p> <h4 id="2ë¼ìš´ë“œ-ì•Œê³ ë¦¬ì¦˜-ì„ ì •-ì´ìœ "><strong>[2ë¼ìš´ë“œ ì•Œê³ ë¦¬ì¦˜ ì„ ì • ì´ìœ ]</strong></h4> <table> <tbody> <tr> <td>CROSS</td> <td>SLH-DSAë³´ë‹¤ ë‚˜ì€ ì„±ëŠ¥ì„ ë³´ì´ëŠ” ë¹„ê²©ì ê¸°ë°˜ ë°©ì‹ ì•ˆì „ì„±ì— ì§‘ì¤‘í•œ ë²„ì „ê³¼ ì„±ëŠ¥ì— ì§‘ì¤‘í•œ ë²„ì „ìœ¼ë¡œ ë‚˜ë‰¨. ëª¨ë“  ë§¤ê°œë³€ìˆ˜ ì§‘í•©ì—ì„œ ê³µê°œ í‚¤ê°€ ì‘ê³ , SLH-DSAì™€ ë¹„ìŠ·í•œ ê²€ì¦ ì†ë„ë¥¼ ë³´ì„. í‚¤ ìƒì„±ì€ ML-DSAì™€ ìœ ì‚¬í•œ ì •ë„ë¡œ ë§¤ìš° ë¹ ë¥´ê³ , ì„œëª… ì‹œê°„ë„ SLH-DSAë³´ë‹¤ ë‚˜ìŒ</td> </tr> <tr> <td>LESS</td> <td>LESS signatures are smaller than SLH-DSA with much larger public keys. ìµœê·¼ ë™ì¼í•œ ê³µê°œ í‚¤ í¬ê¸°ì—ì„œ ë” ì‘ì€ ì„œëª…ì„ ìƒì„±í•˜ëŠ” ë°©ë²•ì´ ì œì•ˆë˜ì–´ ê°œì„ ì˜ ì—¬ì§€ê°€ ìˆìŒ. ì•ˆì „ì„± ì¶”ê°€ ê²€ì¦ í•„ìš”</td> </tr> <tr> <td>HAWK</td> <td>Falconê³¼ ë¬¸ì œ êµ¬ì„± ë° ì„±ëŠ¥ì´ ìœ ì‚¬í•˜ì§€ë§Œ, í‚¤ ë° ì„œëª… í¬ê¸° ì¸¡ë©´ì—ì„œ ë” ìš°ìˆ˜í•˜ë©°, ë¶€ë™ì†Œìˆ˜ì  ì—°ì‚° ì—†ì´ êµ¬í˜„ ê°€ëŠ¥í•¨. ë‹¨, Falconë³´ë‹¤ ì•ˆì „ì„± ì—°êµ¬ê°€ ëœ ì´ë¤„ì§</td> </tr> <tr> <td>Mirath</td> <td>1ë¼ìš´ë“œì˜ ë‘ ì•Œê³ ë¦¬ì¦˜ì€ SLH-DSAì™€ Falcon ì‚¬ì´ì˜ í‚¤ í¬ê¸°ë¥¼ ê°–ëŠ” ë§¤ê°œë³€ìˆ˜ ì„¸íŠ¸ë¥¼ ì œê³µí•˜ë©°, ì„œëª… í¬ê¸°ëŠ” SLH-DSAì™€ ìœ ì‚¬í•¨. í‚¤ ìƒì„± ì„±ëŠ¥ì€ ML-DSAì™€ ìœ ì‚¬í•˜ë©°, ì„œëª… ë° ê²€ì¦ ì„±ëŠ¥ì€ ML-DSAì™€ Falcon ì‚¬ì´ì— ìœ„ì¹˜í•¨. ë‘ ì•Œê³ ë¦¬ì¦˜ í†µí•©ìœ¼ë¡œì¨ ì„œëª… í¬ê¸°ê°€ ê°œì„ ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒë˜ë©°, ê¸°ë³¸ì ì¸ ì•ˆì „ì„± ê°€ì •ì€ ë³€í•˜ì§€ ì•Šì„ ê²ƒìœ¼ë¡œ ë³´ì„</td> </tr> <tr> <td>MQOM</td> <td>ë§¤ìš° ì‘ì€ ê³µê°œ í‚¤. ì„œëª… í¬ê¸°ëŠ” ML-DSAì™€ SLH-DSA ì‚¬ì´ì˜ ì¤‘ê°„ í¬ê¸°. ì„±ëŠ¥ íŠ¸ë ˆì´ë“œì˜¤í”„ì™€ ì„œëª… í¬ê¸°ê°€ ê°œì„ ë  ê²ƒìœ¼ë¡œ ê¸°ëŒ€ë¨</td> </tr> <tr> <td>PERK</td> <td>ML-DSAë³´ë‹¤ ëŠë¦¬ê³  SLH-DSAì™€ ë¹„ìŠ·í•œ ì†ë„ì¼ ê²ƒìœ¼ë¡œ ì˜ˆìƒ. PERK ì„œëª…ì˜ í¬ê¸°ëŠ” ML-DSAë³´ë‹¤ í¬ì§€ë§Œ SLH-DSAë³´ë‹¤ëŠ” ìƒë‹¹íˆ ì‘ì„ ê²ƒìœ¼ë¡œ ì˜ˆìƒ. ì•ˆì „ì„± ë³´ì™„ ì—°êµ¬ í•„ìš”</td> </tr> <tr> <td>RYDE</td> <td>MPCitH ë° VOLEitH ì„œëª… ë°©ì‹ ë²”ì£¼ì—ì„œ ê²½ìŸë ¥ ìˆëŠ” ì„±ëŠ¥ì„ ë³´ì—¬ì£¼ì—ˆìœ¼ë©°, íŠ¹íˆ ìµœê·¼ ê°œì„  ì‚¬í•­ì„ ê³ ë ¤í•˜ì—¬ ì„ ì •</td> </tr> <tr> <td>SDitH</td> <td>ì „ì²´ì ì¸ ì„±ëŠ¥ì€ SLH-DSAë³´ë‹¤ ìš°ìˆ˜í•˜ì§€ë§Œ, ML-DSAë‚˜ Falconë³´ë‹¤ëŠ” ë–¨ì–´ì§. ë§¤ìš° ì‘ì€ í‚¤. SLH-DSAì˜ ì‘ê³  ë¹ ë¥¸ ë§¤ê°œë³€ìˆ˜ ì§‘í•© ì‚¬ì´ì— ìœ„ì¹˜í•˜ëŠ” ì„œëª… í¬ê¸°. ì¶”ê°€ì ì¸ ì•ˆì „ì„± ë¶„ì„ ë° ì„±ëŠ¥ ê°œì„ ì„ ê¸°ëŒ€í•¨</td> </tr> <tr> <td>UOV</td> <td>ì§§ì€ ì„œëª…ê³¼ ë§¤ìš° ë¹ ë¥¸ ì„œëª… ë° ê²€ì¦ ì†ë„. ì˜¤ëœ ê¸°ê°„ ìˆ˜í–‰ëœ ì•ˆì „ì„± ê²€ì¦. ë‹¨, ë‹¨ì ì€ ê³µê°œ í‚¤ì˜ í¬ê¸°. ì œì¶œ íŒ¨í‚¤ì§€ëŠ” ê³µê°œ í‚¤ í¬ê¸°ì™€ ê²€ì¦ ì†ë„ ê°„ì˜ ì ˆì¶©ì•ˆì„ ì œê³µí•˜ì§€ë§Œ, ì‘ì€ ê³µê°œ í‚¤ì¡°ì°¨ë„ ìƒë‹¹íˆ í¼. ì‘ì€ ì„œëª…, ë¹ ë¥¸ ê²€ì¦, ê·¸ë¦¬ê³  í‚¤ì˜ ì˜¤í”„ë¼ì¸ ì „ì†¡ì´ í•„ìš”í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ì— ì ìš©ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒ. ë¹„íŒì  ì•ˆì „ì„± ë¶„ì„ ì¶”ê°€ ì—°êµ¬ í•„ìš”</td> </tr> <tr> <td>MAYO</td> <td>UOVì— ë¹„í•´ ê³µê°œ í‚¤ í¬ê¸°ë¥¼ í¬ê²Œ ì¤„ì´ë©´ì„œ UOVì˜ ì‘ì€ ì„œëª… í¬ê¸°ë¥¼ ìœ ì§€. UOVë§Œí¼ ë¹ ë¥´ì§€ëŠ” ì•Šì§€ë§Œ, ê·¸ë˜ë„ ë§¤ìš° íš¨ìœ¨ì </td> </tr> <tr> <td>QR-UOV</td> <td>ê³µê°œ í‚¤ê°€ UOVì— ë¹„í•´ 50% ë” ì‘ìŒ. QR-UOVì˜ ì„±ëŠ¥ì€ UOVë³´ë‹¤ ëŠë¦¬ì§€ë§Œ ì—¬ì „íˆ ê²½ìŸë ¥ ìˆìŒ. ë‹¨, êµ¬ì¡° ë° ì•ˆì „ì„±ì— ëŒ€í•œ ì—°êµ¬ í•„ìš”</td> </tr> <tr> <td>SNOVA</td> <td>UOVì— ë¹„í•´ í›¨ì”¬ ì‘ì€ ê³µê°œ í‚¤(MAYOì™€ ë¹„ìŠ·í•˜ê±°ë‚˜ ì•½ê°„ ì‘ìŒ), ì œì¶œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì•”í˜¸ ë¶„ì„ì— ëŒ€í•´ ê°€ì¥ ì‘ì€ ê³µê°œ í‚¤ì„. ìƒëŒ€ì ìœ¼ë¡œ ë¹ ë¥¸ ì„±ëŠ¥ ìœ ì§€. MAYOë³´ë‹¤ ì•½ê°„ ëŠë¦¬ì§€ë§Œ ë¹„ìŠ·í•œ ë²”ìœ„ì˜ ì†ë„. ì•ˆì „ì„±ì€ ì•½ê°„ ì˜ë¬¸</td> </tr> <tr> <td>FAEST</td> <td>ìœ ì‚¬í•œ MPCitH ë°©ì‹ì— ë¹„í•´ ì„œëª… í¬ê¸°ê°€ ìƒë‹¹íˆ ì‘ìŒ. ì´ë¡ ì  ì•ˆì „ì„±ì€ ëŒ€ì¹­ í‚¤ ê°€ì •ì—ë§Œ ê¸°ë°˜í•˜ê³  ìˆì§€ë§Œ, í•´ë‹¹ ì†ì„±ì„ ê°€ì§„ ëŒ€ë¶€ë¶„ì˜ ë‹¤ë¥¸ ë°©ì‹, íŠ¹íˆ SLH-DSAë³´ë‹¤ ì„±ëŠ¥ì´ í›¨ì”¬ ë›°ì–´ë‚¨. ë‹¨, ì„±ëŠ¥ì€ ML-DSAì™€ FN-DSA ê°™ì€ ê²©ì ê¸°ë°˜ ë°©ì‹ê³¼ëŠ” ê²½ìŸë ¥ì´ ì—†ìŒ</td> </tr> <tr> <td>SQIsign</td> <td>ì•Œë ¤ì§„ ê³µê²©ë“¤ì— ì €í•­ì„±ì„ ê°€ì§. 1ì°¨ ë¼ìš´ë“œ í›„ë³´ë“¤ ë° ML-DSAì™€ Falconì„ í¬í•¨í•œ ëª¨ë“  ë°©ì‹ ì¤‘ì—ì„œ ê°€ì¥ ì‘ì€ ê³µê°œ í‚¤ì™€ ì„œëª… í¬ê¸°. ì„œëª… ë° ê²€ì¦ì˜ ê³„ì‚° íš¨ìœ¨ì„± ì¸¡ë©´ì—ì„œ, ë§¤ìš° ëŠë¦¬ì§€ë§Œ, ê²€ì¦ì€ ì„œëª…ë³´ë‹¤ í›¨ì”¬ ë¹ ë¦„</td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Study"/><category term="Cryptography"/><category term="PQC"/><summary type="html"><![CDATA[Study note: AIS 31 (version 3.0)]]></summary></entry><entry><title type="html">Information Theory</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2024/information-theory/" rel="alternate" type="text/html" title="Information Theory"/><published>2024-01-02T00:00:00+00:00</published><updated>2024-01-02T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2024/information-theory</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2024/information-theory/"><![CDATA[<p>ğŸ“– Cover, Thomas M.Â <em>Elements of information theory</em>. John Wiley &amp; Sons, 1999.</p> <iframe src="/june.github.io/assets/pdf/info_theory.pdf" width="100%" height="800px" style="border: none;"> PDF ë¯¸ë¦¬ë³´ê¸°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. <a href="/june.github.io/assets/pdf/info_theory.pdf">ì—¬ê¸°</a>ë¥¼ í´ë¦­í•´ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”. </iframe>]]></content><author><name></name></author><category term="Study"/><category term="MATH"/><summary type="html"><![CDATA[Information theory: Probability and Entropy]]></summary></entry><entry><title type="html">(Windows) OpenSSL</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2023/windows-openssl/" rel="alternate" type="text/html" title="(Windows) OpenSSL"/><published>2023-08-02T00:00:00+00:00</published><updated>2023-08-02T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2023/windows-openssl</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2023/windows-openssl/"><![CDATA[<h3 id="1-vs">1. VS</h3> <h4 id="1-vs-í”„ë¡œì íŠ¸-ê²½ë¡œ-ì„¤ì •">1. VS í”„ë¡œì íŠ¸ ê²½ë¡œ ì„¤ì •</h4> <p><strong>í”„ë¡œì íŠ¸ â†’ ì†ì„± â†’ VC++ ë””ë ‰í„°ë¦¬</strong></p> <ul> <li> <p>í¬í•¨ ë””ë ‰í„°ë¦¬ :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $(VC_IncludePath);$(WindowsSDK_IncludePath);C:\Program Files\OpenSSL-Win64\include;$(includePath)
</code></pre></div> </div> </li> <li> <p>ë¼ì´ë¸ŒëŸ¬ë¦¬ ë””ë ‰í„°ë¦¬ :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);C:\Program Files\OpenSSL-Win64\lib\VC;$(LibraryPath)
</code></pre></div> </div> </li> </ul> <p><strong>í”„ë¡œì íŠ¸ â†’ ì†ì„± â†’ ë§ì»¤ â†’ ì…ë ¥</strong></p> <ul> <li> <p>ì¶”ê°€ì¢…ì†ì„± :</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $(CoreLibraryDependencies);%(AdditionalDependencies);libcrypto64MD.lib;libcrypto64MT.lib;libssl64MT.lib;libssl64MD.lib;
</code></pre></div> </div> </li> </ul> <h4 id="2-make-íŒŒì¼-vs-code">2. MAKE íŒŒì¼ (VS code)</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CC		= gcc
LDFLAGS =-lcrypto
LDFLAGS +="-L/usr/local/opt/openssl@3/lib"
CPPFLAGS ="-I/usr/local/opt/openssl@3/include"

SOURCES= file_name.c
HEADERS= file_name.h

PQCgenKAT_pke: $(HEADERS) $(SOURCES)
    $(CC) -o $@ $(SOURCES) $(LDFLAGS) $(CPPFLAGS)

clean:
    @rm -rf *.o program_name
</code></pre></div></div> <p><em><del>ì´ê²Œ ì•ˆ ë  ìˆ˜ ìˆìœ¼ë‹ˆê¹Œ ìƒí™©ì— ë§ì¶°ì„œ ê²€ìƒ‰í•´ë³´ìâ€¦.</del></em></p> <h3 id="2-vs-code">2. VS code</h3> <h4 id="0-ì„¤ì¹˜ë¥¼-ìœ„í•œ-ì‚¬ì „-í™˜ê²½-ì„¤ì •">0. ì„¤ì¹˜ë¥¼ ìœ„í•œ ì‚¬ì „ í™˜ê²½ ì„¤ì •</h4> <p>1) Perl ì„¤ì¹˜ (ì˜¤ë˜ ê±¸ë¦¼)</p> <p>ê°„ë‹¨í•œ ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±ì— ì í•©í•œ ìœ ë‹‰ìŠ¤ ê³„ì—´ ìš´ì˜ì²´ì œìš© í”„ë¡œê·¸ë˜ë° ì–¸ì–´</p> <p><a href="https://strawberryperl.com/">https://strawberryperl.com/</a></p> <p>2) visual studio <em>(ìµœì‹  ë²„ì „)</em> ì„¤ì¹˜</p> <p>ìŠ¤íŠœë””ì˜¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ, VSì—ì„œ ì œê³µí•˜ëŠ” lib íŒŒì¼ê³¼ promptë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ëª©ì ì„</p> <p><a href="https://visualstudio.microsoft.com/ko/downloads/">https://visualstudio.microsoft.com/ko/downloads/</a></p> <h4 id="1-openssl-targz-íŒŒì¼-ë‹¤ìš´ë¡œë“œ">1. OpenSSL tar.gz íŒŒì¼ ë‹¤ìš´ë¡œë“œ</h4> <p>ì•„ë˜ ë§í¬ë¡œ ë“¤ì–´ê°€ì„œ PC ë²„ì „ì— ë§ëŠ” opensslì„ ë‹¤ìš´ë°›ê³  ì„¤ì¹˜í•œë‹¤. windowsì˜ ê²½ìš° ì—­ì‹œ exe íŒŒì¼ë¡œ ì„¤ì¹˜í•˜ëŠ” ê²Œ í¸í•˜ë‹¤.</p> <p><a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a></p> <p><a href="http://slproweb.com/products/Win32OpenSSL.html">http://slproweb.com/products/Win32OpenSSL.html</a></p> <p><img src="/june.github.io/assets/img/post/windows_openssl/image.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>ìµœì‹  ë²„ì „ìœ¼ë¡œ ë‹¤ìš´ë¡œë“œí•˜ì—¬ ì••ì¶• í’€ê³  Cë“œë¼ì´ë¸Œë¡œ ì´ë™</p> <h4 id="2-visual-studio-prompt-ê´€ë¦¬ì-ê¶Œí•œìœ¼ë¡œ-ì‹¤í–‰">2. Visual studio prompt ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰</h4> <p><img src="/june.github.io/assets/img/post/windows_openssl/Untitled.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <h4 id="3-perlë¡œ-openssl-build-copenssl-311">3. perlë¡œ openssl build <em>(C:\openssl-3.1.1)</em></h4> <p>1) configure</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\openssl-3.1.1&gt;perl Configure VC-WIN64I --openssldir=C:\OpenSSL-x64-debug no-shared no-asm threads
</code></pre></div></div> <p>2) make <em>(ì´í›„ â€˜nmake testâ€™ë¡œ test ê°€ëŠ¥)</em></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmake
</code></pre></div></div> <p>3) install</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nmake install
</code></pre></div></div> <h4 id="4-í™˜ê²½-ë³€ìˆ˜-ì¶”ê°€">4. í™˜ê²½ ë³€ìˆ˜ ì¶”ê°€</h4> <p>(ì‚¬ì§„ê³¼ ì…ë ¥í•´ì•¼ í•˜ëŠ” ìœ„ì¹˜ ë‹¤ë¥´ë¯€ë¡œ ìœ„ì¹˜ëŠ” ì½”ë“œ ë¸”ë¡ ì°¸ì¡°)</p> <p>(1) windows ê²€ìƒ‰ì°½ì—</p> <p>â€˜ê³ ê¸‰ ì‹œìŠ¤í…œ ì„¤ì • ë³´ê¸°â€™ ê²€ìƒ‰</p> <p><img src="/june.github.io/assets/img/post/windows_openssl/Untitled_1.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>(2) ê³ ê¸‰ â†’ í™˜ê²½ë³€ìˆ˜</p> <p><img src="/june.github.io/assets/img/post/windows_openssl/Untitled_2.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>(3) ì‚¬ìš©ì ë³€ìˆ˜ â†’ Path â†’ í¸ì§‘</p> <p><img src="/june.github.io/assets/img/post/windows_openssl/Untitled_3.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>(4) ìƒˆë¡œ ë§Œë“¤ê¸° â†’ OpenSSL\bin ìœ„ì¹˜ ì¶”ê°€</p> <p><img src="/june.github.io/assets/img/post/windows_openssl/Untitled_4.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Program Files\OpenSSL\bin
</code></pre></div></div> <p>(5) ì‹œìŠ¤í…œ ë³€ìˆ˜ â†’ Path â†’ í¸ì§‘</p> <p><img src="/june.github.io/assets/img/post/windows_openssl/Untitled_5.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>(6) ìƒˆë¡œ ë§Œë“¤ê¸° â†’ bin, include, lib ìœ„ì¹˜ ì¶”ê°€</p> <p><img src="/june.github.io/assets/img/post/windows_openssl/Untitled_6.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Program Files\OpenSSL\bin
C:\Program Files\OpenSSL\lib
C:\Program Files\OpenSSL\include
</code></pre></div></div> <h4 id="5-makefileì—-flag-ì¶”ê°€">5. makefileì— flag ì¶”ê°€</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CC=gcc
CFLAGS += -Wall -Wextra -O3 -I"C:/Program Files/OpenSSL/include"
LDFLAGS = -L"C:/Program Files/OpenSSL/lib"
LDFLAGS+= -L"C:/Program Files/OpenSSL-Win64/bin" -lcrypto-3-x64
</code></pre></div></div>]]></content><author><name></name></author><category term="Tool"/><category term="Windows"/><category term="Tool"/><summary type="html"><![CDATA[Windowsì—ì„œ OpenSSL í™˜ê²½ êµ¬ì¶•]]></summary></entry><entry><title type="html">(Windows) VS code LaTeX</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2023/windows-vs-code-latex/" rel="alternate" type="text/html" title="(Windows) VS code LaTeX"/><published>2023-01-30T00:00:00+00:00</published><updated>2023-01-30T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2023/windows-vs-code-latex</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2023/windows-vs-code-latex/"><![CDATA[<p>Overleafê°™ì€ ì˜¨ë¼ì¸ íˆ´ì„ ì´ìš©í•˜ë©´ LaTeX ë¬¸ì„œë¥¼ ì‰½ê²Œ í¸ì§‘í•  ìˆ˜ ìˆì§€ë§Œ, ê°€ë…ì„±ì´ ì •ë§ì´ì§€ ë‹µë„ ì—†ì–´ì„œ VS codeë¥¼ ì‚¬ìš©í•˜ê¸°ë¡œ ê²°ì •í–ˆë‹¤. LaTeX ì˜¤í”„ë¼ì¸ í”„ë¡œê·¸ë¨ë“¤ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•´ë„ ë˜ì§€ë§Œ ìµìˆ™í•œ í…Œë§ˆì— ìµìˆ™í•œ íˆ´ë¡œ ì‘ì—…í•˜ë ¤ëŠ” ìš•ì‹¬ì´ í¬ê²Œ ì‘ìš©í–ˆë‹¤.</p> <p>ì¸í„°ë„·ì—ì„œ ì„œì¹˜í•œ ë‚´ìš©ë“¤ì„ ë”°ë¼ í–ˆëŠ”ë° ì›í•˜ëŠ” ëŒ€ë¡œ êµ´ëŸ¬ê°€ê¸°ê¹Œì§€ ì˜ˆìƒë³´ë‹¤ ì‹œê°„ì´ ê±¸ë ¸ë‹¤. ë‚˜ì¤‘ì— ë˜ í™˜ê²½ì„ êµ¬ì¶•í•˜ë ¤ë©´ ê·¸ ìì²´ë¡œ ì¼ì´ì§€ ì‹¶ë‹¤.</p> <hr/> <h4 id="1-visual-studio-code-vscode-ì„¤ì¹˜">1. Visual Studio Code (VScode) ì„¤ì¹˜</h4> <p>ìš°ì„  ì•„ë˜ ë§í¬ì—ì„œ VS codeë¥¼ ì„¤ì¹˜í•œë‹¤.</p> <p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p> <h4 id="2-vscode-í™•ì¥-ì–´í”Œë¦¬ì¼€ì´ì…˜-ì„¤ì¹˜">2. VScode í™•ì¥ ì–´í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì¹˜</h4> <p><img src="/june.github.io/assets/img/post/windows_vs_code_latex/image.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p><img src="/june.github.io/assets/img/post/windows_vs_code_latex/image_1.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>LaTeX Workshopê³¼ Code Spell Checkerë¥¼ ì„¤ì¹˜í•œë‹¤. LaTeX Workshopì€ VS codeì—ì„œ TeXë¥¼ í¸ë¦¬í•˜ê²Œ ì‚¬ìš©í•˜ë„ë¡ ë•ëŠ”ë‹¤. Code Spell CheckerëŠ” í”„ë¡œê·¸ë¨ ì´ë¦„ì—ì„œ ì•Œ ìˆ˜ ìˆë“¯ ì½”ë“œ ì˜¤ë¥˜ë¥¼ í™•ì¸í•´ì£¼ëŠ” í”„ë¡œê·¸ë¨ìœ¼ë¡œ í™˜ê²½ êµ¬ì¶•ì— í•„ìˆ˜ëŠ” ì•„ë‹ˆë‹¤.Â Â  ì‚¬ì‹¤ ì—¬ê¸°ê¹Œì§€ í•˜ë©´ tex ë¬¸ì„œë¥¼ ì—´ì–´ì„œ ë¹Œë“œ í•  ë•Œ ë‚˜ì˜¤ëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€ë‚˜ ë¡œê·¸ë§Œ ë´ë„ ì–´ì°Œì–´ì°Œ í™˜ê²½ êµ¬ì¶•ì„ ë§ˆë¬´ë¦¬í•  ìˆ˜ ìˆë‹¤.</p> <h4 id="3-tex-live-ì„¤ì¹˜">3. TeX Live ì„¤ì¹˜</h4> <p>LaTeX ì»´íŒŒì¼ í”„ë¡œê·¸ë¨ì´ë‹¤. ì•„ë˜ ë§í¬ë¡œ ë“¤ì–´ê°€ë©´ ë³¸ë¬¸ ì²« ë¬¸ë‹¨ ì²« ì¤„ì— install-tl-windows.exeë¼ëŠ” í•˜ì´í¼ë§í¬ê°€ ìˆë‹¤.</p> <p><a href="https://tug.org/texlive/acquire-netinstall.html">https://tug.org/texlive/acquire-netinstall.html</a></p> <p>ë‹¤ìš´ë°›ê³  ì„¤ì¹˜í•˜ë©´ ëœë‹¤. ê°€ê¸‰ì  full packageë¡œ ë°›ì•„ì•¼ ë‚˜ì¤‘ì— ë¹ ì§„ íŒ¨í‚¤ì§€ ì±„ì›Œ ë„£ëŠ”ë‹¤ê³  ì‹ ê²½ ì“°ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤. ë‹¤ë§Œ ì„¤ì¹˜ ì‹œê°„ì´ ì •ë§ ì˜¤ë˜ ê±¸ë¦¬ë‹ˆ install ë²„íŠ¼ì„ ëˆ„ë¥¸ ë’¤ ëŠê¸‹í•˜ê²Œ ë°¥ ë¨¹ê³  ì»¤í”¼ ë§ˆì‹œê³  ëŒì•„ì˜¤ê²Œ ì‹ì‚¬ ì‹œê°„ ì§ì „ì— ì„¤ì¹˜í•˜ê¸¸ ê¶Œí•œë‹¤.</p> <h4 id="4-perl-ì„¤ì¹˜">4. Perl ì„¤ì¹˜</h4> <p>í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ì¤‘ í•˜ë‚˜ë¡œ ì„¤ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ ë‹¤ ê¹”ì•„ë„ ë¹Œë“œê°€ ì•ˆ ëœë‹¤. ì´ê±¸ ì„¤ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì•„ë˜ ì„¤ì¹˜í•  MiKTeX í”„ë¡œê·¸ë¨ì´ ìˆìœ¼ë‚˜ ë§ˆë‚˜ì—¬ì„œ ë¨¼ì € ì„¤ì¹˜í•˜ëŠ” í¸ì´ ì •ì‹  ê±´ê°•ì— ì¢‹ë‹¤.</p> <p><a href="https://strawberryperl.com/">https://strawberryperl.com/</a></p> <p>ìœ„ ë§í¬ë¡œ ë“¤ì–´ê°€ì„œ ì»´í“¨í„° ì‚¬ì–‘ì— ë§ì¶° msi íŒŒì¼ì„ ë‹¤ìš´ë°›ê³  ì„¤ì¹˜í•˜ë©´ ëœë‹¤. CMD ì°½ì—ì„œ â€œPerl -vâ€ë¥¼ ì…ë ¥í•˜ì—¬ ë²„ì „ ì •ë³´ê°€ ì¶œë ¥ë˜ë©´ ì •ìƒì ìœ¼ë¡œ ì„¤ì¹˜ëœ ê²ƒì´ë‹¤.</p> <h4 id="5-miktex-ì„¤ì¹˜">5. MiKTeX ì„¤ì¹˜</h4> <p>LaTeX ì‘ì—… íë¦„ ë™ê¸°í™” (Perl script) í”„ë¡œê·¸ë¨ latexmkì˜ ìœˆë„ìš° ë²„ì „ì´ë‹¤. ì´ í”„ë¡œê·¸ë¨ì€ ì„¤ì¹˜ë§Œ í•˜ë©´ ëì´ì—ˆë˜ ì´ì „ í”„ë¡œê·¸ë¨ë“¤ê³¼ ë‹¬ë¦¬ ì¶”ê°€ ì‘ì—…ì´ ì¡°ê¸ˆ í•„ìš”í•˜ë‹¤.</p> <p><a href="https://miktex.org/download">https://miktex.org/download</a></p> <p>í”„ë¡œê·¸ë¨ ì„¤ì¹˜ê°€ ëë‚˜ë©´ MiKTeX Consoleì„ ì—´ì–´ì„œ ë‹¤ìŒì„ ì§„í–‰í•œë‹¤.</p> <ol> <li>Updates - Update now</li> <li>Packages - latexmk ê²€ìƒ‰ - ê²°ê³¼ ì„ íƒ í›„ + ë²„íŠ¼ì„ ëˆŒëŸ¬ install</li> </ol> <p><img src="https://www.notion.so/icons/attachment_gray.svg" alt="https://www.notion.so/icons/attachment_gray.svg" width="20px"/> â€˜MiKTeX Console is already runningâ€™ì´ë¼ëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€ë§Œ ëœ¨ê³  í”„ë¡œê·¸ë¨ ì‹¤í–‰ì´ ì•ˆ ë  ìˆ˜ ìˆë‹¤. ë‚´ ê²½ìš° ì´ë•Œ í”„ë¡œê·¸ë¨ ì„¤ì¹˜ ê²½ë¡œë¡œ ë“¤ì–´ê°€ë‹¤ ë³´ë©´ ì°¾ì„ ìˆ˜ ìˆëŠ” lock íŒŒì¼ì„ ì‚­ì œí•˜ë‹ˆ ì—´ë ¸ë‹¤.</p> <p>í”„ë¡œê·¸ë¨ ì„¤ì¹˜ ê²½ë¡œëŠ”Â C:\Users\user\AppData\LocalÂ ì¸ë°, lock íŒŒì¼ì€Â C:\Users\userÂ ì— ìˆì—ˆë‹¤.</p> <p>+) ì—°êµ¬ì‹¤ í”¼ë“œë°±</p> <p>ì˜† ì‚¬ì§„ì²˜ëŸ¼ ì‘ì—…í‘œì‹œì¤„ì˜ í™œì„±í™” í”„ë¡œê·¸ë¨ ëª©ë¡ì— MiKTeXì´ ìˆìœ¼ë©´ ë”ë¸”í´ë¦­í•´ì„œ ì—´ ìˆ˜ ìˆë‹¤.</p> <p><img src="/june.github.io/assets/img/post/windows_vs_code_latex/Untitled.png" style="max-width: 30%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <p>latexmk ì„¤ì¹˜ê°€ ì™„ë£Œë˜ë©´ ìœˆë„ìš° ê²€ìƒ‰ ê¸°ëŠ¥ì— ê³ ê¸‰ ì‹œìŠ¤í…œ ì†ì„±ì„ ê²€ìƒ‰í•˜ì—¬ ì‹œìŠ¤í…œ ì†ì„± ì°½ì„ ì—´ì–´ ë‹¤ìŒì„ ì§„í–‰í•œë‹¤.</p> <ol> <li>í™˜ê²½ ë³€ìˆ˜ - ì‹œìŠ¤í…œ ë³€ìˆ˜ - Path - í¸ì§‘ - ì°¾ì•„ë³´ê¸° - MiKTeX ì„¤ì¹˜ ê²½ë¡œ ì¶”ê°€</li> </ol> <h4 id="6-vs-code-ì‹¤í–‰">6. VS code ì‹¤í–‰</h4> <p>latexmk í”„ë¡œê·¸ë¨ì„ ì—¬ëŸ¬ ê°œ ì„¤ì¹˜í•˜ê³  í™˜ê²½ ë³€ìˆ˜ ë³€ê²½ë„ í–ˆìœ¼ë‹ˆ ì¬ë¶€íŒ…ì„ í•˜ê³  tex ë¬¸ì„œë¥¼ í¸ì§‘í•˜ê¸¸ ê¶Œì¥í•œë‹¤. ì—¬íŠ¼, 4ë²ˆê¹Œì§€ ì˜ ì§„í–‰í–ˆìœ¼ë©´ VS codeë¡œ í¸ì§‘í•  tex ë¬¸ì„œë¥¼ ì—´ê³  ë¬¸ì„œ ì‘ì—… í›„ ì €ì¥í•œë‹¤. ì €ì¥(Ctrl + S)ë§Œ í•´ë„ 2ì—ì„œ ì„¤ì¹˜í•œ LaTeX Workshopì´ ìë™ìœ¼ë¡œ pdf ë¬¸ì„œê¹Œì§€ ì»´íŒŒì¼í•´ ì¤€ë‹¤.</p> <p>ë¬¸ì„œ ê²½ë¡œì— í•œê¸€ì´ë‚˜ íŠ¹ìˆ˜ë¬¸ìê°€ ì„ì—¬ ìˆìœ¼ë©´ ë¹Œë“œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë‹ˆ ì£¼ì˜í•´ì•¼ í•œë‹¤. ë¹Œë“œ ê²°ê³¼ëŠ” ë¯¸ë¦¬ë³´ê¸° ì°½ì— ìë™ ë°˜ì˜ëœë‹¤.</p> <hr/> <p>ë§ˆì§€ë§‰ìœ¼ë¡œ ì„¤ì¹˜ë¥¼ ìœ„í•´ ì°¸ê³ í•œ ê¸€ì„ ì•„ë˜ ë‹¬ì•„ë‘”ë‹¤.</p> <ul> <li>í™˜ê²½ êµ¬ì¶• :Â <a href="https://shakeratos.tistory.com/92">https://shakeratos.tistory.com/92</a></li> <li>path ì„¤ì • :Â <a href="https://rootblog.tistory.com/206">https://rootblog.tistory.com/206</a></li> </ul>]]></content><author><name></name></author><category term="Tool"/><category term="Windows"/><category term="LaTeX"/><category term="VScode"/><summary type="html"><![CDATA[Windowsì—ì„œ VS codeë¡œ ì˜¤í”„ë¼ì¸ latex ë¬¸ì„œ ì‘ì—…ì„ ìœ„í•œ í™˜ê²½ êµ¬ì¶•í•˜ê¸°]]></summary></entry><entry><title type="html">(Windows) VS code</title><link href="https://ryuj1eun.github.io/june.github.io/blog/2023/windows-vs-code-copy/" rel="alternate" type="text/html" title="(Windows) VS code"/><published>2023-01-13T00:00:00+00:00</published><updated>2023-01-13T00:00:00+00:00</updated><id>https://ryuj1eun.github.io/june.github.io/blog/2023/windows-vs-code%20copy</id><content type="html" xml:base="https://ryuj1eun.github.io/june.github.io/blog/2023/windows-vs-code-copy/"><![CDATA[<p>ğŸ“š <strong>[MAIN]</strong> Alex Biryukov, Baptiste Lambin, and Aleksei Udovenko. â€Cryptanalysis of arx-based white-box implementations.â€ IACR Transactions on Cryptographic Hardware and Embedded Systems, 2023(3):97135, 2023.</p> <p>ğŸ“š <strong>[Sub 1]</strong> AdriÃ¡n Ranea, Joachim Vandersmissen, and Bart Preneel. â€Implicit white-box implementations: White-boxing arx ciphers.â€ In Annual International Cryptology Conference, pages 3363. Springer, 2022.</p> <p>ğŸ“š <strong>[Sub 2]</strong> AdriÃ¡n Ranea and Bart Preneel. â€On self-equivalence encodings in white-box implementations.â€ Cryptology ePrint Archive, Paper 2020/1325, 2020.</p> <hr/> <h1 id="intro">Intro.</h1> <h2 id="êµ¬í˜„-ë°©ì‹-ë¹„êµ-cejo-vs-self-equivalence"><strong>êµ¬í˜„ ë°©ì‹ ë¹„êµ (CEJO vs Self-equivalence)</strong></h2> <h3 id="cejo-wbc"><strong>CEJO WBC</strong></h3> <p>í…Œì´ë¸”ë¡œ ì €ì¥ (ì…ë ¥ $n$-bit, ì¶œë ¥ $n$-bit) : ê³µê°„ ë³µì¡ë„: $2^n \times n \;(\gg\sum_{i=0}^n \binom{n}{i}= 2^n)$</p> <p>â†’ ì¸ì½”ë”©ì„ í¬ê²Œ ì ìš©í•  ìˆ˜ ì—†ìŒ</p> <h3 id="self-equivalence-êµ¬í˜„"><strong>Self-equivalence êµ¬í˜„</strong></h3> <p>ë‹¤í•­ì‹ìœ¼ë¡œ ì €ì¥ : ê³µê°„ ë³µì¡ë„: $\sum \binom{n}{k}\cdot n$</p> <p>â†’ ì¸ì½”ë”©ì„ í¬ê²Œ ìƒì„±Â·ì ìš©í•  ìˆ˜ ìˆìŒ</p> <ul> <li>ì¸ì½”ë”© ì°¨ìˆ˜ê°€ ë†’ì•„ì§€ë©´ ì €ì¥ ê³µê°„ ë¬¸ì œê°€ ë°œìƒí•¨ <em>(ì°¸ê³ : í…Œì´ë¸” ë°©ì‹ë³´ë‹¨ íš¨ìœ¨ì )</em></li> <li>ì €ì°¨ ì¸ì½”ë”©ì€ ê°€ìš°ìŠ¤ ì†Œê±°ë²•ìœ¼ë¡œ ì‰½ê²Œ í’€ ìˆ˜ ìˆìŒ <ul> <li>ì‚¬ìš©ìì™€ ê³µê²©ì ëª¨ë‘ ê°€ìš°ìŠ¤ ì†Œê±°ë²•ì„ ì‚¬ìš©í•´ì•¼ í•¨</li> </ul> </li> <li>(ê°€ìš°ìŠ¤ ì†Œê±°ë²•ì„ ì ìš©í•˜ë ¤ë©´) ìƒëŒ€ì ìœ¼ë¡œ ê³µê²©í•˜ê¸° ì–´ë ¤ìš´ ë°©ì‹ìœ¼ë¡œ <strong>ìŒí•¨ìˆ˜ ê¸°ë°˜ êµ¬í˜„ ì œì•ˆ</strong></li> </ul> <h3 id="--implicit-wbc-êµ¬í˜„">â‡’ Implicit WBC êµ¬í˜„</h3> <p>CEJO ë˜ëŠ” SE(self-equivalence) êµ¬í˜„ ë°©ì‹ì— ì ìš©ë˜ì—ˆë˜ ê³µê²©ì˜ ê¸°ë°˜ì¸ ì¸ì½”ë”©ì´ ìƒì‡„ë˜ëŠ” ë¬¸ì œë¥¼ ê·¹ë³µí•˜ê¸° ìœ„í•œ ë°©ì‹ìœ¼ë¡œ ìŒí•¨ìˆ˜ ê¸°ë°˜ êµ¬í˜„ ì œì‹œ</p> <table> <thead> <tr> <th>Â </th> <th>ê¸°ì¡´ (CEJO, SE)</th> <th>ê°œì„  (Implicit)</th> </tr> </thead> <tbody> <tr> <td>ì¸ì½”ë”© íŠ¹ì„±</td> <td>2ê°œ ë¼ìš´ë“œì— ë‹¤ë¥¸ ì¸ì½”ë”© ìƒì‡„</td> <td>3ê°œ ë¼ìš´ë“œë¥¼ í†µí•œ ì¸ì½”ë”© ìƒì‡„</td> </tr> <tr> <td>ê³µê²© ì§€ì </td> <td>3 ë¼ìš´ë“œ ì´ìƒì´ ì£¼ì–´ì§ˆ ë•Œ,</td> <td>Â </td> </tr> <tr> <td>ê³µê²©ìë„ ì¸ì½”ë”© ìƒì‡„ ê°€ëŠ¥</td> <td>Â </td> <td>Â </td> </tr> </tbody> </table> <p>Affine SEë¥¼ ê°€ì§€ë©´ì„œ ì•”í˜¸ì— ì‚¬ìš© ê°€ëŠ¥í•œ ì—°ì‚°ì€ ê³ ì°¨ í•¨ìˆ˜ì´ë¯€ë¡œ ë‹¤í•­ì‹ìœ¼ë¡œ ì €ì¥í•˜ê¸°ì— ë¶€ì í•©í•¨</p> <p>â†’ <strong>ìŒí•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ì €ì°¨í•¨ìˆ˜ë¡œ í‘œí˜„ ê°€ëŠ¥í•¨</strong></p> <ul> <li>ê¸°ë³¸ í•¨ìˆ˜: $y = x^{n}\; (\Leftrightarrow x^n+y=0)$</li> <li> <p>ìŒí•¨ìˆ˜ í‘œí˜„: $(x(xy+1), y(xy+1)) = (0,0)$</p> </li> <li> <p>í™”ì´íŠ¸ë°•ìŠ¤ êµ¬í˜„ ê¸°ìˆ ì˜ íë¦„ (Motivation Flow)</p> <p>ì´ˆê¸° WB êµ¬í˜„ ì•„ì´ë””ì–´: í‚¤ë¥¼ ë³´í˜¸í•˜ê¸° ìœ„í•œ ì¸ì½”ë”©ì„ ë¶™ì—¬ì„œ Tableë¡œ ì €ì¥</p> <p>â†’ Table ì €ì¥ì— í•„ìš”í•œ ë©”ëª¨ë¦¬ í¬ê¸° ë¬¸ì œ: $2^n \cdot n$</p> <p>â†’ ì‘ì€ ë¹„ì„ í˜• ì¸ì½”ë”©ì„ ë¶™ì´ëŠ” ì‘ì€ Table êµ¬í˜„ (CEJO)</p> <p>â†’ ë¹„ì„ í˜• ì¸ì½”ë”©ì„ ì„ í˜• ì¸ì½”ë”©ìœ¼ë¡œ ë°”ê¾¸ëŠ” ê³µê²©</p> <p>â†’ í° ì¸ì½”ë”©ì„ ì ìš© ê°€ëŠ¥í•œ SE êµ¬í˜„ ë°©ì‹ ì°¨ìš©</p> <p>â†’ Table ë³´ë‹¨ ë‚«ì§€ë§Œ ì—¬ì „íˆ ë©”ëª¨ë¦¬ ë¬¸ì œ (í° ì¸ì½”ë”©ì„ ì“°ëŠ”) ë°œìƒ</p> <p>â†’ ìŒí•¨ìˆ˜ ê¸°ë°˜ êµ¬í˜„ ì‚¬ìš©</p> <ul> <li>ìŒí•¨ìˆ˜ ë°©ì •ì‹ì„ ì‚¬ìš©í•˜ë©´ ê³ ì°¨ ì–‘í•¨ìˆ˜ ë°©ì •ì‹ì„ ì €ì°¨ë¡œ í‘œí˜„ ê°€ëŠ¥í•¨ <ul> <li>$y=x^n$ì— ëŒ€í•˜ì—¬</li> <li>($n+1$ì°¨) $x \cdot x^n = xy$ (2ì°¨)</li> </ul> </li> <li>ì¸ì½”ë”© ìƒì‡„ ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ <ul> <li>ë‘ ë¼ìš´ë“œ ë‹¨ìœ„ cancellation ruleì˜ ì„±ë¦½ì´ ì•„ë‹Œ</li> <li>ì„¸ ë¼ìš´ë“œ ë‹¨ìœ„ cancellation ruleì˜ ì„±ë¦½ì„ ê¾€í•¨</li> </ul> \[\begin{matrix} \text{Modular Addition: }n\text{ì°¨} &amp; \xleftrightarrow{\quad\text{CCZ-equiv}\quad} &amp; 2\text{ì°¨ í•¨ìˆ˜ }Q \\ \boxplus\text{ì˜ ê·¸ë˜í”„} &amp; \xleftrightarrow{\text{affine-permutation}} &amp; Q\text{ ì˜ ê·¸ë˜í”„} \end{matrix}\] <p>ê·¸ë˜í”„: í•¨ìˆ˜ ê´€ê³„ë¥¼ ë§Œì¡±í•˜ëŠ” $(x, y)$ì˜ ì§‘í•©</p> <ul> <li> <p>CCZ-equivalence: ê·¸ë˜í”„ê°€ affine-permutationìœ¼ë¡œ ê´€ê³„ë¨</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/boxplus_ccz.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="boxplus_ccz"/> </p> </li> <li>$\boxplus$ (S-layer)ëŠ” $Q$ì™€ CCZ-equiv</li> <li>$n$ì°¨ $\boxplus$ ë¥¼ 2ì°¨ í•¨ìˆ˜ $Q$ì˜ ìŒí•¨ìˆ˜ë¡œ í‘œí˜„</li> </ul> <p>â‡’ ìŒí•¨ìˆ˜ë¡œ í‘œí˜„í•˜ê¸°ì— ì¢‹ì€ ì¡°ê±´</p> <p>â‡’ ARX Cipherì˜ S-layer($\boxplus$)ë¥¼ ìŒí•¨ìˆ˜ë¡œ í‘œí˜„</p> </li> </ul> </li> </ul> <h2 id="raneas-arx-wbc-implicit-implementation">Raneaâ€™s ARX-WBC Implicit Implementation</h2> <h3 id="ë¼ìš´ë“œ-í•¨ìˆ˜ì™€-self-equivalence-ìœ ë„"><strong>ë¼ìš´ë“œ í•¨ìˆ˜ì™€ Self-Equivalence ìœ ë„</strong></h3> <p>ì„ì˜ì˜ ë¼ìš´ë“œ í•¨ìˆ˜</p> \[E^{(i)} = L^{(i)} \circ S\] <p>($L^{(i)}$ëŠ” ë¼ìš´ë“œ í‚¤ $k^{(i)}$ë¥¼ í¬í•¨í•¨)</p> <p>ë¹„ì„ í˜• í•¨ìˆ˜ $S$ëŠ” affine-quadratic self-equivalence $(A^{(i)}, B^{(i)}) \in SE(S)$ë¥¼ ê°€ì§</p> \[S = B^{(i)} \circ S \circ A^{(i)}\] <ul> <li>$A^{(i)}$: affine right SE</li> <li>$B^{(i)}$: quadratic left SE</li> </ul> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/basic_attack_structure.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="basic_attack_structure"/> </p> <table> <tbody> <tr> <td>ê·¸ë¦¬ê³  $</td> <td>SE(E^{(i)})</td> <td>=</td> <td>SE(S)</td> <td>$ì´ë¯€ë¡œ $E^{(i)}$ì˜ self-equivalenceëŠ” ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ ê°€ëŠ¥í•¨</td> </tr> </tbody> </table> \[\begin{aligned} E^{(i)} &amp;= L^{(i)} \circ S \\ &amp;= L^{(i)} \circ B^{(i)} \circ S \circ A^{(i)} \\ &amp;= L^{(i)} \circ B^{(i)} \circ (L^{(i)})^{-1} \circ L^{(i)} \circ S \circ A^{(i)} \\ &amp;= L^{(i)} \circ B^{(i)} \circ (L^{(i)})^{-1} \circ E^{(i)} \circ A^{(i)} \end{aligned}\\[.5em] \therefore (A^{(i)}, L^{(i)} \circ B^{(i)} \circ (L^{(i)})^{-1}) \in SE(E^{(i)})\] <p>Let $\hat{A}^{(i)} = A^{(i)},\; \hat{B}^{(i)}= L^{(i)}\circ B^{(i)}\circ (L^{(i)})^{-1}$</p> <p>Then</p> \[E^{(i)} = \hat{B}^{(i)} \circ E^{(i)} \circ \hat{A}^{(i)}\] <p>í•œí¸, $C^{(i+1)}$ : affine permutationì— ëŒ€í•˜ì—¬,</p> \[E^{(i)} = \hat{B}^{(i)} \circ E^{(i)} \circ \hat{A}^{(i)} = \hat{B}^{(i)} \circ (C^{(i+1)})^{-1} \circ C^{(i+1)} \circ E^{(i)} \circ \hat{A}^{(i)}\] <p>ì´ê³ , ì—°ì†ëœ ë‘ ë¼ìš´ë“œì— ëŒ€í•˜ì—¬ ë‹¤ìŒì´ ì„±ë¦½í•¨</p> \[\begin{aligned} &amp; E^{(i)} \circ E^{(i-1)} = \\ &amp; \left( \hat{B}^{(i)} \!\circ\! (C^{(i+1)})^{-1} \circ\! \right. \underset{\color{blue}\overline{E}^{(i)}}{\color{blue}\underbrace{ \color{blue}\left[ \color{black} C^{(i+1)} \!\circ E^{(i)} \!\circ\! \hat{A}^{(i)} \right) \color{black} \;\circ\; \left( \hat{B}^{(i-1)} \!\circ\! (C^{(i)})^{-1}\color{blue} \right] \!\color{black}}} \left. \circ\, C^{(i)} \!\circ E^{(i-1)} \circ \hat{A}^{(i-1)} \right) \end{aligned}\] <p>ì¸ì½”ë”©ëœ ë¼ìš´ë“œ í•¨ìˆ˜ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•˜ë©´</p> \[\bar{E}^{(i)} = C^{(i+1)} \circ E^{(i)} \circ \hat{A}^{(i)} \circ \hat{B}^{(i-1)} \circ (C^{(i)})^{-1}\] <p>ë”°ë¼ì„œ ì¸ì½”ë”©ëœ ì•”í˜¸í™” í•¨ìˆ˜ëŠ”</p> \[\begin{aligned} \bar{E}_k &amp;= \bar{E}^{(r)} \circ \bar{E}^{(r-1)} \circ \dots \circ \bar{E}^{(2)} \circ \bar{E}^{(1)}\\[.7em] &amp;= \left[ C^{(r+1)} \circ E^{(r)} \circ \hat{A}^{(r)} \circ \color{red} \hat{B}^{(r-1)} \circ (C^{(r)})^{-1} \right]\\ {\color{red}\footnotesize E^{(r-1)\;}} &amp;{\color{red}\footnotesize\rightarrow} \;\, \color{red} \circ \left[ C^{(r)} \circ E^{(r-1)} \circ \hat{A}^{(r-1)} \color{black} \circ \hat{B}^{(r-2)} \circ (C^{(r-1)})^{-1} \right] \\ &amp;\quad\; \circ\; \cdots \\ &amp;\quad\;\circ \left[ C^{(3)} \circ E^{(2)} \circ \hat{A}^{(2)} \circ \hat{B}^{(1)} \circ (C^{(2)})^{-1} \right]\\ &amp;\quad\; \circ \left[ C^{(2)} \circ E^{(1)} \circ \hat{A}^{(1)} \circ \hat{B}^{(0)} \circ (C^{(1)})^{-1} \right]\\[1em] &amp; = C^{(r+1)} \circ E^{(r)} \circ \hat{A}^{(r)} \circ E^{(r-1)} \circ \dots \circ E^{(2)} \circ E^{(1)} \circ \hat{B}^{(0)} \circ (C^{(1)})^{-1}\\[.7em] &amp;= \left[ \hat{B}^{(r)} \circ (C^{(r+1)})^{-1} \right]\circ \left[ \hat{B}^{(r)} \circ (C^{(r+1)})^{-1} \right]^{-1} \circ C^{(r+1)} \circ E^{(r)} \circ \hat{A}^{(r)}\\ &amp;\quad\; \circ\dots \circ E^{(1)} \circ \left[ \hat{B}^{(0)} \circ (C^{(1)})^{-1} \right]\\[.7em] &amp;= \left[ \hat{B}^{(r)} \circ (C^{(r+1)})^{-1} \right]\circ E^{(r)}\circ \dots \circ E^{(1)} \circ \left[ \hat{B}^{(0)} \circ (C^{(1)})^{-1} \right]\\[1em] &amp; = O_{ext} \circ E_k \circ I_{ext} \end{aligned}\] <p>ì´ë•Œ</p> \[O_{ext} = C^{(r+1)} \circ (\hat{B}^{(r)})^{-1} \qquad\text{and}\qquad I_{ext} = \hat{B}^{(0)} \circ (C^{(1)})^{-1}\] <h3 id="ì¸ì½”ë”©ëœ-ì•”í˜¸í™”-í•¨ìˆ˜ì—-ëŒ€í•œ-ìŒí•¨ìˆ˜-êµ¬í˜„"><strong>ì¸ì½”ë”©ëœ ì•”í˜¸í™” í•¨ìˆ˜ì— ëŒ€í•œ ìŒí•¨ìˆ˜ êµ¬í˜„</strong></h3> <p>ì•ì„œ ì •ë¦¬í•œ ì¸ì½”ë”©ëœ ì•”í˜¸í™” í•¨ìˆ˜ëŠ”</p> \[\begin{aligned} \bar{E}^{(i)} &amp; = C^{(i+1)} \circ E^{(i)} \circ \hat{A}^{(i)} \circ \hat{B}^{(i-1)} \circ (C^{(i)})^{-1} \\[.5em] &amp; = C^{(i+1)} \circ L^{(i)} \circ S \circ \hat{A}^{(i)} \circ \hat{B}^{(i-1)} \circ (C^{(i)})^{-1} \end{aligned}\] <p>ì´ë¥¼ ìŒí•¨ìˆ˜ë¡œ êµ¬í˜„í•˜ë©´</p> <p>$T$ë¥¼ $S$ì˜ ìŒí•¨ìˆ˜ë¼ê³  í•  ë•Œ, $\bar{E}^{(i)}$ì˜ ìŒí•¨ìˆ˜ $P^{(i)}$ëŠ”</p> \[P^{(i)} = T \circ \left(Id, (L^{(i)})^{-1}\right) \circ \left(\hat{A}^{(i)}, Id\right) \circ \left(\hat{B}^{(i-1)}, Id\right) \circ \left((C^{(i)})^{-1}, (C^{(i+1)})^{-1}\right)\] <p>ë‚˜ì•„ê°€ $(U^{(i)}, V^{(i)})$ê°€ $T$ì˜ SEë¼ í•˜ë©´</p> \[P^{(i)} = V^{(i)} \circ T \circ U^{(i)} \circ \dots \circ ((C^{(i)})^{-1}, (C^{(i+1)})^{-1})\] <p>CEJOë‚˜ SE êµ¬í˜„ì— ìˆ˜ë°˜ëœ ì¼ë°˜ì ì¸ ê³µê²©ë“¤ì— ì €í•­ì„±ì„ ê°€ì§</p> <p><strong>Explicitê³¼ Implicitì˜ ê´€ê³„</strong></p> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/ARX_explicit_implicit.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="ARX_explicit_implicit"/> </p> \[E^{(i)} = \hat{B}^{(i)} \circ (C^{(i+1)})^{-1} \circ C^{(i+1)} \circ E^{(i)} \circ \hat{A}^{(i)}\] \[\bar{E}^{(i)} = \underbrace{C^{(i+1)} \circ L^{(i)}}_{\text{affine}} \circ \underbrace{S}_{\substack{ \!\!\!\!\!\text{ì£¼ìš” ìŒí•¨ìˆ˜}\!\!\!\!\! \\[.2em] \!\!\!\!\!\text{ë³€í™˜ ëŒ€ìƒ}\!\!\!\!\!}} \circ \underbrace{\hat{A}^{(i)} \circ \hat{B}^{(i-1)} \circ (C^{(i)})^{-1}}_{\text{quadratic}}\] <h1 id="birykovs-attack">Birykovâ€™s Attack</h1> <h2 id="external-encoding-ìƒì‡„">External encoding ìƒì‡„</h2> \[\begin{aligned} \bar{E}_K &amp;= O_{ext} \circ E_K \circ I_{ext} \\ &amp;= \left( C^{(r+1)} \circ (\hat{B}^{(r)})^{-1} \right) \circ E_K \circ \left( \hat{B}^{(0)} \circ (C^{(1)})^{-1} \right) \end{aligned}\] <h3 id="1-o_extê°€-ì—†ëŠ”-ê²½ìš°"><strong>1. $O_{ext}$ê°€ ì—†ëŠ” ê²½ìš°</strong></h3> \[\bar{E}_K = \bar{E}^{(r)} \circ \bar{E}^{(r-1)} \circ \dots \circ \bar{E}^{(1)}\] <p>ë§ˆì§€ë§‰ ë¼ìš´ë“œ $\bar{E}^{(r)}$ ë¶„ì„</p> \[\begin{aligned} \qquad\quad \bar{E}^{(r)} &amp;= C^{(r+1)} \circ E^{(r)} \circ \underbrace{\; \hat{A}^{(r)}}_{\substack{ \!\!\!\!\!\!\!\!\!\!\text{ë¨¼ì € ì—†ì•¨ ëŒ€ìƒ}\!\!\!\!\!\!\!\!\!}} \circ \hat{B}^{(r-1)} \circ (C^{(r)})^{-1}\\[1.5em] &amp;= C^{(r+1)} \circ \underbrace{(\hat{B}^{(r)})^{-1} \circ \hat{B}^{(r)}}_{\substack{ \Rightarrow\text{ ì¶”ê°€}}} \circ E^{(r)} \circ \hat{A}^{(r)} \circ \hat{B}^{(r-1)} \circ (C^{(r)})^{-1} \\ &amp;= E^{(r)} \circ \hat{B}^{(r-1)} \circ (C^{(r)})^{-1} \qquad\qquad \footnotesize (O_{ext}\text{ê°€ ì—†ìœ¼ë¯€ë¡œ, } C^{(r+1)} \!\circ\! (\hat{B}^{(r)})^{-1} = Id)\\[1em] &amp;= E^{(r)} \circ Q^{(r)} \qquad\qquad\qquad\qquad\quad\; \footnotesize (\text{Let } \hat{B}^{(r-1)} \circ (C^{(r)})^{-1} = Q^{(r)})\\ \end{aligned}\] <p>â‡’ í™”ì´íŠ¸ë°•ìŠ¤ ê³µê²©ìëŠ” $\bar{E}_K$ì˜ ë°©ì •ì‹ë§Œ ê°€ì§€ê³  ìˆìœ¼ë¯€ë¡œ ê³µê²© ëŒ€ìƒ ë¼ìš´ë“œ í•¨ìˆ˜ë¥¼</p> \[F = \bar{E}^{(r)} = E^{(r)} \circ Q^{(r)}\] <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_in_encoding_attack_structure_1.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_in_encoding_attack_structure_1"/> </p> <p>â†’</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_out_encoding_attack_structure_1.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_out_encoding_attack_structure_1"/> </p> <p>ì´ë¼ê³  í•˜ë©´, êµ¬í˜„ í•¨ìˆ˜ì˜ ì…ì¶œë ¥ì€ ëª¨ë¥´ê³  ë¼ìš´ë“œ ì „ì²´ì— ëŒ€í•œ ì…ì¶œë ¥ì„ ì•Œ ìˆ˜ ìˆìŒ (ì˜¤ë¼í´)</p> <p><strong>ê³µê²© ì „ëµ</strong></p> <p>$Q^{(r)}$ë¥¼ linearë¡œ ë³€í™˜ì‹œì¼œ ì´ì „ ë¼ìš´ë“œì™€ ìƒì‡„ë˜ë„ë¡ í•˜ê³  $E^{(r)}$ì˜ í‚¤ë¥¼ êµ¬í•¨</p> <p>â‡’ $Q$ì™€ ë™ì¹˜ì¸ $M$ì„ ì°¾ì•„ì•¼ í•¨</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_out_encoding_attack_structure_2.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_out_encoding_attack_structure_2"/> </p> \[\begin{aligned} x &amp;= (x_{N-1}, x_{N-2}, \dots, x_1, x_0) \\ &amp;\Downarrow \\ \tilde{x} &amp;= (x_{N-1}x_{N-2}, x_{N-1}x_{N-3}, \dots, x_2x_1, x_2x_0, x_1x_0, \\ &amp;\qquad\! x_{N-1}, x_{N-2}, \dots, x_1, x_0, \\ &amp;\qquad\! 1) \end{aligned}\] \[Q(x) = M(\tilde{x})\] <p>ê³µê²©ì„ ìœ„í•œ êµ¬ì¡°í™”</p> <ul> <li>ê³µê²© ì…ì¶œë ¥ ì •ì˜ <ul> <li> <p>$(x^{(i)}, y^{(i)})$ : $i$ë²ˆì§¸ ê³µê²© ì…ì¶œë ¥ ìŒ ($y^{(i)}$ê°€ ì˜¤ë¼í´ì˜ ì¶œë ¥ì€ ì•„ë‹˜)</p> \[y^{(i)}=G^{-1}(F(x^{(i)}))\] </li> <li> <p>$z^{(i)}$ : $(x^{(i)}, y^{(i)})$ì— ëŒ€í•œ ì¤‘ê°„ê°’</p> </li> </ul> </li> </ul> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_out_encoding_attack_structure_3.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_out_encoding_attack_structure_3"/> </p> <p>$k_0$ë¶€í„° ìƒìœ„ ë¹„íŠ¸ë¡œ ìˆœì°¨ ê³µê²© ì§„í–‰</p> \[(z^{(i)}_0 \boxplus y^{(i)}_0) \oplus k_0 = y^{(i)}_n\\[.7em] \implies y^{(i)}_n = z^{(i)}_0 \oplus y^{(i)}_0 \oplus k_0\] <p>$\because$ 0ë²ˆì§¸ ë¹„íŠ¸ì— ëŒ€í•´ì„œëŠ” $\boxplus$ê°€ $\oplus$ì™€ ê°™ìŒ</p> \[z^{(i)}_0 = \underset{\text{known}}{\underbrace{\ y^{(i)}_n \oplus y^{(i)}_0}} \oplus \underset{\!\!\!\!\text{guessing}\!\!\!\!}{\underbrace{k_0}}\] <p>$k_0$ë¥¼ ì¶”ì¸¡í•˜ë©´ $z_0^{(i)}$ë¥¼ êµ¬í•  ìˆ˜ ìˆìŒ</p> <p>$L+\epsilon$ê°œ ì…ì¶œë ¥ ìŒì— ì˜í•œ $z^{(i)}$ì— ëŒ€í•˜ì—¬ $k_0$ì— ëŒ€í•œ ì¶”ì¸¡ì„ ë°˜ë³µí•˜ì—¬ êµ¬í•œ $z_0^{(i)}$ë¡œ ë‹¤ìŒì„ í™•ì¸</p> \[(z^{(1)}_0, \dots, z^{(N+\epsilon)}_0) = M_n (\tilde{x}^{(1)} \dots \tilde{x}^{(N+\epsilon)})\] <p>ìœ„ ì‹ì´ ì„±ë¦½í•˜ë©´ $k_0$ë¥¼ ì˜³ê²Œ ì¶”ì¸¡í•œ ê²ƒ</p> <p>ë¬¸ì œëŠ” ì•„ì§ $M_n$ì„ ëª¨ë¦„</p> <p>$Z_{\cdot 0} = (z^{(1)}_0, z^{(2)}_0, \dots, z^{(N+e)}_0)$ê°€ $\hat{x}^{(i)}$ë“¤ë¡œ ë§Œë“  í–‰ë ¬ $\tilde{X}$ì˜ í–‰ê³µê°„(Column Space)ì— ì†í•˜ëŠ”ì§€ í™•ì¸</p> <ul> <li>$z_0$ê°€ $\hat{x}^{(i)}$ì˜ ì„ í˜• ê²°í•©ì´ë¯€ë¡œ</li> <li> <p>$\tilde{X}$ ìƒì„±ì—ëŠ” $L=O(N^2)$ê°œ ì…ë ¥ í•„ìš”</p> <p>ì‹¤ì œ ìƒì„± ê°€ëŠ¥í•œ ì…ë ¥ì€ $2^N$ê°œì´ë¯€ë¡œ full-rank matrix ìƒì„± ê°€ëŠ¥</p> </li> </ul> <p>â‡’ ${x}^{(i)}$ì˜ parity check í–‰ë ¬ $H$ë¡œ íš¨ìœ¨ì ì¸ í™•ì¸ ê°€ëŠ¥</p> <p>$H$ëŠ” $\tilde{X}$ì˜ ì—´ê³µê°„ê³¼ ì§êµí•˜ëŠ” í–‰ë ¬</p> \[\begin{pmatrix} | &amp; &amp; | \\[.4em] \tilde{x}^{(1)} &amp;\cdots &amp; \tilde{x}^{(L+e)} \\ | &amp; &amp; | \end{pmatrix} = \tilde{X}_{L \times (L+\epsilon)} \;\xrightarrow{RREF\,}\; (I \mid P) \;\xrightarrow{\text{gen }H}\; H = \begin{pmatrix}-P^T \mid I\end{pmatrix}\] <p>$k_0$ë¥¼ ì˜³ê²Œ ì¶”ì¸¡í•œ ê²½ìš° $H z_{0} = 0$</p> <p>ì˜ëª» ì¶”ì¸¡í•´ë„ $H z_{0} = 0$ì¼ ìˆ˜ ìˆìŒ</p> <p>â†’ ì˜¤íŒì€ ê³µê²©ì˜ ì ì§„ì  ì§„í–‰ ê³¼ì •ì„ í†µí•´ ìˆ˜ì •</p> <p>$\therefore H z_{0} \neq 0$ì´ë©´ $k_0$ë¥¼ ì˜ëª» ì¶”ì¸¡í–ˆë‹¤ê³  íŒë‹¨</p> <ul> <li> <p>ì´ëŸ¬í•œ ë°©ì‹ì€ ì¼ë¶€ $k_j$ì— ëŒ€í•˜ì—¬, ì–´ë–¤ ê°’ìœ¼ë¡œ ì¶”ì¸¡í•˜ë“  $z_j$ê°€ ì—´ ê³µê°„ì— ì†í•˜ëŠ” ê²½ìš°ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ</p> <p>ê·¸ëŸ¬ë‚˜ ë‹¤ìŒ í‚¤ ë¹„íŠ¸ë¥¼ ì¶”ì¸¡í•˜ëŠ” ê³¼ì •ì—ì„œ $k_{j+1}$ë¥¼ ì–´ë–¤ ê°’ìœ¼ë¡œ ì„¤ì •í•˜ë“  $z_{j+1}$ì´ $\tilde{X}$ì˜ ì—´ê³µê°„ì— ì†í•˜ì§€ ì•Šìœ¼ë©´, $k_1,\,â€¦,\,k_{j}$ë¥¼ ì˜ëª» êµ¬í–ˆë‹¤ê³  íŒë‹¨í•  ìˆ˜ ìˆìŒ</p> <p>â†’ ê° ë¹„íŠ¸ì— ëŒ€í•˜ì—¬ í™•ì¸í•  ê°’ì´ ë‘˜ ë¿ì´ë¯€ë¡œ í˜„ì‹¤ì ì¸ ì—°ì‚° ê°€ëŠ¥</p> </li> <li> <p>ë˜í•œ, $k_{n-1}$ì— ëŒ€í•´ ê²°ì •í•˜ì§€ ëª»í•  ê²½ìš°, ì´í›„ $r-1$ ë²ˆì§¸ ë¼ìš´ë“œì˜ ë¼ìš´ë“œ í‚¤ë¥¼ ë³µêµ¬í•˜ëŠ” ê³¼ì •ì—ì„œ $r$ ë¼ìš´ë“œì˜ í‚¤ë¥¼ í•˜ë‚˜ë¡œ íŠ¹ì • ê°€ëŠ¥</p> </li> </ul> <p>$k_0$ë¥¼ êµ¬í•˜ê³  ê²€ì¦ì„ í•˜ë©´ $z_0 \boxplus y_0$ì— ë”°ë¥¸ carry($c_1$)ë¥¼ êµ¬í•  ìˆ˜ ìˆìŒ</p> \[(z^{(i)} \boxplus y^{(i)}) \oplus k_1 = y^{(i)}_{n+1}\\[1em] \Rightarrow y^{(i)}_{n+1} = z^{(i)}_1 \oplus y^{(i)}_1 \oplus c^{(i)}_1 \oplus k_1\\[1em] \therefore z^{(i)}_1 = \underbrace{y^{(i)}_{n+1} \oplus y^{(i)}_1 \oplus c^{(i)}_1}_{\text{known}} \oplus \underbrace{k_1}_{\!\!\!\!\text{guessing}\!\!\!\!}\] <p>ê°™ì€ ê³¼ì • ë°˜ë³µ â‡’ ë¼ìš´ë“œ í‚¤ $k^{(r)}$ ë³µêµ¬</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_out_encoding_attack_structure_4.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_out_encoding_attack_structure_4"/> </p> <p>ë¼ìš´ë“œ $r$ì˜ í‚¤ë¥¼ ì•Œì•˜ìœ¼ë¯€ë¡œ í•´ë‹¹ ë¼ìš´ë“œë¥¼ ë²—ê²¨ë‚´ê³  ì´ì „ ë¼ìš´ë“œ($r-1$)ë¥¼ ê³µê²©</p> \[\begin{aligned} \bar{E}^{(r)} \circ \bar{E}^{(r-1)} &amp;= E^{(r)} \circ \underset{\bar{E}^{(r-1)}}{\underbrace{\;Q^{(r)} \circ \left[ C^{(r)} \circ E^{(r-1)} \circ \hat{A}^{(r-1)} \right.}} \left.\circ\ \hat{B}^{(r-2)} \circ (C^{(r-1)})^{-1} \right] \\[2em] &amp;= E^{(r)} \circ E^{(r-1)} \circ B^{(r-2)} \circ (C^{(r-1)})^{-1} \\ &amp;= E^{(r)} \circ E^{(r-1)} \circ Q^{(r-1)} \end{aligned}\] <p>â‡’ $r$ ë¼ìš´ë“œì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ $r-1$ ë¼ìš´ë“œ ê³µê²©</p> <p>â‡’ ì²« ë²ˆì§¸ ë¼ìš´ë“œê¹Œì§€ ê³µê²© ìˆ˜í–‰</p> <p>Speckì˜ ë§ˆìŠ¤í„° í‚¤ ê¸¸ì´ëŠ” $4n$ì´ë¯€ë¡œ 4ê°œ ë¼ìš´ë“œì˜ ë¼ìš´ë“œ í‚¤ë¥¼ ì°¾ìœ¼ë©´ ë§ˆìŠ¤í„° í‚¤ë¥¼ ë³µêµ¬ ê°€ëŠ¥</p> <p>â‡’ $r$ë¶€í„° $r-4$ ë²ˆì§¸ ë¼ìš´ë“œê¹Œì§€ ìµœëŒ€ 5ê°œ ë¼ìš´ë“œì— ëŒ€í•˜ì—¬ ìœ„ ê³µê²© ê³¼ì •ì„ ìˆ˜í–‰í•˜ë©´ ë§ˆìŠ¤í„° í‚¤ë¥¼ ë³µêµ¬</p> <p>ë§ˆìŠ¤í„° í‚¤ë¥¼ ë³µêµ¬í•˜ì§€ ì•Šê³  ëª¨ë“  ë¼ìš´ë“œì— ëŒ€í•˜ì—¬ ë¼ìš´ë“œ í‚¤ë¥¼ êµ¬í•˜ëŠ” ê³µê²©ë„ ê°€ëŠ¥</p> <p><strong>ê³µê²©ì— í•„ìš”í•œ ì—°ì‚°ëŸ‰</strong></p> <ul> <li>Parity check matrix ìƒì„± : $O(L^3)=O((n^2)^3)$ <ul> <li>ë‹¨, ì—¬ëŸ¬ ë¼ìš´ë“œë¥¼ ê³µê²©í•˜ë”ë¼ë„ $x^{(i)}$ë¥¼ ë°˜ë³µí•´ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ í•œ ë²ˆë§Œ ìˆ˜í–‰í•˜ë©´ ë¨</li> </ul> </li> <li>$x^{(i)}$ë¡œ $y^{(i)}$ë¥¼ êµ¬í•˜ê¸° ìœ„í•œ $G^{-1}(F(x^{(i)}))$ ì—°ì‚° : $O(n^2)$ <ul> <li>$L$ë²ˆ $\times$ (ì˜¤ë¼í´ ì§ˆì˜ + $G^{-1}$ ì—°ì‚°) $=$ ì˜¤ë¼í´ ì§ˆì˜ $O(L) = O(n^2)$</li> </ul> </li> <li> <p>$k_j$ë¥¼ ì¶”ì¸¡í•œ ë’¤, $z_j$ê°€ ë§ê²Œ ë‚˜ì˜¤ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•œ $H z_j$ ì—°ì‚° : $O(n^5)$</p> <p>$n$ê°œì˜ $k_j$ $\times$ $z_j^{(i)}$ ê³±ì…ˆ ì—°ì‚° $O(n^2)$ $\times$ $z_j$ì˜ í¬ê¸° $O(n^2)$ $=$ $O(n^5)$</p> </li> </ul> <h3 id="2-i_extê°€-ì—†ëŠ”-ê²½ìš°">2. $I_{ext}$ê°€ ì—†ëŠ” ê²½ìš°</h3> <p>Input external encodingì´ ì—†ëŠ” ê²½ìš°ì— ëŒ€í•œ ê³µê²©ì„ ìœ„í•´ ë‹¤ìŒì„ ê°€ì •</p> \[I_{\text{ext}} = B^{(0)}\circ \left(C^{(1)}\right)^{-1} = Id\] <p>ì¦‰,</p> \[\overline{E_k} = O_{\text{ext}}\circ E_k \circ I_{\text{ext}}Â  Â  Â  Â  = \left( C^{(r+1)}\circ \left(B^{(r)}\right)^{-1} \right)\circ Â  Â  Â  Â  Â  Â  E_k\circ \left( B^{(0)}\circ \left(C^{(1)}\right)^{-1} \right)\] <p>ì´ë¥¼ ì ìš©í•˜ë©´ ì–´ë–¤ quadratic function $Q^{(1)}$ê°€ $Q^{(1)} = C^{(2)} \circ \left( B^{(1)} \right)^{-1}$ë¼ê³  í•  ë•Œ, ì²« ë²ˆì§¸ ë¼ìš´ë“œ í•¨ìˆ˜ $E^{(1)}$ì„ ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„ ê°€ëŠ¥</p> \[\begin{aligned} \qquad\qquad \overline{E}^{(1)} &amp; = C^{(2)} \circ E^{(1)} \circ A^{(1)} \circ \underset{=\,Id}{\underbrace{B^{(0)} \circ \left( C^{(1)} \right)^{-1} }} \\ &amp; = \left[ C^{(2)} \circ ( B^{(1)} )^{-1} \right] \circ \left[ B^{(1)} \right. \circ \underset{=\,Id}{\underbrace{ \left. ( C^{(2)} )^{-1} \right] \circ C^{(2)}}} \circ E^{(1)} \circ A^{(1)} \\ &amp; = \left[ C^{(2)} \circ ( B^{(1)} )^{-1} \right] \circ \underset{=\,E^{(1)}}{\underbrace{\ B^{(1)} \circ E^{(1)} \circ A^{(1)}}} \\ &amp; = Q^{(1)}\circ E^{(1)} \end{aligned}\] <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_in_encoding_attack_structure_1_1.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_in_encoding_attack_structure_1"/> </p> <p>ì•”í˜¸ ì•Œê³ ë¦¬ì¦˜ì´ Speckì´ë¼ëŠ” ì ì„ ê³ ë ¤í•˜ë©´, ì²« ë¼ìš´ë“œì˜ êµ¬ì¡°ë¥¼ ì˜¤ë¥¸ìª½ ê·¸ë¦¼ê³¼ ê°™ì´ í‘œí˜„ ê°€ëŠ¥</p> <p>ìœ„ ëª¨ë¸ì— ëŒ€í•œ ê³µê²©ì€ output encodingì´ ì—†ëŠ” ê²½ìš°ì™€ ë¹„ìŠ·í•˜ê²Œ ìˆ˜í–‰ë˜ì§€ë§Œ, ë¼ìš´ë“œ í‚¤ ì—°ì‚° ê²°ê³¼ê°€ $Q$ì—ì„œ ë¹„ì„ í˜•ìœ¼ë¡œ ì„ì—¬ í•œ ë¹„íŠ¸ì”© ì¶”ì¸¡ ë¶ˆê°€ëŠ¥í•˜ë‹¤ëŠ” ì°¨ì´ê°€ ìˆìŒ</p> <p>â‡’ input encodingì´ ì—†ëŠ” ê²½ìš°ì— ëŒ€í•œ ì²« ë¼ìš´ë“œì˜ í‚¤ ì¶”ì¶œ ê³µê²©ì€ ì²˜ìŒ ë‘ ë¼ìš´ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìˆ˜í–‰</p> \[\begin{aligned} \qquad \overline{E}^{(2)} \circ \overline{E}^{(1)} &amp; = \left[ C^{(3)} \circ E^{(2)} \circ A^{(2)} \circ B^{(1)} \circ ( C^{(2)})^{-1} \right] \circ \left[ C^{(2)} \circ E^{(1)} \circ A^{(1)} \right] \\[1em] &amp; = \; C^{(3)}\circ \left[ (B^{(2)})^{-1} \right. \circ \underset{=\, E^{(2)}}{\underbrace{\ \left. B^{(2)}\right] \circ E^{(2)} \circ A^{(2)} }} \circ \underset{=\, E^{(1)}}{\underbrace{\ B^{(1)} \circ E^{(1)} \circ A^{(1)}}} \\ &amp; = Q^{(2)} \circ E^{(2)} \circ E^{(1)} \end{aligned}\] <p>ì´ë•Œ, $Q^{(r)} = C^{(r+1)} \circ (B^{(r)} )^{-1}$</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_in_encoding_attack_structure_2.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_in_encoding_attack_structure_2"/> </p> <p>ê·¸ ë’¤, ê³µê²©ìê°€ ì ‘ê·¼ ê°€ëŠ¥í•œ ì¸ì½”ë”©ëœ ì²˜ìŒ ë‘ ë¼ìš´ë“œ í•¨ìˆ˜ë¥¼ $F$ë¼ê³  ì •ì˜ (ì˜¤ë¼í´)</p> \[\begin{aligned} F &amp; = \overline{E}^{(2)} \circ \overline{E}^{(1)} \\ &amp; = Q^{(2)} \circ E^{(2)} \circ E^{(1)}. \end{aligned}\] <p>ê³µê²©ìëŠ” ìì‹ ì´ ì„ íƒí•œ ì…ë ¥ $x$ì— ëŒ€í•œ í•¨ìˆ˜ $F$ì˜ ê°’ì„ ì¶œë ¥ìœ¼ë¡œ ì–»ì„ ìˆ˜ ìˆëŠ” ì˜¤ë¼í´ $\mathbb{O}$ì— ì ‘ê·¼ ê°€ëŠ¥</p> <p>ë‹¨, ê³µê²©ìëŠ” ì—¬ì „íˆ $E^{(1)}, E^{(2)}$ë¥¼ ëª¨ë¦„</p> <p>$F$ë¡œë¶€í„° ì²« ë²ˆì§¸ ë¼ìš´ë“œì˜ í‚¤ $k$ë¥¼ êµ¬í•˜ê¸° ìœ„í•œ ì¬ì •ì˜</p> <p>ë‘ ë²ˆì§¸ ë¼ìš´ë“œì˜ í‚¤ëŠ” ì´ì°¨ í•¨ìˆ˜ $Q$ì— í¬í•¨ì‹œí‚¤ê³  ì²« ë²ˆì§¸ ë¼ìš´ë“œ í‚¤ë¥¼ êµ¬í•  ë•ŒëŠ” ë¬´ì‹œ</p> \[Q^{(2)} = C^{(3)} \circ \left( B^{(2)} \right)^{-1} \circ B^{(2)} \circ L^{(2)}\] <p>$L^{(2)}$ëŠ” $E^{(2)}$ì˜ ë¹„ì„ í˜• ë ˆì´ì–´ $S^{(2)}$ ì´í›„ ì—°ì‚°ë˜ëŠ” ì„ í˜• ë ˆì´ì–´</p> <p>â‡’ $S = S^{(1)} = S^{(2)} = \cdots = S^{(r)}$</p> \[\begin{aligned} (z_{n-1},\,...,\,z_0,\, w_{n-1},\,...,\,w_0) &amp; = \left( Q^{(2)} \right)^{-1}(y) \\ &amp; = \left( Q^{(2)} \right)^{-1}(F(x)) \\ &amp; = \left( Q^{(2)} \right)^{-1} \circ \left( Q^{(2)} \circ S^{(2)} \circ E^{(1)} \right) (x) \\ &amp; = \left( S^{(2)} \circ E^{(1)} \right) (x) \end{aligned}\\[1em] F = \overline{E}^{(2)} \circ \overline{E}^{(1)} = Q^{(2)} \circ S^{(2)} \circ E^{(1)}\] <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_in_encoding_attack_structure_3.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_in_encoding_attack_structure_3"/> </p> <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_in_encoding_attack_structure_5.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_in_encoding_attack_structure_5"/> </p> <p>Output external encodingì´ ì—†ëŠ” caseì—ì„œì™€ ë¹„ìŠ·í•˜ê²Œ, quadratic encodingì„ ì œê±°í•˜ê¸° ìœ„í•˜ì—¬ $y$ë¥¼ ê°€ëŠ¥í•œ ëª¨ë“  ì´ì°¨ í•­ìœ¼ë¡œ í‘œí˜„í•œ $\tilde{y}$ë¡œ ë³€í™˜í•˜ì—¬ ì„ í˜• í•¨ìˆ˜ $M$ì„ êµ¬í•˜ëŠ” êµ¬ì¡°ë¡œ ì „í™˜</p> \[(z_{n-1},\,...,\,z_0,\, w_{n-1},\,...,\,w_0)= \left( S^{(2)} \circ E^{(1)} \right) (x) = \left( Q^{(2)} \right)^{\!\!-1}\!\!(y)= M^{(2)}(\tilde{y})\] <p><img src="/june.github.io/assets/img/post/arx_wbc_1/no_in_encoding_attack_structure_4.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="no_in_encoding_attack_structure_4"/> </p> <p>ì˜¤ë¼í´ $\mathbb{O}$ì— ëŒ€í•œ $L = N(N-1)/2 + N + 1$ê°œì˜ ì…ì¶œë ¥ ìŒ $(x, y)$ì— ëŒ€í•˜ì—¬ $y$ë¥¼ ë²¡í„° $\tilde{y}$ë¡œ ë³€í™˜</p> \[y = (y_{N-1}, y_{N-2},\, ...,\, y_0) \;\to \; \tilde{y} = (y_{N-1}y_{N-2},\, ...,\, y_1 y_0, y_{N-1}, y_{N-2},\, ...,\, y_0, 1)\] <p>$Q$ê°€ 2ì°¨ í•¨ìˆ˜ì´ë¯€ë¡œ $\tilde{y}$ì˜ ì„ í˜• ì¡°í•©ìœ¼ë¡œ $Q^{-1}$ì˜ ê²°ê³¼ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŒ</p> <p>â‡’ ë‹¤ìŒì„ ë§Œì¡±í•˜ëŠ” ì–´ë–¤ unknown matrix $M$ì´ ì¡´ì¬</p> \[Q^{-1}(y) = M\tilde{y}\] <p>(Output external encodingì´ ì—†ë˜ ê²½ìš°ì™€ ìœ ì‚¬í•˜ê²Œ) $k$ë¥¼ ì¶”ì¸¡í•˜ì—¬ $z$ë¥¼ êµ¬í•˜ê³ , $M$ì˜ íŒ¨ë¦¬í‹° ì²´í¬ í–‰ë ¬ $H$ë¥¼ ì‚¬ìš©í•˜ì—¬ $k$ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì¶”ì¸¡í–ˆëŠ”ì§€ í™•ì¸</p> \[\begin{aligned}z_0 &amp; = \left[k'_8 \boxplus w_0 \right]_0 \\[.5em] &amp;= \left[k'_8 \boxplus (k'_0 \oplus x_{n-3}) \right]_0 \\[.5em] &amp;= [ (\;\underset{\text{known}}{\underbrace{x'_8}} \oplus \underset{\text{guess}}{\underbrace{k_8 }}\;) \boxplus ( (\;\underset{\text{known}}{\underbrace{x'_0}} \oplus \underset{\text{guess}}{\underbrace{k_0 }}\;) \oplus \underset{\text{known}}{\underbrace{x_{n-3}}} \;) ]_0 .\end{aligned}\] <p>$k_0$ê³¼ $k_8$ì„ ì˜³ê²Œ ì¶”ì¸¡í–ˆì„ ê²½ìš°, $z_0$ì´ ì˜³ê²Œ ê³„ì‚°ë¨</p> <p>â†’ $z_0$ê°€ $\tilde{y}$ì˜ ì„ í˜• ê²°í•©</p> <ul> <li>$z_0$ê°€ $\tilde{Y}$ì˜ ì—´ê³µê°„ì— ì†í•¨</li> <li>$H z_0 = 0$</li> </ul> <p>â‡’ $H z_0 \neq 0$ì´ë©´, $k_0$ë¥¼ ì˜ëª» ì¶”ì¸¡í–ˆë‹¤ê³  íŒë‹¨</p> <p>$z_0$ë¥¼ êµ¬í•˜ë©´ $z_1$ì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” carry $c_1 = \left[kâ€™_8 \boxplus w_0 \right]_1$ì´ ê³„ì‚°ë˜ë¯€ë¡œ,</p> \[z_1=Â  k'_9 \oplus w_1 \oplus c_1=Â  (\;\underset{\text{known}}{\underbrace{x'_9}} \oplusÂ \underset{\text{guess}}{\underbrace{k_9 }}\;) \oplusÂ ( (\;\underset{\text{known}}{\underbrace{x'_1}} \oplusÂ \underset{\text{guess}}{\underbrace{k_1 }}\;) \oplusÂ \underset{\text{known}}{\underbrace{x_{n-2}}} \;) \oplus c_1 .\] <p>ë¡œë¶€í„° $z_1$ì„ êµ¬í•  ìˆ˜ ìˆìŒ</p> <p>ë¹„ìŠ·í•˜ê²Œ $z_{n-1}$ê¹Œì§€ ë°˜ë³µí•˜ì—¬ ë¼ìš´ë“œ í‚¤ $k$ë¥¼ ë³µêµ¬</p> <ul> <li>í•œ ë¼ìš´ë“œì— ëŒ€í•˜ì—¬ í•´ë‹¹ ê³µê²©ì„ ìˆ˜í–‰í–ˆì„ ë•Œ, 4ê°œì˜ ë¼ìš´ë“œ í‚¤ í›„ë³´ë¥¼ ì–»ê²Œ ë˜ë©°, ë‹¤ìŒ ë¼ìš´ë“œì— ëŒ€í•œ ê³µê²©ì„ ìˆ˜í–‰í•˜ë©´ì„œ ì´ì „ ë¼ìš´ë“œì˜ í‚¤ í›„ë³´ë¥¼ í•˜ë‚˜ë¡œ íŠ¹ì •í•  ìˆ˜ ìˆìŒ</li> <li>ì–´ë–¤ $k_j, k_{j+8}$ì„ ì„ íƒí•´ë„ ëª¨ë‘ $M$ì˜ í–‰ê³µê°„ì— ì†í•  ìˆ˜ ìˆìŒ</li> </ul> <p>Speckì˜ ë§ˆìŠ¤í„° í‚¤ ê¸¸ì´ëŠ” $4n$ì´ë¯€ë¡œ 4ê°œ ë¼ìš´ë“œì˜ ë¼ìš´ë“œ í‚¤ë¥¼ ì°¾ìœ¼ë©´ ë§ˆìŠ¤í„° í‚¤ ë³µêµ¬ ê°€ëŠ¥</p> <p>â‡’ ì²« ë²ˆì§¸ë¶€í„° ë‹¤ì„¯ ë²ˆì§¸ ë¼ìš´ë“œê¹Œì§€ 5ê°œ ë¼ìš´ë“œì— ëŒ€í•˜ì—¬ ìœ„ ê³µê²© ê³¼ì •ì„ ìˆ˜í–‰í•˜ë©´ ë§ˆìŠ¤í„° í‚¤ ë³µêµ¬ ê°€ëŠ¥</p> <p>ë§ˆìŠ¤í„° í‚¤ë¥¼ ë³µêµ¬í•˜ì§€ ì•Šê³  ëª¨ë“  ë¼ìš´ë“œì— ëŒ€í•˜ì—¬ ë¼ìš´ë“œ í‚¤ë¥¼ êµ¬í•˜ëŠ” ê³µê²©ë„ ê°€ëŠ¥</p> <p><strong>ê³µê²©ì— í•„ìš”í•œ ì—°ì‚°ëŸ‰</strong>: ë¹„íŠ¸ ì—°ì‚° $O(n^6)$íšŒ, ì˜¤ë¼í´ í˜¸ì¶œ $O(n^2)$íšŒ</p> <ul> <li>output external encodingì´ ì—†ì„ ë•Œì™€ ë™ì¼</li> <li>ì˜¤ë¼í´ ì—°ì‚°ì´ ë‘ ë¼ìš´ë“œ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ, ì˜¤ë¼í´ í˜¸ì¶œ ì—°ì‚°ëŸ‰ ìì²´ê°€ ì´ì „ ê³µê²©ë³´ë‹¤ ë” í¼</li> </ul> <h1 id="birykovs-attack-1">Birykovâ€™s Attack</h1> <h2 id="black-box-decomposition-of-an-arx-round">Black-box Decomposition of an ARX Round</h2> <h3 id="affine-encoding">Affine encoding</h3> <p>I/O encodingì´ ëª¨ë‘ affineì¼ ë•Œ SEê°€ ì•„ë‹ˆì–´ë„ ì„±ë¦½í•˜ëŠ” ê³µê²© ê¸°ë²•</p> <p>ê³µê²© ëŒ€ìƒ: $\mathbb{O}=B\circ S\circ A$</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_2/affine_round_decompo_1.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="affine_round_decompo_1"/> </p> <p>ì „ëµ: $\mathbb{O}(x)=B\circ S\circ A(x)=z$ë¥¼ $\mathbb{O}(x,y)=(B\circ S\circ A(x),\ y)=(z,y)$ë¡œ ë°”ê¿ˆ</p> <p>ë¹„ì„ í˜• ì—°ì‚°ì€ $S$ì—ì„œë§Œ ì´ë¤„ì§€ê³ , ì„ í˜• ì—°ì‚°ë¶€ëŠ” encodingì— í¡ìˆ˜ì‹œí‚¬ ìˆ˜ ìˆìŒ</p> <p>ì„ í˜• ì—°ì‚°ë¶€ë¥¼ ì¡°ì •í•˜ì—¬ ë¹„ì„ í˜• ì—°ì‚°ì´ $z$ì—ë§Œ ì˜í–¥ì„ ë¯¸ì¹˜ë„ë¡ ì¡°ì •í•˜ë©´, ë¹„ì„ í˜• ì—°ì‚°ì€ $x\boxplus y\mapsto z$ë¡œë§Œ ì´ì–´ì§€ë©° $y\mapsto y$ì— ì˜í–¥ì´ ì—†ìŒ</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_2/image.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image"/> </p> <ol> <li> <p><strong>Locating linear bits</strong></p> <p><em>Encoding ë¶€ì—ì„œ ì„ í˜• ë¶€ë¶„ê³µê°„ì„ êµ¬ë³„í•¨ìœ¼ë¡œì¨ êµ¬ì¡°ë¥¼ ë‹¨ìˆœí™”í•˜ê³  ì¶”í›„ ìˆ˜í–‰ë  ê³µê²©ì´ ì ìš©ë  ë²”ìœ„ë¥¼ ì¶•ì†Œí•¨</em></p> <p><img src="/june.github.io/assets/img/post/arx_wbc_2/image_1.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image_1"/> </p> <p>ARX roundë¥¼ $S$-layerì— affine encoding $(A,B)$ë¥¼ ì¶”ê°€í•œ í˜•íƒœë¡œ ë³¼ ë•Œ, encodingì„ ì œì™¸í•œ ë¼ìš´ë“œ í•¨ìˆ˜ê°€ $S(x| y)=(x\boxplus y|y)$ë¼ëŠ” ì„±ì§ˆì„ í™œìš©í•¨</p> <p>$\mathbb{O}$ì˜ $A,B$ëŠ” affine mapì´ë¯€ë¡œ $S$ì˜ basis transformë§Œ ìˆ˜í–‰í•˜ëŠ” ê²ƒìœ¼ë¡œ ë³¼ ìˆ˜ ìˆìŒ</p> <p>â‡’ $n+1$ ê°œ ì„ í˜• ê´€ê³„ë¥¼ ì°¾ì•„ basis transformationì„ í†µí•´ ë¶„ì„í•˜ê¸° ì‰¬ìš´ êµ¬ì¡°ë¡œ ì „í™˜</p> <p>$x, y$ ì¡°ì •</p> <ul> <li>$x:\ (x_{n-1}, x_{n-2}, â€¦\,, x_{1}, {\color{red} x_0})\to (x_{n-1}, x_{n-2}, â€¦\,, x_{1})$</li> <li>$y:\ (y_{n-1}, y_{n-2}, â€¦\,, y_{0})\to ({\color{red}y_n=x_0\oplus y_0},\; y_{n-1}, y_{n-2}, â€¦\,, y_{0})$</li> <li>$c_1$ (unknown with $A$) $:\ carry(xâ€™_0, yâ€™_0)=carry({\color{red} yâ€™_n}\oplus yâ€™_0,\ yâ€™_0)$</li> </ul> <p>$\pi_x, \pi_z$: affine projection maps s.t.</p> \[\mathbb{O}'=\pi_z\circ\mathbb{O}\circ \pi_x^{-1}\] <p>(<em>ì¼ë°˜ì ìœ¼ë¡œ ì •ì˜í•˜ëŠ” projection $\pi:V^n\to V$ì™€ ë‹¤ë¦„</em> )</p> <p>Then,</p> \[\mathbb{O}=\pi_z^{-1}\circ\mathbb{O}' \circ \pi_x=(\pi_z^{-1}\circ B')\circ S\circ (A'\circ \pi_x)\] <p>ì´ë•Œ, $Aâ€™, Bâ€™$ì€ $\mathbb{O}â€™= Bâ€™\circ S\circ Aâ€™ =\pi_z\circ\mathbb{O}\circ \pi_x^{-1}$ê°€ ì„±ë¦½í•˜ëŠ” affine encoding</p> <ul> <li> <p>$\pi_x$ì˜ êµ¬ì¡°ë¥¼ ê³ ë ¤í•  ë•Œ ì—­í•¨ìˆ˜ê°€ ì¡´ì¬í•˜ì§€ ì•Šì§€ë§Œ, ì§ê´€ì  í‘œê¸°ë¥¼ ìœ„í•´ inverse í‘œê¸°í•¨</p> <p>ìˆœì°¨ì ìœ¼ë¡œ ì§„í–‰ë˜ëŠ” ê³µê²©ì— ëŒ€í•˜ì—¬ projection mapì˜ ì ìš©ê³¼ branchì˜ ë¶„ë¦¬ëŠ” 2ê°œì˜ layerë¡œ ë°”ë¼ë´ì•¼ í•¨. projection mapì— ë”°ë¥¸ $\mathbb{O}â€™$ì˜ í‘œí˜„ì€ ìˆ˜í•™ì ìœ¼ë¡œ ì—„ë°€í•˜ì§€ ì•Šìœ¼ë‚˜ ì•„ë˜ì™€ ê°™ì´ ì´í•´í•  ìˆ˜ ìˆìŒ</p> <p>$\pi_x, \pi_z$ì˜ ì˜ë¯¸</p> <p>Line 7 $B$: $V$ì˜ ì˜ê³µê°„ì„ ê¸°ì €ë¡œ ê°–ëŠ” ê³µê°„ì˜ í–‰ë ¬ í‘œí˜„</p> <ul> <li>ì„ í˜• ë¶€ë¶„ ê³µê°„ì˜ ê¸°ì € = non-linear part í•„í„°ë§</li> <li> <p>Line 6ì—ì„œ ëª¨ì€ ê·¸ë˜í”„ ìœ„ ì ë“¤ì´ ê³µí†µì ìœ¼ë¡œ ë§Œì¡±í•˜ëŠ” $n+1$ê°œì˜ ì„ í˜• ê´€ê³„ë¥¼ ì°¾ì•„ì•¼ í•¨</p> \[\ker(V)=\{ \lambda: V\circ \lambda =0 \}\\[1em] \dim(\ker V)=\underset{\dim V}{\underbrace{(2N+1)}}\;-\underset{(\text{rank} V)\,=\,(\# \text{ pivot columns})}{\underbrace{\;[\,2N+1-(n+1)\,]\;}}= \underset{\text{Nullity } V}{\underbrace{n+1}}\] </li> <li> <p>$V$ì˜ ì˜ê³µê°„: $V$ì˜ ëª¨ë“  í–‰ê³¼ ìˆ˜ì§, ì„ í˜• ì—°ì‚° ê²°ê³¼ = 0</p> \[\begin{aligned} \left&lt; \lambda_X, X \right&gt; \oplus \left&lt; \lambda_Z, Z \right&gt; \oplus \lambda_c &amp;= \left&lt; \left( \lambda_X \| \lambda_Z \| \lambda_c \right) ,\ \left( X \| Z \| 1 \right) \right&gt;\\ &amp;= 0 \end{aligned}\\[.5em] \implies \left( \lambda_X \| \lambda_Z \| \lambda_c \right) \perp \left( X \| Z \| 1 \right)\] </li> </ul> <p>ì¦‰,</p> \[x^{(i)}_{(1\times N)},\quad \mathbb{O}(x^{(i)})=y^{(i)}_{(1\times N)}, \quad {\pi_x^{(i)}}_{\!\!(N\times 1)}, \quad {\pi_z^{(i)}}_{\!\!(N\times 1)}\] <p>ì— ëŒ€í•˜ì—¬</p> \[\underset{\qquad\qquad\qquad\qquad\;\;\;(N+\epsilon)\times(2N+1)\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!}{\begin{pmatrix} x^{(1)} &amp; \mathbb{O}(x^{(1)}) &amp; 1\; \\[-.3em] \vdots &amp; \vdots &amp; \vdots\; \\[.2em] x^{(i)} &amp; \mathbb{O}(x^{(i)}) &amp; 1\; \\[-.3em] \vdots &amp; \vdots &amp; \vdots\; \\[.2em] x^{(N+\epsilon)} &amp; \mathbb{O}(x^{(N+\epsilon)}) &amp; 1\; \end{pmatrix}} \underset{\qquad\qquad\qquad\qquad(2N+1)\times(n+1)\!\!\!\!\!\!\!\!\!\!\!\!}{ \begin{pmatrix} \pi_x^{(1)} &amp; \!\!\!\!\cdots\!\!\!\! &amp; \pi_x^{(i)} &amp; \!\!\!\!\cdots\!\!\!\! &amp; \pi_x^{(n+1)} \\[1.3em] \pi_z^{(1)} &amp; \!\!\!\!\cdots\!\!\!\! &amp; \pi_z^{(i)} &amp; \!\!\!\!\cdots\!\!\!\! &amp; \pi_z^{(n+1)} \\[1.3em] c_y^{(1)} &amp; \!\!\!\!\cdots\!\!\!\! &amp; c_y^{(i)} &amp; \!\!\!\!\cdots\!\!\!\! &amp; c_y^{(n+1)} \end{pmatrix}} = \underset{\qquad\qquad\quad(N+\epsilon)\times(n+1)\!\!\!\!\!\!\!\!\!\!\!\!}{ \begin{pmatrix} 0 &amp; \!\!\!\cdots\!\!\! &amp; 0 &amp; \!\!\!\cdots\!\!\! &amp; 0 \\[-.5em] \vdots &amp; &amp; \vdots &amp; &amp; \vdots \\ 0 &amp; \!\!\!\cdots\!\!\! &amp; 0 &amp; \!\!\!\cdots\!\!\! &amp; 0 \\[-.5em] \vdots &amp; &amp; \vdots &amp; &amp; \vdots \\ 0 &amp; \!\!\!\cdots\!\!\! &amp; 0 &amp; \!\!\!\cdots\!\!\! &amp; 0 \end{pmatrix}}\] \[\begin{aligned} \pi^{(i)}_{x1} x^{(i)}_1 + \cdots + \pi^{(i)}_{xN} x^{(i)}_N \;&amp; + \; \pi^{(i)}_{z1} z^{(i)}_1 + \cdots + \pi^{(i)}_{zN} z^{(i)}_N + c_y^{(i)}=0 \\[1em] \pi^{(i)}_{x1} x^{(i)}_1 + \cdots + \pi^{(i)}_{xN} x^{(i)}_N \;&amp; = \; \pi^{(i)}_{z1} z^{(i)}_1 + \cdots + \pi^{(i)}_{zN} z^{(i)}_N + c_y^{(i)} \end{aligned} \\[1.5em] \qquad\implies x^{(i)}_{(1\times N)}{\pi_x^{(i)}}_{\!\!(N\times 1)} =\, y^{(i)}_{(1\times N)} {\pi_z^{(i)}}_{\!\!(N\times 1)} \;\;\left(\text{set }\pi_z^{(i)}\leftarrow \pi_z^{(i)}\oplus(0^{N-1}\|c_y^{(i)})\right)\] <p>ë‹¬ë¦¬ í‘œí˜„í•˜ë©´</p> \[\underset{\qquad\qquad(N+\epsilon)\times(2N+1)\!\!\!\!}{\begin{pmatrix} | &amp; | &amp; |\; \\[.2em] X^T &amp; \!\!(\mathbb{O}(X))^T\!\! &amp; 1\; \\[.1em] | &amp; | &amp; |\; \end{pmatrix}} \underset{\qquad(2N+1)\times(n+1)\!\!\!\!}{ \begin{pmatrix} - &amp; \!\!\pi_X^T\!\! &amp; - \\[1.3em] - &amp; \!\!\pi_Z^T\!\! &amp; - \\[1.3em] - &amp; \!\!c_Y^T\!\! &amp; - \end{pmatrix}} = X^T\pi_X^T +(\mathbb{O}(X))^T\pi_Z^T+c_Y^T=\vec 0\] \[X^T \pi_X^T =(\mathbb{O}(X))^T\pi_Z^T + c_Y^T\] \[\begin{aligned} \pi_X X &amp;= \pi_Z(\mathbb{O}(X)) \quad\left(\text{set }\pi_Z\leftarrow \pi_Z\oplus(0^{n-1}\|c_y^T)\right) \\[1em] \pi_X (X) &amp;= \pi_Z\circ \mathbb{O}(X) \\[1em] X = \pi_X\circ (\pi_X)^{-1} (X) &amp;= \pi_Z\circ \mathbb{O}\circ (\pi_X)^{-1} (X) \end{aligned}\] <p>$\mathbb{O}â€™$ì— ì˜í•´ right branch ì •ë ¬ì´ ì™„ë£Œëœ í›„ ë‚¨ì€ êµ¬ì¡°ë¡œ $y$ê°€ left branchì— ì˜í–¥ì„ ë¯¸ì¹˜ëŠ” ì˜ì—­ì€ ë‹¤ìŒê³¼ ê°™ìŒ</p> <ul> <li>$A\circ\pi_x$ <ul> <li>$Aâ€™$ì—ì„œ left branchë¡œ ì´ì–´ì§€ëŠ” ì—°ì‚° $A_1$</li> <li>$n+1$ë¹„íŠ¸ $y$ì˜ $n+1$ë²ˆì§¸ ë¹„íŠ¸ $x_0$ê³¼ $0$ë²ˆì§¸ ë¹„íŠ¸ $y_0$ì˜ ì¸ì½”ë”© í›„ ê°’ì¸ $x_0â€™, y_0â€™$ì— ëŒ€í•œ carry bit $c_1=carry(x_0â€™, y_0â€™)$</li> <li>$S$-layer ì—°ì‚°ì— ì‚¬ìš©ë  $n-1$ë¹„íŠ¸ $y=(y_{n-1},\,â€¦\,,y_2,y_1)$ì˜ ì¸ì½”ë”© í›„ ê°’ $A_2(y)$</li> </ul> </li> <li>$\pi_z\circ B$ <ul> <li>$Bâ€™$ì—ì„œ left branchë¡œ ì´ì–´ì§€ëŠ” ì—°ì‚° $A_3$</li> </ul> </li> </ul> <p>ë˜í•œ, ì •ë ¬ì´ ì™„ë£Œëœ í›„ $x$ì— ëŒ€í•œ ì¸ì½”ë”©ìœ¼ë¡œ $Aâ€™$ì—ì„œì˜ $B_1$ê³¼ $Bâ€™$ì—ì„œì˜ $B_2$ë¥¼ ê³ ë ¤í•´ì•¼ í•¨</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_2/affine_round_decompo_1_1.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="affine_round_decompo_1_1"/> </p> <p>Here, $A_1, A_2, A_3, B_1, B_2$ are unknown affine maps, $c_1$ is first carry bit of the original $n$-bit addition, expressible as $c_1(y) = \left&lt;\alpha, y\right&gt;\cdot\left&lt;\beta, y\right&gt;$ for some $\alpha, \beta\in\mathbb{F}_2^{n+1}$.</p> </li> </ul> <p>How to find $\pi_x, \pi_z$?</p> <p><strong>Algorithm 1: Recovering input/output matching affine subspaces</strong></p> <ul> <li><strong>Input:</strong> oracle $\mathbb{O}$ implementing bijective modular addition with affine encodings</li> <li><strong>Output:</strong> affine maps $\pi_X, \pi_Z$ such that $\mathbb{O}â€™ = \pi_z \circ \mathbb{O} \circ \pi_x^{-1}$ is such that $\mathbb{O}â€™(x|y) = (z|y)$ for all $(x, y) \in \mathbb{F}_2^{n-1} \times \mathbb{F}_2^{n+1}$, with $z \in \mathbb{F}_2^{n-1}$ <ol> <li><strong>for</strong> $i \in {0, \dots, N + \epsilon - 1}$ <strong>do</strong> <code class="language-plaintext highlighter-rouge">N+eê°œ ì…ì¶œë ¥ ìŒì— ëŒ€í•˜ì—¬</code></li> <li>$\quad x^{(i)} \xleftarrow{$} \mathbb{F}_2^N$ <code class="language-plaintext highlighter-rouge">Në¹„íŠ¸ ì˜¤ë¼í´ ì…ë ¥ x ìƒì„±</code></li> <li>$\quad y^{(i)} \leftarrow \mathbb{O}(x^{(i)})$ <code class="language-plaintext highlighter-rouge">ì˜¤ë¼í´ ì¶œë ¥ y ìƒì„±</code></li> <li>$\quad v^{(i)} \leftarrow (x^{(i)} | y^{(i)} | 1)$ <code class="language-plaintext highlighter-rouge">ê·¸ë˜í”„ ìœ„ì˜ ì  (x,y)ë¡œ ë³¼ ìˆ˜ ìˆìŒ</code></li> <li><strong>end for</strong></li> <li>$V \leftarrow$ matrix with rows ${v^{(i)}}_i$ <code class="language-plaintext highlighter-rouge">ê° í–‰ ë²¡í„°ê°€ vì¸ í–‰ë ¬ V êµ¬ì„±</code></li> <li>$B \leftarrow \text{basis}(\ker V)$ so that $V \times B = 0$ <code class="language-plaintext highlighter-rouge">ker Vê°€ basisì¸ B ìƒì„±</code></li> <li>$(\pi_x, \pi_z, c_y) \leftarrow B^T$, where $\pi_x, \pi_z \in \mathbb{F}_2^{(n+1) \times N}$, $c_y \in \mathbb{F}_2^{(n+1) \times 1}$ <code class="language-plaintext highlighter-rouge">ê° í–‰ì´ mapì´ ë˜ë„ë¡ transpose B ê³„ì‚°</code></li> <li><strong>return</strong> $\pi_x, \pi_z\leftarrow \pi_z\oplus(0^{n-1} | c_y^T)$ <code class="language-plaintext highlighter-rouge">affine map ìƒìˆ˜í•­ì„ ë³´ì •í•œ zì˜ affine mapì„ pi_zë¡œ ë°˜í™˜</code></li> </ol> </li> </ul> <p>êµ¬í•˜ë ¤ëŠ” projection mapì€ $n-1$ë¹„íŠ¸ $x$ì™€ $n+1$ë¹„íŠ¸ $y$ë¥¼ $n+1$ë¹„íŠ¸ $y$ë¡œ ë³´ë‚´ëŠ” mapì´ë¯€ë¡œ $\pi:\mathbb{F}_2^{N}\to \mathbb{F}_2^{n+1}$ì¼ ê²ƒì„ ê¸°ëŒ€í•  ìˆ˜ ìˆìœ¼ë©° $\mathbb{O}$ì˜ $S$-layerë¥¼ êµ¬ì„±í•œ ë¹„ì„ í˜• ì—°ì‚°ì€ $\ker V$ì— ì†í•´ ë‚˜íƒ€ë‚˜ì§€ ì•Šê²Œ ë  ê²ƒìœ¼ë¡œ ì˜ˆìƒí•  ìˆ˜ ìˆìŒ</p> </li> <li> <p><strong>Triangularization of the outer affine maps (left branches)</strong></p> <p><strong>Proposition 3.</strong> Let $\Delta x = (\dots \parallel 0^k), \Delta y = 0^n$. Let $Z$ denote the set of all possible output differences $\Delta z$ of $z = x \boxplus y$. Then, $\text{rank } Z \leq n - k$. Furthermore, if $\text{rank } Z = n - k$, then $(\Delta x)_k = (\Delta z)_k = 1$, i.e., $\Delta x$ and $\Delta z$ both have shape $(\dots \parallel 1 \parallel 0^k)$.</p> <p>Explain) Let $\Delta x_i = x_i \oplus xâ€™_i,\ \Delta y_i = y_i \oplus yâ€™_i=0$. Then, $\Delta z_i = (x_i \boxplus y_i)\oplus (xâ€™_i \boxplus yâ€™_i)$</p> \[\begin{aligned} \Delta z_i &amp; =(x_{i,n-1}\oplus y_{i,n-1}\oplus c_{i,n-1},..., x_{i,0}\oplus y_{i,0}\oplus c_{i,0})\\&amp; \qquad\oplus(x'_{i,n-1}\oplus y'_{i,n-1}\oplus c'_{i,n-1},..., x'_{i,0}\oplus y'_{i,0}\oplus c'_{i,0})\\&amp; =(x_{i,n-1}\oplus x'_{i,n-1}\oplus c_{i,n-1}\oplus c'_{i,n-1},\;...\,, \;x_{i,0}\oplus x'_{i,0}\oplus c_{i,0}\oplus c'_{i,0})\\&amp; =(\Delta x_{i,n-1}\oplus \Delta c_{i,n-1},\;...\,, \;\Delta x_{i,0}\oplus \Delta c_{i,0})\qquad\footnotesize(\text{Let }\Delta c_{i,j}= c_{i,j}\oplus c'_{i,j}) \end{aligned}\] <p>Assume that $\Delta x_{i,j}\neq 1$ (i.e., $\Delta x_{i,j}=0$).</p> <p>Because $\Delta x_{i,j-1}=0, \Delta y_{i,j-1}=0$ implies $(x_{i,j-1}\boxplus y_{i,j-1}) = (xâ€™<em>{i,j-1}\boxplus yâ€™</em>{i,j-1})$,</p> <p>$\Delta c_{i,j}=0$,</p> <p>Then, $\Delta z_{i,j}=0 \implies \text{rank } Z$ canâ€™t be $n-k$.</p> <p>$\therefore$ If $\text{rank }Z=n-k$ then $\Delta x_{i,k}=1$ and also $\Delta z_{i,k}=1$</p> <p><strong>Algorithm 2: Triangularization of the outer maps on the left branch</strong></p> <ul> <li><strong>Input:</strong> oracle $\mathbb{O}$ implementing bijective modular addition with partially recovered affine encodings (Subsection 6.1)</li> <li> <p><strong>Output:</strong> affine maps $\pi_x, \pi_z$ such that $\mathbb{O}â€™ = \pi_z \circ \mathbb{O} \circ \pi_x^{-1}$ matches structure from Figure with lower triangular $T_1, T_2$</p> <p><img src="/june.github.io/assets/img/post/arx_wbc_2/image_2.png" style="max-width: 40%; height: auto; display: block; margin: 0 auto;" alt="image_2"/> </p> </li> <li><strong>Complexity:</strong> $\mathcal{O}(n^2)$ queries, $\mathcal{O}(n^4)$ time <ol> <li>$\mathbb{O}_0 \leftarrow \mathbb{O}$</li> <li><strong>for</strong> $k \in {0, \dots, n - 2}$ <strong>do</strong></li> <li><strong>repeat</strong> <code class="language-plaintext highlighter-rouge">try n+e time</code></li> <li>$\quad \quad \Delta x \overset{$}{\leftarrow} (*^{n-1-k} \parallel 0^{n+1+k})$</li> <li>$\quad \quad Z \leftarrow { \Delta \mathbb{O}_k (\Delta x) \mid n + \epsilon \text{ times} }$</li> <li> <p><strong>until</strong> $\text{rank } Z = n - 1 - k$</p> <p><code class="language-plaintext highlighter-rouge">It is sufficient to query each of n-1-k unit differences</code></p> </li> <li>solve $Z \times \alpha = (1, \dots, 1)^T$ for $\alpha = (*^{n-1-k} \parallel 0^{n+1+k})$</li> <li> <p>$\quad \pi_z \leftarrow$ a linear map such that</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $(\pi_z(z))_{n+1+k} = \langle \alpha, z \rangle, (\pi_z(z))_i = z_i$ for $i &gt; n + 1 + k$
</code></pre></div> </div> </li> <li>$\quad \beta \leftarrow (\pi_z(\Delta \mathbb{O}<em>k(e_i))</em>{n+1+k} \mid n + 1 + k \leq i &lt; 2n) \parallel 0^{n+1+k}$</li> <li> <p>$\quad \pi_x \leftarrow$ a linear map such that</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $(\pi_x(x))_{n+1+k} = \langle \beta, x \rangle, (\pi_x(x))_i = x_i$ for $i &gt; n + 1 + k$
</code></pre></div> </div> </li> <li>$\quad \mathbb{O}_{k+1} \leftarrow \pi_z \circ \mathbb{O} \circ \pi_x^{-1}$</li> <li><strong>end for</strong></li> <li><strong>return</strong> $\mathbb{O}_{n-1}$</li> </ol> </li> </ul> </li> </ol> <h3 id="sparse-quadratic-affine-encoding">Sparse Quadratic-Affine encoding</h3>]]></content><author><name></name></author><category term="Tool"/><category term="Windows"/><category term="Tool"/><category term="VScode"/><summary type="html"><![CDATA[Windowsì—ì„œ VS code ì»´íŒŒì¼ í™˜ê²½ êµ¬ì¶•]]></summary></entry></feed>