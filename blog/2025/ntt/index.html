<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="n8dLJYW35x7DJL8Qm6jd505pT0eW3ucsWsW4_GaH3MA"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> NTT | June </title> <meta name="author" content="Jieun Ryu"> <meta name="description" content="NTT(Number Theoretic Transform) for ML-KEM, ML-DSA"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; media-src 'self' https:; frame-src 'self' https:; connect-src 'self' https:;"> <link rel="stylesheet" href="/june.github.io/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/june.github.io/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/june.github.io/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/june.github.io/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/june.github.io/assets/img/whale.png?v=169c6de4639e20133f0d09309d538e58"> <link rel="stylesheet" href="/june.github.io/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://ryuj1eun.github.io/june.github.io/blog/2025/ntt/"> <script src="/june.github.io/assets/js/theme.js?v=5fea5159b787642c1bbc1f334d60f883"></script> <link defer rel="stylesheet" href="/june.github.io/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/june.github.io/"> June </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/june.github.io/">ABOUT </a> </li> <li class="nav-item active"> <a class="nav-link" href="/june.github.io/blog/">BLOG </a> </li> <li class="nav-item "> <a class="nav-link" href="/june.github.io/til/">TIL </a> </li> <li class="nav-item "> <a class="nav-link" href="/june.github.io/publications/">PUBLICATIONS </a> </li> <li class="nav-item "> <a class="nav-link" href="/june.github.io/cv/">CV </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">SUB </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/june.github.io/books/">Books</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/june.github.io/projects/">Exhibitions</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="fa-solid fa-magnifying-glass"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-half-sun-moon" id="light-toggle-system"></i> <i class="fa-solid fa-moon" id="light-toggle-dark"></i> <i class="fa-solid fa-sun" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">NTT</h1> <p class="post-meta"> Created on December 12, 2025 </p> <p class="post-tags"> <a href="/june.github.io/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a> Â  Â· Â  <a href="/june.github.io/blog/tag/math"> <i class="fa-solid fa-hashtag fa-sm"></i> MATH</a> Â  <a href="/june.github.io/blog/tag/pqc"> <i class="fa-solid fa-hashtag fa-sm"></i> PQC</a> Â  <a href="/june.github.io/blog/tag/cryptography"> <i class="fa-solid fa-hashtag fa-sm"></i> Cryptography</a> Â  Â· Â  <a href="/june.github.io/blog/category/study"> <i class="fa-solid fa-tag fa-sm"></i> Study</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>ğŸ“š <strong>[MAIN]</strong> Liang, Zhichuang, and Yunlei Zhao. â€œNumber theoretic transform and its applications in lattice-based cryptosystems: A survey.â€Â <em>arXiv preprint arXiv:2211.13546</em>Â (2022).<br> ğŸ“š <strong>[Sub 1]</strong> Pollard, John M. â€œThe fast Fourier transform in a finite field.â€Â <em>Mathematics of computation</em>Â 25.114 (1971): 365-374.<br> ğŸ“š <strong>[Sub 2]</strong> Agarwal, Ramesh C., and C. Sidney Burrus. â€œNumber theoretic transforms to implement fast digital convolution.â€Â <em>Proceedings of the IEEE</em>Â 63.4 (2005): 550-560.<br> ğŸ“š <strong>[Sub 3]</strong> FÃ¼rer, Martin. â€œFaster integer multiplication.â€Â <em>Proceedings of the thirty-ninth annual ACM symposium on Theory of computing</em>. 2007.<br> ğŸ“š <strong>[Sub 4]</strong> Fraleigh, John B.Â <em>A first course in abstract algebra</em>. Pearson Education India, 2003.</p> <hr> <h3 id="preliminaries">PRELIMINARIES</h3> <h4 id="notations-and-definitions">Notations and Definitions</h4> <ul> <li>$\Z$: the ring of rational integers</li> <li>$n$, $q$: some positive integers</li> <li>$\mathbb{Z}_q\cong{0, 1,\ â€¦\, ,\ q âˆ’ 1}$</li> <li>$xâ€™ \equiv x \pmod ğ‘$: $q\mid (xâ€™ âˆ’ x)$</li> <li>$xâ€™ = x \pmod q$: $xâ€™$ is the unique element in $\mathbb{Z}_ğ‘$ satisfying $ğ‘¥â€™ \equiv ğ‘¥ \pmod ğ‘$</li> <li>$\bf a$, $a(x)$: polynomials</li> <li>$\bf r=a\mod b$: ğ’“ is the polynomial remainder of ğ’‚ divided by ğ’ƒ</li> <li>For any $n_1,n_2\in\Z$, $n_1 &gt; n_2$ and any $a_i$, $\sum_{j=n_1}^{n_2} a_i = 0$</li> <li>$\circ$: point-wise multiplication</li> </ul> <h5 id="def-bitreversal">Def) Bitreversal</h5> <p>Let $n$ be a power of two, and</p> <p>$b$ be a non-negative integer satisfying $b&lt;n$.</p> <p>The bitreversal of $b$ with respect to $n$ is defined as</p> \[{\rm brv}_n (b_{\log_{n-1}}2^{\log n-1} + \cdots + b_1 2 + b_0) = b_0 2^{\log n-1} + \cdots + b_{\log_{n-2}}2 + b_{\log_{n-1}},\] <p>where $b_i$ is the $i$-th bit of the binary expansion of $b$ .</p> <h5 id="def-primitive-and-principal-root-of-unity">Def) Primitive and Principal Root of Unity</h5> <p>The elements of the set $U_{k}=\left{ \psi\in\mathbb{C} \mid \psi^k=1 \right}$ are called the $k$-th roots of unity.</p> <p>Let $R$ be a commutative ring with multiplicative identity 1,</p> <p>$k$ be a positive integer, and</p> <p>$\psi(\neq1)$ be an element in $R$.</p> <p>Define $\psi$ is the primitive $k$-th root of unity in $R$</p> <p>$\iff$ $\psi^k=1$, and $\psi^i\neq 1,\; i=1,2,\ â€¦\,,\ k-1$.</p> <p>(i.e., $k$ is the least positive integer s.t. $\psi^k = 1$)</p> <p>Define $\psi$ is the principal $k$-th root of unity in $R$</p> <p>$\iff$ $\psi^k = 1$, and $\sum_{j=0}^{k-1}\psi^{jl}=0,\; l=1,2,\ â€¦\,,\ k-1$.</p> <p>Notice that primitive and principal $ğ‘˜$-th root of unity coincide if $R = \mathbb{Z}_q$ where $q$ is a prime number.</p> <ul> <li> <strong>Coincide if $R=\mathbb{Z}_q$</strong> <ol> <li> <p>Primitive â‡’ Principal</p> <p>$\mathbb{Z}_q$ì˜ primitive $k$-th root of unity $\psi$ê°€ ì¡´ì¬í•˜ë©´, $\psi$ëŠ” $\mathbb{Z}_q$ì˜ principal $k$-th root of unityì´ë‹¤.</p> <p>pf ) $\psi$ê°€ primitive $k$-th root of unityì´ë¯€ë¡œ</p> <p>$\psi^k\equiv 1\bmod q$ì´ê³ , ëª¨ë“  $i=1,2,\, â€¦\,,k-1$ì— ëŒ€í•˜ì—¬ $\psi^i\neq 1$ì´ë‹¤.</p> <p>ì¦‰, ëª¨ë“  $l=1,2,\,â€¦\,,k-1$ì— ëŒ€í•´ $\psi^l -1\neq0$ì´ë¯€ë¡œ</p> \[\sum_{j=0}^{k-1} \psi^{jl} = \frac{(\psi^l)^k - 1}{\psi^l-1} = \frac{(\psi^k)^l - 1}{\psi^l-1} = \frac{(1)^k - 1}{\psi^l-1} = 0\] <p>ì´ë‹¤.</p> <p>$\psi^k\equiv 1\bmod q$ì´ê³ , ëª¨ë“  $l=1,2,\,â€¦\,,k-1$ì— ëŒ€í•´ $\sum_{j=0}^{k-1} \psi^{jl}=0$ì´ë¯€ë¡œ</p> <p>$\psi$ëŠ” principal $k$-th root of unityì´ë‹¤.</p> </li> <li> <p>Principal â‡’ Primitive</p> <p>$\mathbb{Z}_q$ì˜ principal $k$-th root of unity $\psi$ê°€ ì¡´ì¬í•˜ë©´, $\psi$ëŠ” $\mathbb{Z}_q$ì˜ primitive $k$-th root of unityì´ë‹¤.</p> <p>pf ) $\psi$ê°€ $\mathbb{Z}_q$ì˜ principal $k$-th root of unityì¼ ë•Œ,</p> <p>ì–´ë–¤ $l\in{1,2,\,â€¦\,,k-1}$ì— ëŒ€í•˜ì—¬ $\psi^l=1$ì´ë¼ê³  ê°€ì •í•˜ì.</p> <p>ì´ $l$ì— ëŒ€í•´</p> \[\sum_{j=0}^{k-1}\psi^{jl} = (\psi^l)^0 + (\psi^l)^1 + \cdots + (\psi^l)^{k-1}= 1+1+\cdots+1=k\neq0\pmod q\] <p>ì´ë‹¤. ($k\mid (q-1)$ì´ì–´ì•¼ í•˜ë¯€ë¡œ $k &lt; q$) ì´ëŠ” $\psi$ê°€ principal $k$-th root of unityë¼ëŠ” ê°€ì •ì— ëª¨ìˆœì´ë¯€ë¡œ $\psi$ëŠ” ëª¨ë“  $l=1,2,\,â€¦\,,k-1$ì— ëŒ€í•´ $\psi^j\neq 1$ì´ë‹¤. ëª¨ë“  $j=1,2,\,â€¦\,,k-1$ì— ëŒ€í•˜ì—¬ $\psi^j\neq 1$ì´ê³ , $\psi^k\equiv 1\bmod q,\ \psi\neq 1$ì´ë¯€ë¡œ $\psi$ëŠ” principal $k$-th root of unityì´ë‹¤.</p> </li> </ol> </li> <li> <p>Example</p> <p>$\mathbb{Z}_5$ì—ì„œ $a^i$ Table</p> <table> <thead> <tr> <th>$\psi$ $\setminus$ $i$</th> <th>0</th> <th>1</th> <th>2</th> <th>3</th> <th>4</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> </tr> <tr> <td>2</td> <td>1</td> <td><strong>2</strong></td> <td><strong>4</strong></td> <td><strong>8=3</strong></td> <td><strong>6=1</strong></td> </tr> <tr> <td>3</td> <td>1</td> <td><strong>3</strong></td> <td><strong>9=4</strong></td> <td><strong>12=2</strong></td> <td><strong>6=1</strong></td> </tr> <tr> <td>4</td> <td>1</td> <td>4</td> <td>16=1</td> <td>4</td> <td>16=1</td> </tr> </tbody> </table> <p>2, 3 are primitive 4-th roots of unity in $\mathbb{Z}_5$</p> <table> <thead> <tr> <th>$\psi$</th> <th>$\sum_{j=0}^3 a^j$</th> <th>$\sum_{j=0}^3 a^{2j}$</th> <th>$\sum_{j=0}^3 a^{3j}$</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>4</td> <td>4</td> <td>4</td> </tr> <tr> <td>2</td> <td><strong>0</strong></td> <td><strong>0</strong></td> <td><strong>0</strong></td> </tr> <tr> <td>3</td> <td><strong>0</strong></td> <td><strong>0</strong></td> <td><strong>0</strong></td> </tr> <tr> <td>4</td> <td>0</td> <td>4</td> <td>0</td> </tr> </tbody> </table> <p>2, 3 are principal 4-th roots of unity in $\mathbb{Z}_5$</p> <p>â†’ primitive and principal 4-th roots of unity coincide in $\mathbb{Z}_5$</p> </li> </ul> <h4 id="polynomial-rings">Polynomial Rings</h4> <p>Let $\Z[x]$ and $\mathbb{Z}_q[x]$ be the polynomial rings over $\Z$ and $\mathbb{Z}_q$ respectively, with corresponding quotient rings $\Z[x]/!\left&lt;\phi(x)\right&gt;$ and $\mathbb{Z}_q[x]/!\left&lt;\phi(x)\right&gt;$, where $\phi(x)$ is a polynomial with integer coefficients.</p> <ul> <li> <p>Preliminary</p> <p><strong>Def)</strong> zero of $f(x)$</p> <p>Let $F$ be a subfield of a field $E$, and let $\alpha$ be an element of $E$.</p> <p>Let $f(x)=a_0 + a_1 x +\cdots+a_n x^n$ be in $F[x]$, and let $\phi_\alpha:F[x]\to E$ be the evaluation homomorphism.</p> <p>Let $f(\alpha)$ denote</p> \[\phi_\alpha(f(x))=a_0+a_1\alpha+\cdots+a_n\alpha^n.\] <p>If $f(\alpha)=0$, then $\alpha$ is a zero of $f(x)$.</p> <p><strong>Def)</strong> factor of $f(x)$</p> <p>An element $a\in F$ is a zero of $f(x)\in F[x]$ if and only if $x-a$ is a factor of $f(x)$ in $F[x]$.</p> <p><strong>Thm)</strong> Eisenstein Criterion</p> <p>Let $q\in\Z$ be a prime.</p> <p>Suppose that $f(x)=a_nx ^n +\cdots+a_0$ is in $\Z[x]$, and $a_n\neq 0\pmod q$, but $a_i=0\pmod q$ for all $i&lt;n$, with $a_0\neq 0\pmod {q^2}$.</p> <p>Then $f(x)$ is irreducible over $\mathbb{Q}$.</p> </li> </ul> <p>Especially, $\phi(x)$ is chosen to be a cyclotomic polynomial.</p> <ul> <li> <p>Preliminary</p> <p><strong>Cor)</strong> The polynomial</p> \[\phi_p(x)=\frac{x^p -1}{x-1}=x^{p-1}+\cdots+x+1\] <p>is irreducible over $\mathbb{Q}$ for any prime $p$.</p> <p>The polynomial $\phi_p(x)$ is the $p$-th cyclotomic polynomial.</p> <p>$n$-th cyclotomic polynomial $\phi_n(x)$ëŠ” 1ì˜ primitive $n$-th roots of unityë“¤ë§Œì„ ê·¼ìœ¼ë¡œ ê°–ëŠ” ë‹¤í•­ì‹ì´ë‹¤.</p> \[\phi_n(x)=\prod_{1\le k&lt;n,\\[1em] \gcd(k,n)=1}(x-e^{2\pi ki/n})\] <p>$p$ê°€ ì†Œìˆ˜ì¼ ë•Œ, ë°©ì •ì‹ $x^p -1=0$ì€ ë³µì†Œí‰ë©´ ìœ„ì—ì„œ ì´ $p$ê°œì˜ í•´ë¥¼ ê°€ì§„ë‹¤. $p$ê°œì˜ ê·¼ì„ $\zeta_k$ë¼ê³  í•˜ë©´</p> \[\zeta_k=e^{2\pi ki/n}\quad(k=0,1,\,...\,,p-1)\] <p>ì´ê³ , $k=0$ì¼ ë•Œ $\zeta_0 = 1$ì´ë‹¤. ì´ëŠ” orderê°€ 1ì´ë¯€ë¡œ primitive $p$-th roots of unityê°€ ì•„ë‹ˆë‹¤.</p> <p>$k\neq 0$ì¸ ê²½ìš°, $p$ê°€ primeì´ë¯€ë¡œ, 1ë³´ë‹¤ í¬ê³  $p$ë³´ë‹¤ ì‘ì€ ëª¨ë“  $k$ëŠ” $\gcd(k,p)=1$ì„ ë§Œì¡±í•œë‹¤. ë”°ë¼ì„œ, 1ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ $p-1$ê°œì˜ ê·¼ì€ ëª¨ë‘ order=$p$ì¸ primitive roots of unityì´ë‹¤.</p> <p>ë”°ë¼ì„œ</p> \[x^p -1=\prod_{k=0}^{p-1}(x-\zeta_k)=(x-1)\prod_{k=1}^{p-1}(x-\zeta_k)\] <p>ì´ê³ , ì •ì˜ì— ë”°ë¼</p> \[\prod_{k=1}^{p-1}(x-\zeta_k) = (x^p -1)/(x-1)\] <p>ì€ cyclotomic polynomialì´ ëœë‹¤.</p> </li> </ul> <p>If $\deg \phi(x)=n$ holds, the element in $\mathbb{Z}<em>q[x]/!\left&lt;\phi(x)\right&gt;$, for example, $\boldsymbol a$, can be represented in the form of $\boldsymbol{a}=\sum</em>{i=0}^{n-1}a_i x^i$, or in the form of $\boldsymbol{a}=(a_0, a_1, \,â€¦\,,a_{n-1})$<code class="language-plaintext highlighter-rouge">vector space over Zq</code>, where $a_i\in\mathbb{Z}_q$.</p> <p>Main target rings are $\mathbb{Z}_q[x]/(x^n-1)$ and $\mathbb{Z}_q[x]/(x^n+1)$, since they are widely used in lattice-based schemes.</p> <p>Let $n$ be a power of two, then $x^n +1$ is the $2n$-th cyclotomic polynomial.</p> <ul> <li>$n=2^k$ì¼ ë•Œ, $\phi_{2n}(x)=x^n +1$ ì¦ëª… <ol> <li> <p>ì‚¬ì „ ì¦ëª…</p> \[x^n - 1 = \prod_{d \mid n} \Phi_d(x)\] <p>ì´ë¯€ë¡œ, ì†Œìˆ˜ $p$ì™€ ìì—°ìˆ˜ $r \ge 1$ì— ëŒ€í•´ $n = p^r$ì¼ ë•Œ, ì•½ìˆ˜ë“¤ì€ $1, p, p^2, \cdots, p^r$ì´ê³ </p> \[x^{p^r} - 1 = \prod_{j=0}^{r} \Phi_{p^j}(x) = \Phi_{p^r}(x) \cdot \prod_{j=0}^{r-1} \Phi_{p^j}(x) = \Phi_{p^r}(x) (x^{p^{r-1}} - 1)\] <p>ì´ë¯€ë¡œ</p> \[\Phi_{p^r}(x) = \frac{x^{p^r} - 1}{x^{p^{r-1}} - 1}\] <p>ì´ë‹¤.</p> <p>í•œí¸,</p> \[\Phi_p(y) = \frac{y^p - 1}{y - 1}\] <p>ì´ë¯€ë¡œ $y=x^{p^{r-1}}$ë¥¼ ëŒ€ì…í•˜ë©´</p> \[\Phi_p(x^{p^{r-1}}) = \frac{(x^{p^{r-1}})^p - 1}{x^{p^{r-1}} - 1} = \frac{x^{p^r} - 1}{x^{p^{r-1}} - 1}\] <p>ì´ë‹¤. ë”°ë¼ì„œ</p> \[\Phi_{p^r}(x) = \Phi_p(x^{p^{r-1}})\] <p>ì´ë‹¤. ì¦‰, $p^r$-th cyclotomic polynomialì€ $p$-th cyclotomic polynomialì˜ ë³€ìˆ˜ì— $x^{p^{r-1}}$ì„ ëŒ€ì…í•œ ê²ƒê³¼ ê°™ë‹¤.</p> </li> <li> <p>ë³¸ ì¦ëª…</p> <p>$n=2^k$ì´ë¯€ë¡œ ($k \ge 0$)</p> \[\Phi_{2n}(x) = \Phi_{2^{k+1}}(x) = \Phi_2(x^{2^{(k+1)-1}}) = \Phi_2(x^{2^k})\] <p>ì´ë‹¤.</p> <p>2-th cyclotomic polynomialì€</p> \[\Phi_2(y) = \frac{y^2-1}{y-1} = y+1\] <p>ì´ë¯€ë¡œ, $y$ì— $x^{2^k}=x^n$ë¥¼ ëŒ€ì…í•˜ë©´</p> \[\Phi_{2n}(x) = \Phi_2(x^{2^k}) = \Phi_2(x^n) = x^n + 1\] <p>ì´ë‹¤.</p> <p>ê²°ê³¼ì ìœ¼ë¡œ $2n=2^{k+1}$-th cyclotomic polynomialì€ $x^n +1$ì´ë‹¤.</p> </li> </ol> </li> </ul> <h4 id="crt-for-the-polynomial-ring">CRT for the Polynomial Ring</h4> <h5 id="theorem">Theorem</h5> <p>$f_1(x), f_2(x), \dots, f_k(x)$ê°€ $F[x]$ì˜ ì›ì†Œì´ê³ ,</p> <p>ëª¨ë“  $i \neq j$ì— ëŒ€í•´ $\gcd(f_i(x), f_j(x)) = 1$ì´ë¼ê³  ê°€ì •í•˜ì.</p> <ul> <li> <p>$f(x) = f_1(x)f_2(x)\cdots f_k(x)$ ë¼ê³  í•  ë•Œ, ë‹¤ìŒ ring Isomorphismì´ ì„±ë¦½í•œë‹¤.</p> <p>ë‘ ring $(R, +, \cdot)$ê³¼ $(S, \oplus, \odot)$ ì‚¬ì´ì— í•¨ìˆ˜ $\phi : R \to S$ê°€ ì¡´ì¬í•˜ê³ , ë‹¤ìŒ ì„¸ ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ $\phi$ë¥¼ Ring Isomorphismì´ë¼ê³  í•œë‹¤.</p> <ol> <li> <p><strong>ì „ë‹¨ì‚¬(Bijective):</strong></p> <p>$\phi$ëŠ” ì¼ëŒ€ì¼ ëŒ€ì‘(One-to-one correspondence)ì´ì–´ì•¼ í•œë‹¤.</p> <p>ì¦‰, ë‹¨ì‚¬(Injective)ì´ë©´ì„œ ì „ì‚¬(Surjective)ì—¬ì•¼ í•œë‹¤. (1-1, onto)</p> </li> <li> <p><strong>ë§ì…ˆ ë³´ì¡´ (Homomorphism - Additive):</strong></p> <p>ì„ì˜ì˜ $a, b \in R$ì— ëŒ€í•´, $\phi(a + b) = \phi(a) \oplus \phi(b)$</p> </li> <li> <p><strong>ê³±ì…ˆ ë³´ì¡´ (Homomorphism - Multiplicative):</strong></p> <p>ì„ì˜ì˜ $a, b \in R$ì— ëŒ€í•´, $\phi(a \cdot b) = \phi(a) \odot \phi(b)$</p> </li> </ol> </li> </ul> \[F[x] / \langle f(x) \rangle \;\cong\; F[x] / \langle f_1(x) \rangle \times F[x] / \langle f_2(x) \rangle \times \dots \times F[x] / \langle f_k(x) \rangle\] <p>ì´ëŠ” ì„ì˜ì˜ ë‹¤í•­ì‹ $a_1(x), \dots, a_k(x)$ê°€ ì£¼ì–´ì¡Œì„ ë•Œ,</p> <p>ë‹¤ìŒ ì—°ë¦½ í•©ë™ì‹ì„ ë§Œì¡±í•˜ëŠ” ë‹¤í•­ì‹ $A(x)$ê°€ modulus $f(x)$ì— ëŒ€í•´ ìœ ì¼í•˜ê²Œ ì¡´ì¬í•¨ì„ ì˜ë¯¸í•œë‹¤.</p> \[\begin{aligned} A(x) &amp;\equiv a_1(x) \pmod{f_1(x)} \\ A(x) &amp;\equiv a_2(x) \pmod{f_2(x)} \\ &amp;\vdots \\ A(x) &amp;\equiv a_k(x) \pmod{f_k(x)} \end{aligned}\] <h5 id="proof">Proof</h5> <ol> <li>map ì •ì˜</li> <li>Homomorphism</li> <li>Injective</li> <li> <p>Surjective</p> </li> <li> <p><strong>Define the Map</strong></p> <p>í•¨ìˆ˜ $\phi : F[x] \to F[x] / \langle f_1(x) \rangle \times \dots \times F[x] / \langle f_k(x) \rangle$ ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•œë‹¤.</p> \[\phi(h(x)) = (h(x) \,\bmod{f_1(x)},\; \dots,\; h(x) \,\bmod{f_k(x)})\] </li> <li> <p><strong>Homomorphsim</strong></p> <p>ì´ í•¨ìˆ˜ $\phi$ëŠ” ë‹¤í•­ì‹ì˜ ë§ì…ˆê³¼ ê³±ì…ˆì„ ë³´ì¡´í•˜ë¯€ë¡œ Ring Homomorphism(ë§ì…ˆ ë³´ì¡´, ê³±ì…ˆ ë³´ì¡´, indentity ë³´ì¡´)ì´ë‹¤.</p> </li> <li> <p><strong>Injective:</strong></p> <p>ì´ í•¨ìˆ˜ê°€ ë‹¨ì‚¬ì„ì„ ë³´ì´ë ¤ë©´ â€œí•¨ìˆ˜ê°’ ${\phi}(h(x))$ê°€ $(0, \dots, 0)$ ì´ë¼ë©´, $h(x)$ê°€ ë°˜ë“œì‹œ $0$ì´ì–´ì•¼ í•¨â€ì„ ë³´ì´ë©´ ëœë‹¤.</p> <ol> <li> <p>Kernelì´ ê³µì§‘í•©ì´ ì•„ë‹ˆë¼ê³  ê°€ì •í•˜ì.</p> <p>ì¦‰, ì–´ë–¤ ë‹¤í•­ì‹ $h(x)$ê°€ quatient ring $F[x]/\langle f(x) \rangle$ì˜ ì›ì†Œì´ê³ ,</p> \[{\phi}(h(x)) = (0, 0, \dots, 0)\] <p>ë¼ê³  í•˜ì.</p> </li> <li> <p>í•¨ìˆ˜ì˜ ì •ì˜ì— ë”°ë¼, ì´ëŠ” $h(x)$ë¥¼ ê° $f_i(x)$ë¡œ ë‚˜ëˆ„ì—ˆì„ ë•Œ ë‚˜ë¨¸ì§€ê°€ ëª¨ë‘ 0ì´ë¼ëŠ” ëœ»ì´ë‹¤.</p> <p>ì¦‰,</p> \[h(x) \equiv 0 \pmod{f_1(x)}\\[.5em] h(x) \equiv 0 \pmod{f_2(x)}\\ \vdots\\[.5em] h(x) \equiv 0 \pmod{f_k(x)}\] </li> <li> <p>ëª¨ë“  $f_i(x)$ëŠ” ì„œë¡œì†Œì´ë¯€ë¡œ, ê°œë³„ì ì¸ $f_i(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§€ë©´,</p> <p>ê·¸ë“¤ì˜ ê³±ì¸ $f(x)$ë¡œë„ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§„ë‹¤.</p> </li> <li> <p>$h(x)$ê°€ $f(x)$ì˜ ë°°ìˆ˜ë¼ëŠ” ë§ì€, $F[x]/\langle f(x) \rangle$)ì—ì„œ $0$ê³¼ ë™ì¹˜ë¼ëŠ” ëœ»ì´ë‹¤.</p> \[f(x) = f_1(x)f_2(x)\cdots f_k(x) \;\mid\; h(x)\\[1em] \implies h(x) \equiv 0 \pmod{f(x)}\] </li> </ol> <p>ì´ëŠ” $\phi(h(x))=(0,..,0)$ì´ ë˜ëŠ” $h(x)$ê°€ $0$ë°–ì— ì—†ë‹¤ëŠ” ê²ƒì´ë¯€ë¡œ</p> \[\text{Ker}({\phi}) = \{ {0} \}\] <p>ì´ê³ , Kernelì´ 0 í•˜ë‚˜ë¿ì´ë¯€ë¡œ, ì´ í•¨ìˆ˜ëŠ” ë‹¨ì‚¬(Injective)ì´ë‹¤.</p> <ul> <li> <p><strong>Kernel ì„ í†µí•œ ë™í˜• ì‚¬ìƒ êµ¬í•˜ê¸°</strong></p> <p>$\phi$ì˜ kernelì´ $\langle f(x)\rangle$ì´ë©´ $F[x]/\langle f(x)\rangle \cong \text{Im}(\phi)$ì´ë¯€ë¡œ $\phi$ì˜ Kernelì„ êµ¬í•´ ì´ë¥¼ ì¸í•œë‹¤.</p> <p>$\phi(h(x)) = (0, \dots, 0)$ ì´ ë˜ë ¤ë©´ ëª¨ë“  $i$ì— ëŒ€í•´ ë‹¤ìŒì´ ì„±ë¦½í•´ì•¼ í•œë‹¤.</p> \[h(x) \equiv 0 \pmod{f_i(x)}\] <p>ì¦‰, $h(x)$ëŠ” ëª¨ë“  $f_i(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì ¸ì•¼ í•œë‹¤.</p> <p>$f_i(x)$ë“¤ì´ ìŒë§ˆë‹¤ ì„œë¡œ ì†Œ(pairwise coprime)ì´ë¯€ë¡œ, $h(x)$ëŠ” ê·¸ë“¤ì˜ ê³±ì¸ $f(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì ¸ì•¼ í•œë‹¤.</p> \[\text{Ker}(\phi) = \{ h(x) \in F[x] \mid f(x) \text{ divides } h(x) \} = \langle f(x) \rangle\] <p>ë”°ë¼ì„œ, First Isomorphism Theoremì— ì˜í•´ ë‹¤ìŒì´ ì„±ë¦½í•œë‹¤.</p> \[F[x] / \langle f(x)\rangle = F[x] / \text{Ker}(\phi) \cong \text{Im}(\phi)\] </li> </ul> </li> <li> <p><strong>Surjectivity</strong></p> <p>ì˜¤ë¥¸ìª½ ringì˜ ì„ì˜ì˜ ì›ì†Œ $(a_1(x), \dots, a_k(x))$ì— ëŒ€í•´,</p> <p>$\phi(A(x)) = (a_1(x), \dots, a_k(x))$ë¥¼ ë§Œì¡±í•˜ëŠ” $A(x)$ê°€ ì¡´ì¬í•¨ì„ ë³´ì—¬ì•¼ í•œë‹¤.</p> <p>ê° $i$ ($1 \le i \le k$)ì— ëŒ€í•´ ë‹¤ìŒì„ ì •ì˜í•œë‹¤.</p> \[M_i(x) = \frac{f(x)}{f_i(x)} = \prod_{j \neq i} f_j(x)\] <p>$f_j(x)$ë“¤ì´ ì„œë¡œ ì†Œì´ë¯€ë¡œ, $M_i(x)$ì™€ $f_i(x)$ëŠ” ì„œë¡œ ì†Œì…ë‹ˆë‹¤ ($\gcd(M_i(x), f_i(x)) = 1$).</p> <p>ë”°ë¼ì„œ Extended Euclidean Algorithmì— ì˜í•´ ë‹¤ìŒì„ ë§Œì¡±í•˜ëŠ” ë‹¤í•­ì‹ $s_i(x), t_i(x)$ê°€ ì¡´ì¬í•œë‹¤.</p> \[s_i(x)M_i(x) + t_i(x)f_i(x) = 1\] <p>ìœ„ ì‹ì„ modulusë²• $f_i(x)$ë¡œ ë³´ë©´</p> \[s_i(x)M_i(x) \equiv 1 \pmod{f_i(x)}\] <p>ì´ê³ , $e_i(x) = s_i(x)M_i(x)$ ë¼ê³  ì •ì˜í•˜ë©´, $e_i(x)$ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì„±ì§ˆì„ ê°€ì§„ë‹¤.</p> <ul> <li>$e_i(x) \equiv 1 \pmod{f_i(x)}$</li> <li> <p>$e_i(x) \equiv 0 \pmod{f_j(x)}$ (ë‹¨, $j \neq i$)</p> <p>($M_i(x)$ê°€ $f_j(x)$ë¥¼ ì¸ìˆ˜ë¡œ í¬í•¨í•˜ë¯€ë¡œ)</p> </li> </ul> <p>ì´ì œ í•´ $A(x)$ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ êµ¬ì„±í•œë‹¤.</p> \[A(x) = \sum_{i=1}^{k} a_i(x)e_i(x) = \sum_{i=1}^{k} a_i(x)s_i(x)M_i(x)\] <p>ì´ $A(x)$ë¥¼ $f_j(x)$ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ í™•ì¸í•˜ë©´</p> \[A(x) \equiv a_j(x) \cdot 1 + \sum_{i \neq j} a_i(x) \cdot 0 \equiv a_j(x) \pmod{f_j(x)}\] <p>ì´ë‹¤. ë”°ë¼ì„œ $A(x)$ëŠ” ì£¼ì–´ì§„ ëª¨ë“  í•©ë™ì‹ì„ ë§Œì¡±í•œë‹¤.</p> </li> </ol> <p>$\phi$ë¥¼ í†µí•´ ìœ ë„ëœ ì‚¬ìƒ $\bar{\phi} : F[x]/\langle f(x) \rangle \to \prod F[x]/\langle f_i(x) \rangle$ ëŠ” ë‹¨ì‚¬(Injective)ì´ë©° ì „ì‚¬(Surjective)ì´ë¯€ë¡œ ë™í˜•(Isomorphism)ì´ë‹¤.</p> <p><strong>Uniqueness (ìœ ì¼ì„± ì¦ëª…)</strong></p> <p>ë§ë¶™ì—¬, ë§Œì•½ ë‘ ë‹¤í•­ì‹ $A(x)$ì™€ $B(x)$ê°€ ëª¨ë‘ ì£¼ì–´ì§„ ì—°ë¦½ í•©ë™ì‹ì„ ë§Œì¡±í•œë‹¤ê³  ê°€ì •í•˜ì. ì¦‰, ëª¨ë“  $i=1, \dots, k$ì— ëŒ€í•˜ì—¬ ë‹¤ìŒì´ ì„±ë¦½í•œë‹¤.</p> \[A(x) \equiv a_i(x) \pmod{f_i(x)}\\[.5em] B(x) \equiv a_i(x) \pmod{f_i(x)}\] <p>ë‘ ì‹ì„ ë¹¼ë©´,</p> \[A(x) - B(x) \equiv 0 \pmod{f_i(x)}\] <p>ì¦‰, $D(x) = A(x) - B(x)$ëŠ” ëª¨ë“  $f_i(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì§„ë‹¤.</p> <p>$f_i(x)$ë“¤ì€ ì„œë¡œì†Œ(pairwise coprime)ì´ë¯€ë¡œ, $D(x)$ëŠ” ê·¸ë“¤ì˜ ê³±ì¸ $f(x) = f_1(x)\cdots f_k(x)$ë¡œ ë‚˜ëˆ„ì–´ ë–¨ì–´ì ¸ì•¼ í•œë‹¤.</p> \[A(x) - B(x) \equiv 0 \pmod{f(x)}\\[.5em] \therefore A(x) \equiv B(x) \pmod{f(x)}\] <p>ë”°ë¼ì„œ modulus $f(x)$ì— ëŒ€í•œ í•´ $A(x)$ëŠ” ìœ ì¼í•˜ë‹¤.</p> <h3 id="example">Example</h3> <p>ë‹¤ìŒ ì—°ë¦½ í•©ë™ì‹ì„ ë§Œì¡±í•˜ëŠ” ë‹¤í•­ì‹ $A(x)$ë¥¼ êµ¬í•˜ì‹œì˜¤.</p> \[\begin{aligned} 1.\quad A(x) &amp;\equiv 2 \pmod{x-1} \\ 2.\quad A(x) &amp;\equiv 2x + 1 \pmod{x^2 + 1} \end{aligned}\] <ul> <li> <p>$f_1(x) = x-1$, $f_2(x) = x^2 + 1$</p> <p>â‡’ $\gcd(x-1, x^2+1) = 1$ì´ë¯€ë¡œ CRT ì ìš© ê°€ëŠ¥</p> </li> <li>$f(x) = (x-1)(x^2+1) = x^3 - x^2 + x - 1$</li> <li>$a_1(x) = 2$, $a_2(x) = 2x + 1$</li> </ul> <p>$M_1(x) = {f(x)}/{f_1(x)} = x^2 + 1$</p> <p>$M_2(x) = {f(x)}/{f_2(x)} = x - 1$</p> <ol> <li> <p><strong>$M_1^{-1}(x) \pmod{x-1}$</strong></p> <p>$M_1(x) = x^2 + 1$</p> <p>$M_1(1) = 1^2 + 1 = 2$</p> <p>â†’ $2 \cdot s_1 \equiv 1 \pmod{x-1}$ì´ ë˜ëŠ” ìƒìˆ˜ $s_1$ì„ ì°¾ì•„ì•¼ í•¨</p> <p>$\mathbb{Q}$ì—ì„œ $2$ì˜ ì—­ì›ì€ ${1}/{2}$</p> <p>$\therefore M_1^{-1}(x) = {1}/{2}$</p> </li> <li> <p><strong>$M_2^{-1}(x) \pmod{x^2+1}$</strong></p> <p>$M_2(x) = x - 1$</p> <p>$x^2+1$ì´ë¯€ë¡œ</p> <ul> <li> <p>$x^2 + 1$ì„ $x-1$ë¡œ ë‚˜ëˆ„ë©´</p> \[x^2 + 1 = (x+1)(x-1) + 2\] <p>ë¡œ ë‚˜ë¨¸ì§€ê°€ 2ì´ë©°, ì‹ì„ ì •ë¦¬í•˜ë©´</p> \[2 = (x^2+1) - (x+1)(x-1)\\ 1 = \frac{1}{2}(x^2+1) - \frac{1}{2}(x+1)(x-1)\] </li> </ul> \[1 \equiv -\frac{1}{2}(x+1) \cdot (x-1) \pmod{x^2+1}\] <p>ë”°ë¼ì„œ $(x-1)$ì˜ ì—­ì›ì€ $-{1}/{2}(x+1)$</p> <p>$\therefore M_2^{-1}(x) = -{1}/{2}(x+1)$</p> </li> <li> <p><strong>í•´ $A(x)$ êµ¬ì„±</strong></p> <p>$A(x) = a_1 M_1 M_1^{-1} + a_2 M_2 M_2^{-1}$</p> \[\begin{aligned} A(x) &amp;= 2 \cdot (x^2 + 1) \cdot \left(\frac{1}{2}\right) + (2x + 1) \cdot (x - 1) \cdot \left[ -\frac{1}{2}(x+1) \right] \\ &amp;= (x^2 + 1) - \frac{1}{2}(2x+1)(x^2-1) \quad (\because (x-1)(x+1)=x^2-1) \\ &amp;= (x^2 + 1) - \frac{1}{2}(2x^3 - 2x + x^2 - 1) \\ &amp;= x^2 + 1 - x^3 + x - \frac{1}{2}x^2 + \frac{1}{2} \\ &amp;= -x^3 + \frac{1}{2}x^2 + x + \frac{3}{2} \end{aligned}\] </li> <li> <p><strong>Modulus $f(x)$ë¡œ reduction</strong></p> <p>êµ¬í•œ í•´ì˜ ì°¨ìˆ˜ê°€ $f(x)$ $3$ì°¨ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìœ¼ë¯€ë¡œ, $f(x) = x^3 - x^2 + x - 1$ë¡œ ë‚˜ëˆ„ì–´ ë‚˜ë¨¸ì§€ë¥¼ êµ¬í•´ì•¼ í•œë‹¤.</p> <p>$A(x)$ ë¥¼ $x^3 - x^2 + x - 1$ ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ êµ¬í•œë‹¤.</p> <p>$x^3 \equiv x^2 - x + 1 \pmod{f(x)}$ ê´€ê³„ë¥¼ ì´ìš©í•´ ëŒ€ì…í•œë‹¤.</p> \[\begin{aligned} A(x) &amp;\equiv -(x^2 - x + 1) + \frac{1}{2}x^2 + x + \frac{3}{2} \\ &amp;\equiv -x^2 + x - 1 + \frac{1}{2}x^2 + x + \frac{3}{2} \\ &amp;\equiv -\frac{1}{2}x^2 + 2x + \frac{1}{2} \end{aligned}\] </li> </ol> <h5 id="verification">Verification</h5> <p>êµ¬í•œ í•´ $A(x) = -{1}/{2}x^2 + 2x + {1}/{2}$ ê°€ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ í™•ì¸í•´ ë´…ì‹œë‹¤.</p> <ol> <li> <p>ì²« ë²ˆì§¸ ì¡°ê±´ ($x-1$): $x=1$ ëŒ€ì…</p> \[A(1) = -\frac{1}{2} + 2 + \frac{1}{2} = 2\\[.5em] \rightarrow A(x) \equiv 2 \pmod{x-1}\] </li> <li> <p>ë‘ ë²ˆì§¸ ì¡°ê±´ ($x^2+1$): $x^2 \equiv -1$ ëŒ€ì…</p> \[A(x) \equiv -\frac{1}{2}(-1) + 2x + \frac{1}{2} = \frac{1}{2} + 2x + \frac{1}{2} = 2x + 1\\[.5em] \rightarrow A(x) \equiv 2x+1 \pmod{x^2+1}\] </li> </ol> <h5 id="polynomial-multiplication-and-convolution">Polynomial multiplication and Convolution</h5> <p>Without loss of generality, $\boldsymbol{a}$ and $\boldsymbol{b}$ of degree $n - 1$ are considered in this paper. Pad them with zero if their lengths are less than $n$.</p> <ul> <li> <p><strong>Linear</strong> convolution</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]$, then</p> \[\boldsymbol{c} = \sum_{k=0}^{2n-2} c_k x^k \in \mathbb{Z}_q[x],\\[.5em] \text{where } c_k = \sum_{i+j=k} a_i b_j \bmod q\quad (k = 0, 1, \dots, 2n - 2).\] <p>Here, $c$ is referred to as the linear convolution of $\boldsymbol{a}$ and $\boldsymbol{b}$.</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/!\left&lt;\phi(x)\right&gt;$. One can first compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]$, then $\boldsymbol{c} = \boldsymbol{c}â€™ \bmod \phi(x)$.</p> </li> <li> <p><strong>Cyclic</strong> convolution</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n - 1)$, then</p> \[\boldsymbol{c} = \sum_{k=0}^{n-1} c_k x^k,\\[.5em] \text{where } c_k = \sum_{i=0}^k a_i b_{k-i} + \sum_{i=k+1}^{n-1} a_i b_{n+k-i} \bmod q\quad (k = 0, 1, \dots, n - 1).\] <p>And $\boldsymbol{c}$ is referred to as the cyclic convolution (CC for short) of $\boldsymbol{a}$ and $\boldsymbol{b}$.</p> </li> <li> <p><strong>Negative wrapped</strong> convolution</p> <p>Consider $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n + 1)$, then</p> \[\boldsymbol c = \sum_{k=0}^{n-1} c_k x^k,\\[.5em] \text{where } c_k = \sum_{i=0}^k a_i b_{k-i} - \sum_{i=k+1}^{n-1} a_i b_{n+k-i} \bmod q \quad (k = 0, 1, \dots, n - 1).\] <p>Here, $\boldsymbol{c}$ is referred to as their negative wrapped convolution (NWC for short).</p> <p>â€» $x^{n+k} = x^n \cdot x^k \equiv \mathbf{(-1)} \cdot x^k = -x^k$</p> </li> </ul> <h3 id="number-theoretic-transform-ntt">NUMBER THEORETIC TRANSFORM (NTT)</h3> <p>NTT is the special case of the discrete Fourier transform (DFT) over a finite field.</p> <p>NTT and DFT share the same formula and similar properties, except that DFT has complex twiddle factors $\exp(-2\pi i/n)$, while NTT uses an integer primitive root of unity $\omega_n$.</p> <h4 id="cyclic-convolution-based-ntt">Cyclic Convolution-based NTT</h4> <p>$n$-point CC-based NTT has two parameters.</p> <ul> <li>The length or the point $n$, where $n$ is a power of two.</li> <li>The modulus $q$, where $q$ is a prime number satisfying $q \equiv 1 \pmod n$.</li> <li> <p>It implies that the primitive $n$-th root of unity $\omega_n$ in $\mathbb{Z}_q$ exists.</p> <p>$\mathbb{Z}_q$ê°€ ì†Œìˆ˜ $q$ì— ëŒ€í•œ Fieldì´ë¯€ë¡œ,</p> <p>0ì„ ì œì™¸í•œ ê³±ì…ˆêµ° $\mathbb{Z}_q^* = {1, 2, \dots, q-1}$ì€ order$\,=q-1$ì¸ groupì´ë‹¤.</p> <p>$\mathbb{Z}_q$ì˜ ê³±ì…ˆêµ° $\mathbb{Z}_q^*$ëŠ” í•­ìƒ cyclic groupì´ë¯€ë¡œ,</p> <p>ì–´ë–¤ generator $g$ê°€ ì¡´ì¬í•˜ì—¬ $\mathbb{Z}_q^* = { g^1, g^2, \dots, g^{q-1} }$ì´ë‹¤.</p> <p>ì´ë•Œ $q \equiv 1 \pmod n$ì´ë¯€ë¡œ $n \mid (q-1)$ì´ê³ ,</p> <p>ë”°ë¼ì„œ $\mathbb{Z}_q$ì—ëŠ” order$\,=n$ì¸ cyclic subgroupì˜ generatorê°€ ì¡´ì¬í•œë‹¤.</p> <p>order$\,=n$ì¸ $x\in\mathbb{Z}_q$ëŠ” ë‹¤ìŒì„ ë§Œì¡±í•œë‹¤.</p> <ul> <li>$x^n \equiv 1 \pmod q$</li> <li>$0 &lt; k &lt; n$ ì¸ ëª¨ë“  $k$ì— ëŒ€í•´ $x^k \not\equiv 1 \pmod q$</li> </ul> <p>ì¦‰, $x$ëŠ” primitive $n$-th root of unityì´ë‹¤.</p> <p>ë”°ë¼ì„œ ì†Œìˆ˜ $q$ì— ëŒ€í•´ $q \equiv 1 \pmod n$ì´ë¼ë©´, $\mathbb{Z}_q$ì—ëŠ” primitive $n$-th root of unity <strong>$\omega_n$</strong>ê°€ ì¡´ì¬í•˜ë©°,</p> <p>íŠ¹íˆ, $\phi(n)$ê°œë§Œí¼ ì¡´ì¬í•œë‹¤.</p> </li> </ul> <p>The forward transform, denoted by NTT, is defined as: $\hat{\boldsymbol{a}} = \text{NTT}(\boldsymbol{a})$, where</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \omega_n^{ij} \bmod q \quad (j = 0, 1, \dots, n - 1).\] <ul> <li> <p>NTTì˜ matrix í‘œí˜„</p> \[NTT=\begin{bmatrix} \omega^{0\times0} &amp;\cdots &amp; \omega^{0\times j} &amp;\cdots&amp; \omega^{0\times(n-1)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\ \omega^{i\times0} &amp;\cdots &amp; \omega^{i\times j} &amp;\cdots&amp; \omega^{i\times(n-1)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\ \omega^{(n-1)\times0} &amp;\cdots &amp; \omega^{(n-1)\times j} &amp;\cdots&amp; \omega^{(n-1)\times(n-1)}\\ \end{bmatrix}\] </li> </ul> <p>The inverse transform, denoted by INTT, is defined as $\boldsymbol{a} = \text{INTT}(\hat{\boldsymbol{a}})$, where</p> \[a_i = n^{-1} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q \quad (i = 0, 1, \dots, n - 1).\] <ul> <li> <p>INTTì˜ matrix í‘œí˜„</p> \[\begin{aligned} NTT^{-1}&amp;=\frac{1}{n}\begin{bmatrix} \;\omega^{-[0\times0]} &amp;\cdots &amp; \omega^{-[0\times j]} &amp;\cdots&amp; \omega^{-[0\times(n-1)]}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \;\omega^{-[i\times0]} &amp;\cdots &amp; \omega^{-[i\times j]} &amp;\cdots&amp; \omega^{-[i\times(n-1)]}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \;\omega^{-[(n-1)\times0]} &amp;\;\;\cdots\;\; &amp; \omega^{-[(n-1)\times j]} &amp;\cdots&amp; \omega^{-[(n-1)\times(n-1)]}\; \end{bmatrix}\\ &amp; =\frac{1}{n}\begin{bmatrix} \omega^{[0\times0] + (n/2)} &amp;\cdots &amp; \omega^{[0\times j] + (n/2)} &amp;\cdots&amp; \omega^{[0\times(n-1)] + (n/2)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \omega^{[i\times0] + (n/2)} &amp;\cdots &amp; \omega^{[i\times j] + (n/2)} &amp;\cdots&amp; \omega^{[i\times(n-1)] + (n/2)}\\ \vdots &amp; \ddots &amp; \vdots &amp; \ddots &amp; \vdots \\[.5em] \omega^{[(n-1)\times0] + (n/2)} \!\!\!\!&amp;\cdots &amp; \!\!\!\!\omega^{[(n-1)\times j] + (n/2)} \!\!\!\!&amp;\cdots&amp;\!\!\!\! \omega^{[(n-1)\times(n-1)] + (n/2)}\\ \end{bmatrix} \end{aligned}\] </li> </ul> <p>Note that the inverse transform can be implemented by replacing the $\omega_n$ in NTT procedure with $\omega_n^{-1}$, followed by multiplying by a scale factor $n^{-1}$.</p> <h5 id="prop">Prop)</h5> <p>It always holds that $\boldsymbol{a} = \text{INTT}(\text{NTT}(\boldsymbol{a}))$.</p> <h5 id="prop-cyclic-convolution-property">Prop) Cyclic Convolution Property</h5> <p>Let $\boldsymbol{c}$ be the cyclic convolution of $\boldsymbol{a}$ and $\boldsymbol{b}$, then it holds that</p> \[\text{NTT}(\boldsymbol{c}) = \text{NTT}(\boldsymbol{a}\cdot\boldsymbol{b}) = \text{NTT}(\boldsymbol{a}) \circ \text{NTT}(\boldsymbol{b}).\] <h4 id="negative-wrapped-convolution-based-ntt">Negative Wrapped Convolution-based NTT</h4> <p>The modulus $q$ is set to be a prime number satisfying $q \equiv 1 \pmod{2n}$ such that</p> <ul> <li> <p>the primitive $2n$-th root of unity $\psi_{2n}$ in $\mathbb{Z}_q$ exists.</p> <p>[ì™œ $2n$-th root of unityë¥¼ êµ¬í•˜ëŠ”ê°€?]</p> <p>Negative Wrapped Convolutionì€ $\mathbb{Z}_q[x]/(x^n+1)$ì—ì„œ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ $x^n \equiv -1$ê°€ ë˜ëŠ” $x$ë¥¼ êµ¬í•´ì•¼ í•œë‹¤.</p> <p><code class="language-plaintext highlighter-rouge">n-th primitive roots of unityëŠ” x^n=1ì´ë¯€ë¡œ êµ¬í•˜ê³ ì í•˜ëŠ” ê·¼ì´ ì•„ë‹˜</code></p> <p>ì´ë•Œ $x$ëŠ” $x^{2n} \equiv 1$ì´ë¯€ë¡œ $q \equiv 1 \pmod{2n}$ë¡œ ì„¤ì •í•˜ë©´,</p> <p>$(\psi_{2n}^{n})^2\equiv 1\implies \psi_{2n}^{n}\equiv -1$ì¸ primitive $2n$-th root of unity $\psi_{2n}\in\mathbb{Z}_q$ë¥¼ êµ¬í•  ìˆ˜ ìˆë‹¤.</p> <p>ì´ë•Œ, $\psi_{2n}$ëŠ” primitiveì´ë¯€ë¡œ $k&lt;2n$ì— ëŒ€í•˜ì—¬ $\psi_{2n}^k\neq 1$ì´ë¯€ë¡œ $\psi_{2n}^n\equiv1$ì´ë‹¤.</p> <p>â€» $\mathbb{Z}<em>q[x]/(x^{2n}-1)$ì˜ primitive $2n$-th roots of unity $\psi</em>{2n}$</p> <p>ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬ì— ì˜í•´</p> \[\mathbb{Z}_q[x]/(x^{2n}-1) \;\cong\; \underbrace{\,\mathbb{Z}_q[x]/(x^n-1)}_{\text{Cyclic Convolution}} \;\times \; \underbrace{\,\mathbb{Z}_q[x]/(x^n+1)}_{\text{Negative Wrapped}}\] <p>ì´ê³ , $\mathbb{Z}<em>q[x]/(x^{2n}-1)$ì—ì„œ êµ¬í•œ $2n$ê°œ ê·¼ì€ ${ \psi</em>{2n}^0, \psi_{2n}^1, \psi_{2n}^2, \dots, \psi_{2n}^{2n-1} }$ì´ë‹¤.</p> <p>ì´ë•Œ, $k=0,1,\,â€¦\,,n-1$ì— ëŒ€í•˜ì—¬ $\psi_{2n}^{2k}$ëŠ”</p> \[(\psi_{2n}^{2k})^n = (\psi_{2n}^{2n})^k = 1^k = 1\] <p>ì´ë¯€ë¡œ $\mathbb{Z}<em>q[x]/(x^n-1)$ì˜ ê·¼ì´ ë˜ê³ , $\psi</em>{2n}^{2k+1}$ì€</p> \[(\psi_{2n}^{2k+1})^n = (\psi_{2n}^{2n})^k \cdot \psi_{2n}^n = 1 \cdot (-1) = -1\] <p>ì´ë¯€ë¡œ $\mathbb{Z}_q[x]/(x^n+1)$ì˜ ê·¼ì´ ëœë‹¤.</p> </li> </ul> <p>Take $\omega_n = \psi_{2n}^2 \bmod q$, and write</p> \[\boldsymbol{\psi} = (1, \psi_{2n}, \psi_{2n}^2, \dots, \psi_{2n}^{n-1}),\quad \boldsymbol{\psi}^{-1} = (1, \psi_{2n}^{-1}, \psi_{2n}^{-2}, \dots, \psi_{2n}^{-(n-1)}).\] <p>Define</p> \[\bar{\boldsymbol{a}} = \boldsymbol{\psi} \circ \boldsymbol{a},\text{ where } \bar{a}_i = \psi_{2n}^i a_i\] <p>in detail, which implies</p> \[\boldsymbol{a} = \boldsymbol{\psi}^{-1} \circ \bar{\boldsymbol{a}},\text{ where } a_i = \psi_{2n}^{-i} \bar{a}_i.\] <p>$n$-point NWC-based NTT is to integrate $\boldsymbol{\psi}$ (resp., $\boldsymbol{\psi}^{-1}$) into NTT (resp., INTT), and denote them by $\text{NTT}^\psi$ (resp., $\text{INTT}^{\psi^{-1}}$), that is</p> \[\hat{\boldsymbol{a}} = \text{NTT}^\psi(\boldsymbol{a}) = \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a}),\\[1em] \boldsymbol{a} = \text{INTT}^{\psi^{-1}}(\hat{\boldsymbol{a}}) = \boldsymbol{\psi}^{-1} \circ \text{INTT}(\hat{\boldsymbol{a}}).\] <p><code class="language-plaintext highlighter-rouge">matrix í‘œí˜„ì€ CCì™€ ë™ì¼ (psiê°€ ì•„ë‹Œ omega ì‚¬ìš©)</code></p> <p>More specifically, the forward transform $\hat{\boldsymbol{a}} = \text{NTT}^\psi(\boldsymbol{a})$ can be written as</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \psi_{2n}^i \omega_n^{ij} \bmod q \quad (j = 0, 1, \dots, n - 1).\] <p>The inverse transform $\boldsymbol{a} = \text{INTT}^{\psi^{-1}}(\hat{\boldsymbol{a}})$ can be written as</p> \[a_i = n^{-1} \psi_{2n}^{-i} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q \quad (i = 0, 1, \dots, n - 1).\] <h5 id="prop-1">Prop)</h5> <p>It always holds that $\boldsymbol{a} = \text{INTT}^{\psi^{-1}}(\text{NTT}^\psi(\boldsymbol{a}))$.</p> <h5 id="prop-negative-wrapped-convolution-property">Prop) Negative Wrapped Convolution Property</h5> <p>Let $\boldsymbol{c}$ be the negative wrapped convolution of $\boldsymbol{a}$ and $\boldsymbol{b}$, then it holds that</p> \[\begin{aligned} \text{NTT}^\psi(\boldsymbol{c}) &amp; = \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})\\[.3em] &amp;=\text{NTT}(\boldsymbol{\psi} \circ (\underbrace{\boldsymbol{a}\cdot\boldsymbol{b}}_\text{NWC}))\\[.3em] &amp;=\text{NTT}(\underbrace{(\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b})}_{\text{CC\; }\because\ \psi_{wn}^{2k+1}\,\to\ \psi_{wn}^{2k+2}})\\[.3em] &amp;=\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{a})\circ\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{b})\\[.3em] &amp;=\text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b}). \end{aligned}\] <ul> <li> <p>Example</p> <p><strong>Initialization</strong></p> <ul> <li>$\mathbb{Z}_q[x]/(x^n+1)$ <ul> <li>$n=2$, modulus $x^2 + 1$ (ì¦‰, $x^2 \equiv -1$)</li> <li>$q=5$ ($q \equiv 1 \pmod{2n}$ ë§Œì¡±)</li> </ul> </li> <li> <p>$\psi=2$</p> <p>$2^1=2,\; 2^2=4,\; 2^3=8\equiv3,\; 2^4=16\equiv1$, $\psi^n \equiv -1 \pmod q$</p> </li> <li>$\omega=4$</li> <li>NTT matrix $N = \begin{bmatrix} 1 &amp; 1 \ 1 &amp; \omega \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \ 1 &amp; 4 \end{bmatrix}$</li> <li>$\boldsymbol{a} = [1, 1]$ (ì¦‰, $x+1$)</li> <li>$\boldsymbol{b} = [2, 1]$ (ì¦‰, $x+2$)</li> </ul> <p><strong>Calculation</strong> (ë²¡í„°í‘œí˜„ê³¼ ë§ì¶”ê¸° ìœ„í•´ ë‹¤í•­ì‹ì„ ì €ì°¨í•­ë¶€í„° í‘œê¸°)</p> <p>$\boldsymbol{\psi}=[ \psi^0, \psi^1 ] = [1, 2]$</p> <ol> <li> <p>$\text{NTT}^\psi(\boldsymbol{c}) :=\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})=\text{NTT}(\boldsymbol{\psi} \circ (\boldsymbol{a}\cdot\boldsymbol{b}))$</p> <p>$\boldsymbol{c}=(1+x)(2+x) = 2 + 3x + x^2\equiv 2 + 3x + (-1) = 1+3x \implies[1,3]$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{c}=[1,2]\circ[1,3]=[1,6]\equiv[1,1]$</p> \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{c})=N([1,1])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 1 \end{bmatrix}=\begin{bmatrix} 2 \\ 5 \end{bmatrix}\equiv\begin{bmatrix} 2 \\ 0 \end{bmatrix}=[2,0]\] <p>$\boldsymbol{a}\cdot \boldsymbol{b}=\boldsymbol{c}=[1,3]$</p> <p>$\text{NTT}(\boldsymbol{\psi} \circ (\boldsymbol{a}\cdot \boldsymbol{b}))=[2,0]$</p> </li> <li> <p>$\text{NTT}((\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}))$</p> <p>â€» $\boldsymbol{\psi}$ë¥¼ ê³±í•´ì¤¬ê¸° ë•Œë¬¸ì— Cyclic convolution ê³µê°„ì´ ë¨ â‡’ $x^2\equiv 1$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{a}=[1,2]\circ[1,1]=[1,2]\implies1+2x$</p> <p>$\boldsymbol{\psi} \circ \boldsymbol{b}=[1,2]\circ[2,1]=[2,2]\implies 2+2x$</p> \[\begin{aligned} (\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}) &amp;=(1+2x)(2+2x)=2+4x+2x+4x^2\\ &amp;=2+6x+4(1)=6+6x\\ &amp;\equiv 1+x\implies [1,1] \end{aligned}\] \[\text{NTT}((\boldsymbol{\psi} \circ\boldsymbol{a})\cdot (\boldsymbol{\psi} \circ\boldsymbol{b}))=N([1,1])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 1 \end{bmatrix}=\begin{bmatrix} 2 \\ 5 \end{bmatrix}\equiv\begin{bmatrix} 2 \\ 0 \end{bmatrix}=[2,0]\] </li> <li> <p>$\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{a})\circ\text{NTT}(\boldsymbol{\psi} \circ\boldsymbol{b}) := \text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b})$</p> \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a})=N([1,2])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 1 \\ 2 \end{bmatrix}=\begin{bmatrix} 3 \\ 9 \end{bmatrix}\equiv\begin{bmatrix} 3 \\ 4 \end{bmatrix}=[3,4]\] \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{b})=N([2,2])=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 4 \end{bmatrix}\begin{bmatrix} 2 \\ 2 \end{bmatrix}=\begin{bmatrix} 4 \\ 10 \end{bmatrix}\equiv\begin{bmatrix} 4 \\ 0 \end{bmatrix}=[4,0]\] \[\text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{a})\circ \text{NTT}(\boldsymbol{\psi} \circ \boldsymbol{b})=[3,4]\circ[4,0]=[12,0]=[2,0]\] </li> </ol> </li> </ul> <h4 id="ntt-based-polynomial-multiplication">NTT-based Polynomial Multiplication</h4> <p>NTT can be used to compute inear/cyclic/negative-wrapped convolutioLns.</p> <h5 id="linear-convolution-based-polynomial-multiplication">Linear convolution-based polynomial multiplication</h5> <p>To compute the linear convolution $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}q[x]$,</p> <p>first, pad them to the length of $2n$ with zeros, resulting with</p> \[\boldsymbol{a}' = (a_0, \dots, a_{n-1}, \underbrace{0, \dots, 0}_{\# \,0\ =\ n}) \;\text{ and }\; \boldsymbol{b}' = (b_0, \dots, b_{n-1}, \underbrace{0, \dots, 0}_{\# \,0\ =\ n}).\] <p>Second, use $2n$-point NTT/INTT for</p> \[\boldsymbol{c}=\text{INTT}(\text{NTT}(\boldsymbol{a}')\circ \text{NTT}(\boldsymbol{b}')).\] <p>Moreover, to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(\phi(x))$, one can compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]$ with $2n$-point NTT/INTT, followed by computing</p> \[\boldsymbol{c}=\boldsymbol{c}'\bmod\phi(x).\] <h5 id="cyclic-convolution-based-polynomial-multiplication">Cyclic convolution-based polynomial multiplication</h5> <p>To compute the cyclic convolution $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n - 1)$,</p> <p>one can straightly use $n$-point NTT/INTT, according to cyclic convolution property</p> \[\boldsymbol{c} = \text{INTT}(\text{NTT}(\boldsymbol{a}) \circ \text{NTT}(\boldsymbol{b})).\] <h5 id="negative-wrapped-convolution-based-polynomial-multiplication">Negative wrapped convolution-based polynomial multiplication</h5> <p>To compute the negative wrapped convolution $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n + 1)$, one can use the negative wrapped convolution property</p> \[\boldsymbol{c} = \text{INTT}^{\psi^{-1}}\left(\text{NTT}^\psi(\boldsymbol{a}) \circ \text{NTT}^\psi(\boldsymbol{b})\right).\] <h5 id="complexity">Complexity</h5> <p>The complexity of directly computing NTT/INTT is $O(n^2)$.</p> <p>There are</p> <ul> <li>two NTTs,</li> <li>one point-wise multiplication and</li> <li>one INTT for NTT-based multiplication.</li> </ul> <p>Therefore, the complexity of NTT-based multiplication without fast algorithms is $O(n^2)$.</p> <h5 id="advantages-of-ntt">Advantages of NTT</h5> <p>Here, let NTT/INTT be any kind of forward/inverse transforms.</p> <ul> <li> <p>Firstly, both NTT and INTT are linear transformations, based on which it can save INTTs in lattice-based schemes (e.g., Kyber and Dilithium), i.e.,</p> \[\begin{aligned} \sum_{i=0}^l \boldsymbol{a}_i \boldsymbol{b}_i &amp;= \sum_{i=0}^l \text{INTT}(\text{NTT}(\boldsymbol{a}_i) \circ \text{NTT}(\boldsymbol{b}_i)) \\ &amp;= \text{INTT}(\sum_{i=0}^l \text{NTT}(\boldsymbol{a}_i) \circ \text{NTT}(\boldsymbol{b}_i)). \end{aligned}\] </li> <li>Additionally, consider $\boldsymbol{c} = \text{INTT}(\text{NTT}(\boldsymbol{a}) \circ \text{NTT}(\boldsymbol{b}))$, where $\boldsymbol{a}$ is random. Since the NTT transforms keep the randomness of a random polynomial, i.e., $\hat{\boldsymbol{a}} = \text{NTT}(\boldsymbol{a})$ is also random, one can directly generate a random polynomial, and view it as random $\hat{\boldsymbol{a}}$ already in the NTT domain, and compute $\boldsymbol{c} = \text{INTT}(\hat{\boldsymbol{a}} \circ \text{NTT}(\boldsymbol{b}))$, thus eliminating the need for the forward transform.</li> <li>Besides, NTT and INTT preserve the dimension and bit length of all individual coefficients of a polynomial, i.e., $\hat{\boldsymbol{a}}$ and $\boldsymbol{a}$ share the same dimension and bit length of any coefficient. Thus, $\hat{\boldsymbol{a}}$ can be stored where $\boldsymbol{a}$ is originally placed.</li> <li>Finally, in some cases where $\boldsymbol{a}$ is involved in multiple multiplications, $\hat{\boldsymbol{a}}$ is computed once and stored for its use in subsequent multiplications, which can save forward transforms without any extra requirement of storage.</li> </ul> <h4 id="some-tricks-for-polynomial-multiplication">SOME TRICKS FOR POLYNOMIAL MULTIPLICATION</h4> <h5 id="def-one-iteration-karatsuba-algorithm">Def) One-iteration Karatsuba algorithm</h5> <p>Let $a, b, c, d$ be any numbers or polynomials.</p> <ul> <li> <p>The one-iteration Karatsuba algorithm</p> <p>1 wordë¥¼ $X$ë¼ê³  í•  ë•Œ</p> \[f=aX+b,\quad g=cX+d \\[1em] \begin{aligned} fg &amp;= (aX+b)(cX+d)\\ &amp;= acX^2 + (ad+bc)X + bd\\ &amp;= t_1 X^2 + t_2 X + t_3 \end{aligned}\] </li> </ul> <p>implies that, to compute</p> \[t_1 = a \cdot c,\; t_2 = a \cdot d + b \cdot c \text{\quad and\quad } t_3 = b \cdot d,\] <p>first compute $t_1$ and $t_3$, and then compute $t_2$ by</p> \[t_2 = (a + b) \cdot (c + d) - t_1 - t_3.\] <ul> <li> <p>One-iteration Karatsuba algorithm saves one multiplication at the cost of three extra additions (subtractions).</p> \[\begin{aligned} t_2 &amp;= ad+bc &amp; \text{\quad 2 multiplications}\\ &amp;= ad+bc+ac-ac+bd-bd\\ &amp;= ac+bc+ad+bd-ac-bd &amp; \downarrow\qquad\quad\,\\ &amp;= (a+b)(c+d)-ac-bd\\ &amp;= (a+b)(c+d)-t_1-t_2 &amp; \text{\quad 1 multiplication\,} \end{aligned}\] </li> </ul> <h5 id="def-goods-trick">Def) Goodâ€™s trick</h5> <p>As for the ring $\mathbb{Z}_q[x]/(x^{h \cdot 2^k} - 1)$ where $h$ is an odd number, Goodâ€™s trick maps</p> \[\mathbb{Z}_q[x]/(x^{h \cdot 2^k} - 1) \xrightarrow{\phi\,} \left(\mathbb{Z}_q[z]/(z^{2^k} - 1)\right)[y]/(y^h - 1), \\[1em] \begin{aligned} \text{where }\; \boldsymbol{a} = \sum_{l=0}^{h \cdot 2^k - 1} a_l x^l \mapsto &amp;\sum_{l=0}^{h \cdot 2^k - 1} a_l y^{(l \bmod h)} z^{(l \bmod 2^k)} \\ &amp;= \sum_{i=0}^{h-1} \sum_{j=0}^{2^k-1} \tilde{a}_{i,j} y^i z^j. \end{aligned}\] <ul> <li> <p>ì›ë¦¬: ì¤‘êµ­ì¸ì˜ ë‚˜ë¨¸ì§€ ì •ë¦¬</p> <p>Goodâ€™s trickì˜ ê°€ì¥ ì¤‘ìš”í•œ ì¡°ê±´ì€ $N = h \cdot 2^k$ì—ì„œ $h$ê°€ í™€ìˆ˜ë¼ëŠ” ì ìœ¼ë¡œ, $\gcd(h, 2^k) = 1$ì´ë‹¤.</p> <p>CRTì— ì˜í•´, ì„œë¡œì†Œì¸ ë‘ ì •ìˆ˜ $h, 2^k$ì— ëŒ€í•´ ë‹¤ìŒ Group Isomorphismì´ ì„±ë¦½í•œë‹¤.</p> \[\mathbb{Z}_{h \cdot 2^k} \cong \mathbb{Z}_h \times \mathbb{Z}_{2^k}\] <p>ì´ ë™í˜• ì‚¬ìƒì„ í†µí•´ $l$ì„ ë‹¤ìŒê³¼ ê°™ì´ ë§¤í•‘í•œë‹¤.</p> \[l \mapsto (l \bmod h, \ l \bmod 2^k)=(i,j)\] \[l = \underbrace{i \cdot [2^k \cdot ((2^k)^{-1} \bmod h)]}_{i \text{ component}} + \underbrace{j \cdot [h \cdot (h^{-1} \bmod 2^k)]}_{j \text{ component}} \pmod{h \cdot 2^k}\] <p>$i = l \bmod h$ë¥¼ ì°¨ìˆ˜ë¡œ ê°–ëŠ” ë³€ìˆ˜(formal variable)ë¥¼ $y$, $j = l \bmod 2^k$ë¥¼ ì°¨ìˆ˜ë¡œ ê°–ëŠ” ë³€ìˆ˜ë¥¼ $z$ë¼ê³  í•˜ë©´, $x$ë¼ëŠ” í•˜ë‚˜ì˜ ë³€ìˆ˜ê°€ $y, z$ë¼ëŠ” ë‘ ê°œì˜ ë³€ìˆ˜ë¡œ ë¶„ë¦¬ë˜ë©´ì„œ, 1ì°¨ì› ë‹¤í•­ì‹ì´ í–‰ë ¬ í˜•íƒœì˜ 2ì°¨ì› ë‹¤í•­ì‹ìœ¼ë¡œ ë³€í™˜ëœë‹¤.</p> \[\phi(x^l)= y^{(l \bmod h)} \!\cdot\! z^{(l \bmod 2^k)}\\[1em] a_l = \tilde{a}_{i,j}\] <p>ì´ ë°©ì‹ì€ í° 1ì°¨ì› ë‹¤í•­ì‹ í™˜ $\mathbb{Z}_q[x]/(x^N-1)$ì„ ë‹¤ë£¨ê¸° ì‰¬ìš´ ì‘ì€ ë‘ ê°œì˜ ë§ì˜ Tensor Product í˜•íƒœì¸ $(\mathbb{Z}_q[z]/(z^{2^k} - 1)) \otimes (\mathbb{Z}_q[y]/(y^h - 1))$ë¡œ decompositioní•˜ëŠ” ì¥ì ì´ ìˆë‹¤.</p> <p>ì´ ë¶„í•´ë¥¼ í†µí•´ $N$-point NTTë¥¼ ìˆ˜í–‰í•˜ëŠ” ëŒ€ì‹ , $h$ê°œì˜ $2^k$-point NTTì™€ $2^k$ê°œì˜ $h$-point NTTë¡œ ìª¼ê°œì„œ ë³‘ë ¬ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•´ì§„ë‹¤.</p> </li> </ul> <p>Write the coefficients $\tilde{a}<em>{i,j}$ into a matrix $\tilde{A} = (\tilde{a}</em>{i,j})_{h \times 2^k}$, and do $h$ parallel $2^k$-point NTT over $\mathbb{Z}_q[z]/(z^{2^k} - 1)$ with each row.</p> <p>The corresponding point-wise multiplications are $2^k$ parallel degree-$(h - 1)$ polynomial multiplications in the ring $\mathbb{Z}<em>q[y]/(y^h - 1)$ with each column from $\tilde{A}$. Then we do $h$ parallel $2^k$-point INTT with each row. Denote the resulting matrix by $\tilde{C} = (\tilde{c}</em>{i,j})_{h \times 2^k}$.</p> <p>Map $\sum_{i=0}^{h-1} \sum_{j=0}^{2^k-1} \tilde{c}<em>{i,j} y^i z^j$ back to $c = \sum</em>{l=0}^{h \cdot 2^k - 1} c_l x^l \in \mathbb{Z}_q[x]/(x^{h \cdot 2^k} - 1)$ according to the CRT formula</p> \[l = ((2^k)^{-1} \bmod h) \cdot 2^k \cdot i + (h^{-1} \bmod 2^k) \cdot h \cdot j \bmod h \cdot 2^k\] <p>to obtain $c_l x^l$ from $\tilde{c}_{i,j} y^i z^j$.</p> <h5 id="def-schÃ¶nhages-trick">Def) SchÃ¶nhageâ€™s trick</h5> <p>Map the multiplicand</p> \[\begin{aligned} &amp; a = \sum_{i=0}^{2mn-1} a_i x^i \in \mathbb{Z}_q[x]/(x^{2mn} - 1) \\[1.5em] &amp; \to\; \sum_{j=0}^{2n-1} (\sum_{i=0}^{m-1} a_{m \cdot j + i} x^i) y^j \in \left(\mathbb{Z}_q[x][y]/(y^{2n} - 1)\right)/(x^m - y) \text{ with } y = x^m. \end{aligned}\] <p>To compute multiplication in $(\mathbb{Z}_q[x][y]/(y^{2n} - 1))/(x^m - y)$,</p> <p>one can first compute that in $\mathbb{Z}_q[x][y]/(y^{2n} - 1)$, and then obtain the result modulo $(x^m - y)$.</p> <p>And to compute multiplication in $\mathbb{Z}_q[x]$ with multiplicands of degree less than $m$,</p> <p>we can do it in $\mathbb{Z}_q[x]/(x^{2m} + 1)$ without modulo $(x^{2m} + 1)$.</p> <p>Therefore, multiplication in $\mathbb{Z}_q[x][y]/(y^{2n} - 1)$ can be computed in $(\mathbb{Z}_q[x]/(x^{2m} + 1))[y]/(y^{2n} - 1)$.</p> <p>Note that it is an NTT-friendly ring and $x$ is the primitive $4m$-th root of unity in $\mathbb{Z}_q[x]/(x^{2m} + 1)$.</p> <ul> <li> <p>ì›ë¦¬: ë¸”ë¡í™”</p> \[a(x) = a_0 + a_1 x + \dots + a_{2mn-1} x^{2mn-1}\] <p>$x^m = y$ë¼ê³  í•˜ê³ , ë‹¤í•­ì‹ $a(x)$ë¥¼ $m$ê°œ í•­ì”© ë¸”ë¡ìœ¼ë¡œ ë‚˜ëˆˆë‹¤ê³  í•˜ì.</p> <p>$x$ì˜ ì§€ìˆ˜ $l$ì„ $m$ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ëª«($j$)ê³¼ ë‚˜ë¨¸ì§€($i$)ë¡œ ë³´ë©´</p> \[l = m \cdot j + i \quad (0 \le i &lt; m)\] <p>ì´ë¯€ë¡œ</p> \[A(y) = \sum_{j=0}^{2n-1} \left( \sum_{i=0}^{m-1} a_{m \cdot j + i} x^i \right) y^j\] <p>ì´ê³  $A(y)$ëŠ” $y$ì— ëŒ€í•œ ë‹¤í•­ì‹ì´ë‹¤.</p> <p>ì´ë•Œ ê³„ìˆ˜ëŠ” ìƒìˆ˜ê°€ ì•„ë‹Œ, $x$ì— ëŒ€í•œ (ì°¨ìˆ˜ $m$ ë¯¸ë§Œì˜) ë‹¤í•­ì‹ì´ë‹¤.</p> <p>ë”°ë¼ì„œ $y$ì— ëŒ€í•˜ì—¬ $2n$-point NTTë¥¼ ìˆ˜í–‰í•´ì•¼ í•˜ë©°, ê³„ìˆ˜ë¼ë¦¬ ë§ì…ˆ/ê³±ì…ˆì„ í•  ë•Œ modulus $x^{2m}+1$ìœ¼ë¡œ ë‹¤í•­ì‹ ì—°ì‚°ì„ ìˆ˜í–‰í•´ì•¼ í•œë‹¤.</p> <p>ì´ ê¸°ë²•ì€ NTTë¥¼ ì ìš©í•˜ê³  ì‹¶ì€ë° ì ì ˆí•œ $q$ê°€ ì—†ì„ ë•Œ í™œìš©ëœë‹¤.</p> <p>NTTë¥¼ í•˜ë ¤ë©´ $N$-th root of Unity)ê°€ $\mathbb{Z}_q$ ì•ˆì— ìˆì–´ì•¼ í•˜ì§€ë§Œ , $q$ê°€ ì‘ê±°ë‚˜ ì¡°ê±´ì´ ì•ˆ ë§ìœ¼ë©´ ì´ëŸ¬í•œ ê·¼ì´ ì¡´ì¬í•˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.</p> <p>SchÃ¶nhageâ€™s Trickì€ $q$ë¥¼ ì°¾ëŠ” ëŒ€ì‹  ë³€ìˆ˜ $x$ ìì²´ë¥¼ root of Unityë¡œ ì‚¬ìš©í•œë‹¤.</p> <p>ê³„ì‚°í•˜ëŠ” ringì˜ modulusê°€ $x^{2m} + 1$ì´ë¯€ë¡œ, $x^{2m} \equiv -1$ì´ê³  ë”°ë¼ì„œ $x^{4m} \equiv 1$ì´ ëœë‹¤.</p> <p>ì¦‰, $x$ë¼ëŠ” ë‹¤í•­ì‹ ìì²´ê°€ $4m$-th root of Unity ì—­í• ì„ í•˜ë¯€ë¡œ,</p> <p>$\mathbb{Z}_q$ì— $N$-th root of unityê°€ ì—†ì–´ë„, ringì„ í™•ì¥í•¨ìœ¼ë¡œì¨ ì–µì§€ë¡œ NTTê°€ ê°€ëŠ¥í•˜ê²Œ ë§Œë“  ê²ƒì´ë‹¤.</p> <p>ë˜í•œ, Goodâ€™s Trickì€ $N = h \cdot 2^k$ì²˜ëŸ¼ ì„œë¡œì†Œì¸ ê²½ìš°ì—ë§Œ êµ¬ì¡°ë¥¼ ë¶„í•´í•  ìˆ˜ ìˆëŠ” ë°˜ë©´, SchÃ¶nhageâ€™s Trickì€ ì„œë¡œì†Œê°€ ì•„ë‹ˆë”ë¼ë„ $N = m \cdot n$ì´ê¸°ë§Œ í•˜ë©´ ì–¸ì œë“  ringê³¼ ì—°ì‚° ë‹¨ìœ„ë¥¼ ë¶„í•´í•  ìˆ˜ ìˆë‹¤.</p> </li> </ul> <h5 id="nussbaumers-trick">Nussbaumerâ€™s trick</h5> <p>Nussbaumerâ€™s trick is similar to SchÃ¶nhageâ€™s trick.</p> <p>It maps</p> \[\begin{aligned} &amp;a = \sum_{i=0}^{2mn-1} a_i x^i \in \mathbb{Z}_q[x]/(x^{2mn} + 1) \\[1.5em] &amp;\to \sum_{i=0}^{m-1} (\sum_{j=0}^{2n-1} a_{m \cdot j + i} y^j) x^i \in \left(\mathbb{Z}_q[y]/(y^{2n} + 1)\right)[x]/(x^m - y) \text{\; with\; } y = x^m. \end{aligned}\] <p>To compute multiplication in $(\mathbb{Z}_q[y]/(y^{2n} + 1))[x]/(x^m - y)$,</p> <p>first compute multiplication in $(\mathbb{Z}_q[y]/(y^{2n} + 1))[x]$,</p> <p>and then obtain the result modulo $(x^m - y)$.</p> <p>And to compute multiplication in $(\mathbb{Z}_q[y]/(y^{2n} + 1))[x]$ with multiplicands of degree less than $n$,</p> <p>one can do it in $(\mathbb{Z}_q[y]/(y^{2n} + 1))[x]/(x^{2n} - 1)$ for $n \ge m$ without modulo $(x^{2n} - 1)$.</p> <p>Note that it is an NTT-friendly ring and $y$ is the primitive $4n$-th root of unity in $\mathbb{Z}_q[y]/(y^{2n} + 1)$.</p> <ul> <li> <p>ì›ë¦¬: ì¶• ë³€í™˜</p> <p>ì´ ê¸°ë²•ì€ ë‘ ë‹¨ê³„ì˜ ì¶• ë³€í™˜ì„ ì—°ì†ì ìœ¼ë¡œ ìˆ˜í–‰í•œë‹¤.</p> <p>ë¨¼ì € SchÃ¶nhageì™€ ë™ì¼í•˜ê²Œ, ì›ë˜ ë‹¤í•­ì‹ $a$ê°€ $\mathbb{Z}_q[x]/(x^{2mn} + 1)$ì— ìˆì„ ë•Œ</p> <p>ì´ë¥¼ $m$ê°œ í•­ ë‹¨ìœ„ë¡œ ë‚˜ëˆ  $y=x^m$ìœ¼ë¡œ ì¹˜í™˜í•˜ì—¬ 2ì°¨ì› í˜•íƒœë¡œ ë§Œë“ ë‹¤.</p> \[a = \sum_{l=0}^{2mn-1} a_l x^l \;\mapsto\; \sum_{j=0}^{2n-1} \left(\sum_{i=0}^{m-1} a_{m \cdot j + i} x^i \right) y^j \in (\mathbb{Z}_q[x]/(x^m - y))[y]/(y^{2n} + 1)\] <p>ê²°ê³¼ì ìœ¼ë¡œ, $y$ì— ëŒ€í•œ ë‹¤í•­ì‹ì´ ë˜ë©°, ê³„ìˆ˜ëŠ” $x$ì— ëŒ€í•œ ë‹¤í•­ì‹ì´ ëœë‹¤.</p> <p>ìµœì¢…ì ìœ¼ë¡œ ì–»ê³ ì í•˜ëŠ” ringì€ $\mathbb{Z}_q[y]/(y^{2n} + 1)$ì´ ê³„ìˆ˜ê°€ ë˜ê³ ,</p> <p>$x$ê°€ ë³€ìˆ˜ê°€ ë˜ëŠ” ring $(\mathbb{Z}_q[y]/(y^{2n} + 1))[x]/(x^m - y)$ì´ë‹¤.</p> \[\sum_{j=0}^{2n-1} \underbrace{\left(\, \sum_{i=0}^{m-1} a_{m j + i} x^i \right)}_{\text{Coefficient } C_j(x)} y^j \;\,=\;\; \sum_{i=0}^{m-1} \underbrace{\left(\, \sum_{j=0}^{2n-1} a_{m j + i} y^j \right)}_{\text{Coefficient } D_i(y)} x^i\] <p>ì´ ringì€ $x$ì˜ ì°¨ìˆ˜ê°€ $m$ ë¯¸ë§Œ, $y$ì˜ ì°¨ìˆ˜ê°€ $2n$ ë¯¸ë§Œì´ë©°, $y$ê°€ $4n$-th root of unity ì—­í• ì„ í•˜ê²Œ ëœë‹¤.</p> <p>Nussbaumerâ€™s TrickëŠ” ê³„ì‚°ì˜ íš¨ìœ¨ì„± ê·¹ëŒ€í™”í•œë‹¤.</p> <p>ì´ ê¸°ë²•ì€ $\mathbb{Z}_q$ì— $N$-th root of unityê°€ ì—†ì„ ë•Œë„ ë³€ìˆ˜ $y$ë‚˜ $x$ ìì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ NTTì™€ ìœ ì‚¬í•œ ê³ ì† ë³€í™˜(Polynomial Transform)ì„ ê°•ì œë¡œ ì ìš©í•  ìˆ˜ ìˆê²Œ í•œë‹¤.</p> <p>ë˜í•œ, ì „ì²´ $2mn$-ì°¨ìˆ˜ ë‹¤í•­ì‹ì˜ ê³±ì…ˆì„ $y$ì— ëŒ€í•œ $2n$-point NTTë¡œ ë°”ê¾¸ë©°, ì´ ê³¼ì •ì—ì„œ $2n$ê°œì˜ ì‘ì€ ê³±ì…ˆì„ ë³‘ë ¬ë¡œ ìˆ˜í–‰í•˜ê²Œ ëœë‹¤.</p> <p>ê°€ì¥ í° ì´ì ì€ ì‘ì€ ê³±ì…ˆì„ í•  ë•Œ $\text{modulo } (x^{2m} + 1)$ ëŒ€ì‹  $\text{modulo } (x^{2n} - 1)$ê³¼ ê°™ì€ ë‹¨ìˆœí•œ moduloë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë³€í™˜í•œë‹¤ëŠ” ì ì´ë‹¤.</p> </li> </ul> <h4 id="-number-theoretic-transform-over-mathbbz_qxxn-xn2-1">[+] NUMBER THEORETIC TRANSFORM OVER $\mathbb{Z}_Q[X]/(X^N-x^{N/2} +1)$</h4> <p>In this section, introduce some progresses about relaxing the requirement of $n$ being power-of-two such that NTT can be utilized over non-power-of-two rings.</p> <h5 id="incomplete-fft-trick-over-mathbbz_qxxn--xn2-1">Incomplete FFT trick over $\mathbb{Z}_q[x]/(x^n -x^{n/2} +1)$</h5> <p>Some progress about relaxing the requirement of $n$ being a power-of-two is made by Lyubashevsky and Seiler.</p> <p>They first introduced a special incomplete NTT to lattice-based cryptographic schemes,</p> <p>by offering a new non-power-of-two ring structure $\mathbb{Z}_q[x]/(x^n - x^{n/2} + 1)$ where $n = 3 \cdot 2^e$</p> <p>instead of a power of two and $q$ is a prime number satisfying $q \equiv 1 \pmod n$ such that $\psi_n$ exits.</p> <ul> <li> <p>Actually, $x^n - x^{n/2} + 1$ is the $3n$-th cyclotomic polynomial of degree $n$, where $n = 3^l \cdot 2^e\; (l \ge 0, e \ge 1)$, not a power-of-two cyclotomic polynomial anymore.</p> \[\Phi_{3n}(x) = x^n - x^{n/2} + 1\\[.5em] \Phi_{3n}(x) = \Phi_{6(n/2)}(x) = \Phi_6(x^{n/2}) = (x^{n/2})^2 - (x^{n/2}) + 1\\[.5em] \therefore \Phi_{3n}(x) = x^n - x^{n/2} + 1\] <p>ì´ë•Œ $\Phi_{3n}(x)$ì˜ ë‘ ê·¼ì˜ í•©ì€ $-(-1)/1=1$, ê³±ì€ $1/1=1$.</p> <p>$\zeta_1$ì˜ orederê°€ $3^l \cdot 2^e$ ê¼´ì´ì–´ì•¼ í•˜ë¯€ë¡œ $\zeta_1 = \psi_n^{n/6}$ ì´ë¼ í•˜ê³ ,</p> <p>orderê°€ ìµœì†Œì¸ 6ì¼ ë•Œ</p> \[\zeta_1^6 = 1 \implies \zeta_1\cdot \zeta_2 = \zeta_1\cdot\zeta_1^5 = 1\] <p>ì´ë¯€ë¡œ ë‚˜ë¨¸ì§€ í•˜ë‚˜ì˜ ê·¼ì€ $\zeta_2 = \zeta_1^5$ ë¼ í•œë‹¤.</p> </li> </ul> <p>The main observation they use is the CRT map, as follows</p> \[\mathbb{Z}_q[x]/(x^n - x^{n/2} + 1) \;\cong\; \mathbb{Z}_q[x]/(x^{n/2} - \zeta_1) \times \mathbb{Z}_q[x]/(x^{n/2} - \zeta_2),\\[.5em] \text{where \; } \zeta_1 + \zeta_2 = 1\text{ and }\zeta_1 \cdot \zeta_2 = 1.\] <p>In their instantiation, they choose $\zeta_1 = \psi_n^{n/6}$ and $\zeta_2 = \zeta_1^5$.</p> <p>As for its forward transform, $\boldsymbol{a} \in \mathbb{Z}q[x]/(x^n - x^{n/2} + 1)$ from the $0$-th level generates its images</p> \[\boldsymbol{a}_l = \boldsymbol{a} \bmod x^{n/2} - \zeta_1 \in \mathbb{Z}q[x]/(x^{n/2} - \zeta_1)\\[.5em] \text{and}\quad \boldsymbol{a}_r = \boldsymbol{a} \bmod x^{n/2} - (1 - \zeta_1) \in \mathbb{Z}q[x]/(x^{n/2} - \zeta_2)\] <p>respectively in the first level, by using the fact that $\zeta_2 = 1 - \zeta_1$. In order to get the coefficients, one can compute</p> \[\quad a_{l,i} = a_i + \zeta_1 a_{i+n/2}, \;\; a_{r,i} = a_i + a_{i+n/2} - \zeta_1 a_{i+n/2}\quad (i = 0, 1, \dots, n/2 - 1).\] <p>Different from the radix-2 Cooley-Tukey algorithm, there are extra $n/2$ additions in this case.</p> <p>These additional additions donâ€™t cost much.</p> <p>For a fast NTT algorithm, one can continue with a similar radix-2 ($\log \frac{n}{3}$)-level FFT trick in $\mathbb{Z}_q[x]/(x^{n/2} - \zeta_1)$ and $\mathbb{Z}_q[x]/(x^{n/2} - \zeta_2)$, as in the power-of-two cyclotomic rings above,</p> <p>until the leaf nodes are of the form $\mathbb{Z}_q[x]/(x^3 - \psi_n^j)$ instead of linear terms.</p> <p>The inverse transform can be obtained by inverting the trick mentioned above, where Gentleman-Sande butterflies are used in the radix-2 steps.</p> <p>The point-wise multiplication is performed about the corresponding polynomials of degree 2 in each $\mathbb{Z}_q[x]/(x^3 - \psi_n^j)$. Detailedly, the CRT map can be described as follows</p> \[\mathbb{Z}_q[x]/(x^n - x^{n/2} + 1) \;\cong\; \prod_{j \in \mathbb{Z}_n^\times} \mathbb{Z}_q[x]/(x^3 - \psi_n^j),\] <p>where $\mathbb{Z}_n^\times$ is the group of invertible elements of $\mathbb{Z}_n$.</p> <h5 id="splitting-polynomial-ring-over-mathbbz_qxxn--xn2-1">Splitting Polynomial Ring over $\mathbb{Z}_q[x]/(x^n -x^{n/2} +1)$</h5> <p>The method based on splitting the polynomial ring can be generalized to the ring $\mathbb{Z}_q[x]/(x^n - x^{n/2} + 1)$ where $n = 3 \cdot 2^e$ and $q$ is a prime number, based on which Liang et al. proposed a generalized, modular, and parallelizable NTT method referred to as Generalized 3-NTT (G3-NTT for simplicity).</p> <p>Similarly, let $\alpha, \beta$ be non-negative integers. The general $\alpha$-round G3-NTT with $\beta$ levels cropped is essentially based on the following isomorphism.</p> \[\Psi_{\alpha, 3} : \mathbb{Z}_q[x]/(x^n - x^{n/2} + 1) \;\cong\; \left(\mathbb{Z}_q[y]/(y^{\frac{n}{3 \cdot 2^\alpha}} - y^{\frac{n}{3 \cdot 2^{\alpha+1}}} + 1)\right)[x]/(x^{3 \cdot 2^\alpha} - y) \\[1.5em] \boldsymbol{a} = \sum_{i=0}^{n-1} a_i x^i \;\mapsto\; \Psi_{\alpha, 3}(\boldsymbol{a}) =\!\!\! \sum_{i=0}^{3 \cdot 2^\alpha - 1}\!\! \left( \sum_{j=0}^{({n}/{3 \cdot 2^\alpha}) - 1 \!\!\!\!\!\!} a_{3 \cdot 2^\alpha \cdot j + i} y^j \right)\! x^i\] <p>where $y^{ {n}/{3 \cdot 2^\alpha}} - y^{ {n}/{3 \cdot 2^{\alpha+1}}} + 1$ is the ${n}/{2^\alpha}$-th cyclotomic polynomial of degree ${n}/{3 \cdot 2^\alpha}$.</p> <p>Similar to NTTRU, there is a CRT map as follows</p> \[\mathbb{Z}_q[y]/(y^{ {n}/{3 \cdot 2^\alpha}\!\!\!} - y^{ {n}/{3 \cdot 2^{\alpha+1}}\!\!\!} + 1) \;\cong\; \mathbb{Z}_q[y]/(y^{ {n}/{3 \cdot 2^{\alpha+1}}\!\!\!} - \zeta_1) \times \mathbb{Z}_q[y]/(y^{ {n}/{3 \cdot 2^{\alpha+1}}\!\!\!} - \zeta_2)\] <p>where $\zeta_1 + \zeta_2 = 1,\ \zeta_1 \cdot \zeta_2 = 1$.</p> <p>It turns out that radix-2 truncated-NTTs can be performed in $\mathbb{Z}_q[y]/(y^{ {n}/{3 \cdot 2^{\alpha+1}}} - \zeta_1)$ and $\mathbb{Z}_q[y]/(y^{ {n}/{3 \cdot 2^{\alpha+1}}} - \zeta_2)$.</p> <p>If there are $\beta$ levels to be cropped, $\beta = 0, 1, \dots, \log \frac{n}{3 \cdot 2^\alpha} - 1$, the modulus $q$ can be chosen to satisfy only $q \equiv 1 \bmod{ n/2{\alpha+\beta}}}$ such that the primitive ${n}/{2^{\alpha+\beta}}$-th root of unity $\psi_{n/2^{\alpha+\beta}}$ exits.</p> <p>The leaf nodes of the CRT tree map are degree-$2^\beta$ polynomials, e.g., $\mathbb{Z}<em>q[y]/(y^{2^\beta} - \psi</em>{n/2^{\alpha+\beta}}^j)$.</p> <p>They choose $\zeta_1 = \psi_{n/2^{\alpha+\beta}}^{n/(6 \cdot 2^{\alpha+\beta})}$ and $\zeta_2 = \zeta_1^5$.</p> <p>One-iteration Karatsuba algorithm can be used in a same way as H-NTT.</p> <p>Given appropriate and fixed $(n, q)$, the computational complexity of G3-NTT can reach its optimization if $\alpha = 0, \beta = 0$.</p> <h3 id="basic-radix-2-fast-number-theoretic-transform">BASIC RADIX-2 FAST NUMBER THEORETIC TRANSFORM</h3> <p>Here, â€œradix-2â€ means the length $n$ of NTT has a factor as a power of two, resulting that original algorithm can be divided into two parts of less length.</p> <table> <thead> <tr> <th>Transforms</th> <th>Cooley-Tukey algorithm</th> <th>Gentleman-Sande algorithm</th> </tr> </thead> <tbody> <tr> <td>$\text{NTT}$</td> <td>$\text{NTT}<em>{bo\to no}^{CT}, \text{NTT}</em>{no\to bo}^{CT}$</td> <td>$\text{NTT}<em>{bo\to no}^{GS}, \text{NTT}</em>{no\to bo}^{GS}$</td> </tr> <tr> <td>$\text{INTT}$</td> <td>$\text{INTT}<em>{bo\to no}^{CT}, \text{INTT}</em>{no\to bo}^{CT}$</td> <td>$\text{INTT}<em>{bo\to no}^{GS}, \text{INTT}</em>{no\to bo}^{GS}$</td> </tr> <tr> <td>$\text{NTT}^\psi$</td> <td>$\text{NTT}<em>{bo\to no}^{CT, \psi}, \text{NTT}</em>{no\to bo}^{CT, \psi}$</td> <td>â€”</td> </tr> <tr> <td>$\text{INTT}^{\psi^{-1}}$</td> <td>â€”</td> <td>$\text{INTT}<em>{bo\to no}^{GS, \psi^{-1}}, \text{INTT}</em>{no\to bo}^{GS, \psi^{-1}}$</td> </tr> </tbody> </table> <h4 id="fft-trick">FFT Trick</h4> <h5 id="thm-chinese-remainder-theorem-in-ring-form">Thm. Chinese Remainder Theorem in ring form</h5> <p>Let $R$ be a commutative ring with multiplicative identity,</p> <p>$I_1, I_2,\,â€¦\,,I_k$ be ideals in $R$ that are pairwise co-prime, and $I$ be their intersection.</p> <p>Then there is a ring isomorphism</p> \[\Phi:R/I\cong R/I_1 \times R/I_2 \times \cdots \times R/I_k.\] <p>FFT trick means that according to Theorem,</p> <p>for polynomial rings $\mathbb{Z}_q[x]/(x^{2m}-\omega^2)$ where $m&gt;0$ and invertible $\omega\in\mathbb{Z}_q$,</p> \[\Phi: \mathbb{Z}_q[x]/(x^{2m} - \omega^2) \;\cong\; \mathbb{Z}_q[x]/(x^m - \omega) \times \mathbb{Z}_q[x]/(x^m + \omega) \\[.5em] \boldsymbol{a} \mapsto (\boldsymbol{a}' = \boldsymbol{a} \bmod x^m - \omega, \boldsymbol{a}'' = \boldsymbol{a} \bmod x^m + \omega)\] <p>and the detailed mapping process</p> \[\Phi\left(\sum_{i=0}^{2m-1} a_i x^i\right) = \left(\sum_{i=0}^{m-1} (a_i + \omega \cdot a_{i+m}) x^i,\;\ \sum_{i=0}^{m-1} (a_i - \omega \cdot a_{i+m}) x^i\right) \\[1.5em] \Phi^{-1}\left(\sum_{i=0}^{m-1} a'_i x^i,\;\ \sum_{i=0}^{m-1} a''_i x^i\right) =\; \sum_{i=0}^{m-1} \frac{1}{2}(a'_i + a''_i) x^i + \sum_{i=0}^{m-1} \frac{\omega^{-1}}{2}(a'_i - a''_i) x^{i+m}.\] <p>As for the forward FFT trick, it is very effective to compute $\boldsymbol{a}â€™$ and $\boldsymbol{a}â€™â€™$.</p> <p>Their $i$-th coefficient can be computed via</p> \[a'_i = a_i + \omega \cdot a_{i+m},\;\; a''_i = a_i - \omega \cdot a_{i+m},\] <p>where $\omega \cdot a_{i+m}$ is computed once but used twice, $i = 0, 1, \dots, m-1$.</p> <p>This type of operation is known as the Cooley-Tukey butterfly or CT butterfly<code class="language-plaintext highlighter-rouge">Multiplication â†’ Addition</code> for short.</p> <p><img src="/june.github.io/assets/img/post/ntt/image.png" alt="image"> </p> <p>The forward FFT trick totally takes $m$ multiplications, $m$ additions, and $m$ subtractions.</p> <p>As for the inverse FFT trick, the $i$-th and $(i + \frac{n}{2})$-th coefficient of $\boldsymbol{a}$ can be derived from the $i$-th coefficient of $\boldsymbol{a}â€™$ and $\boldsymbol{a}â€™â€™$.</p> \[a_i = (a'_i + a''_i)/2,\quad a_{i+m} = \omega^{-1}(a'_i - a''_i)/2\quad (i = 0, 1, \dots, m-1).\] <p>In the practical applications, the scale factor 2 can be omitted, with multiplying a total factor in the end.</p> <p>This type of operation is known as Gentlemen-Sande butterfly or GS butterfly<code class="language-plaintext highlighter-rouge">Addition â†’ Multiplication</code> for short.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_1.png" alt="image"> </p> <p>Based on the FFT trick, introduce the fast algorithms to compute NTT and INTT over $\mathbb{Z}_q[x]/(x^n - 1)$, as well as $\text{NTT}^\psi$ and $\text{INTT}^{\psi^{-1}}$ over $\mathbb{Z}_q[x]/(x^n + 1)$ in the subsequent two subsections.</p> <h4 id="fft-trick-for-cc-based-ntt-over-mathbbz_qxxn---1">FFT Trick for CC-based NTT over $\mathbb{Z}_q[x]/(x^n - 1)$</h4> <p>How to use the FFT trick to compute NTT and INTT over $\mathbb{Z}_q[x]/(x^n - 1)$,</p> <p>where $n$ is a power of two and $q$ is a prime number satisfying $q \equiv 1 \pmod n$.</p> <p>Denote by $\omega_n$ the primitive $n$-th root of unity in $\mathbb{Z}_q$.</p> \[\mathbb{Z}_q[x]/(x^n - 1) \;\cong\; \mathbb{Z}_q[x]/(x^{\frac{n}{2} } - 1) \times \mathbb{Z}_q[x]/(x^{\frac{n}{2} } + 1)\] <p>Notice that the forward FFT trick can be applied repeatedly to map $\mathbb{Z}_q[x]/(x^{\frac{n}{2} } \pm 1)$, according to the fact $x^{\frac{n}{2} } + 1 = x^{\frac{n}{2} } - \omega_n^{\frac{n}{2} }$.</p> <p>In fact, $x^n - 1$ has $n$ distinct roots in $\mathbb{Z}_q$, i.e., $\omega_n^i\ (i = 0, 1, \dots, n-1)$.</p> <p>Therefore, forward FFT trick can be applied recursively from $\mathbb{Z}_q[x]/(x^n - 1)$ all the way down to linear terms,</p> \[\mathbb{Z}_q[x]/(x^n - 1) \cong \prod_{i=0}^{n-1} \mathbb{Z}_q[x]/(x - \omega_n^{\text{brv}_n(i)}).\] <p>Finally, $\boldsymbol{a}$ generates its images in $\mathbb{Z}<em>q[x]/(x - \omega_n^{\text{brv}_n(i)})$, i.e., $\hat{a}</em>{\text{brv}_n(i)}$, which turns out to be the coefficient of $\hat{\boldsymbol{a}}$ indexed by $\text{brv}_n(i)$.</p> <p>Notice that using the Cooley-Tukey algorithm, the coefficients of the input polynomials are indexed under natural order, while the coefficients of the output polynomials are indexed under bit-reversed order.</p> <p>This Cooley-Tukey NTT algorithm is denoted by $\text{NTT}^{CT}_{no \to bo}$,</p> <p>where the subscripts $no \to bo$ indicate that the input coefficients are under natural order and the output coefficients are under bit-reversed order.</p> <p>The signal flow of $\text{NTT}^{CT}_{no \to bo}$ for $n=8$ can be seen in Figure (c).</p> <p><img src="/june.github.io/assets/img/post/ntt/image_2.png" alt="image"> </p> <p>Adjust the input to bit-reversed order, then the Cooley-Tukey butterflies in the signal flow are changed elsewhere, as in Figure (a). The output will be under natural order. This type of NTT is denoted by $\text{NTT}^{CT}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_3.png" alt="image"> </p> <p>Figure 2 shows the detailed process of using FFT trick to map $\mathbb{Z}_q[x]/(x^n - 1)$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_4.png" alt="image"> </p> <p>The mapping process takes on the shape of a binary tree, with the root node being the $0$-th level and the leaf nodes being the $(\log n)$-th level. <code class="language-plaintext highlighter-rouge">(x^n-1) â†’ (x-1) * (x+1) *â€¦* (x-w^{(n/2)-1} * (x+w^{(n/2)-1})</code></p> <p>After the $k$-th level, $0 \le k &lt; \log n$, there are $2^{k+1}$ nodes.</p> <p>The fast algorithm to compute INTT can be obtained by iteratively inverting the CRT mappings.</p> <p>In this case, the coefficients of the input polynomials are indexed under bit-reversed order, i.e., $\hat{a}_{\text{brv}_n(i)}\ (i = 0, 1, \dots, n-1)$.</p> <p>Apply the inverse FFT trick to the computation from the $(k+1)$-th level to the $k$-th level, where $1 \le k &lt; \log n$. <code class="language-plaintext highlighter-rouge">(x-1) * (x+1) *â€¦* (x-w^{(n/2)-1} * (x+w^{(n/2)-1}) -&gt; (x^n-1)</code></p> <p><img src="/june.github.io/assets/img/post/ntt/image_5.png" alt="image"> </p> <p><img src="/june.github.io/assets/img/post/ntt/image_6.png" alt="image"> </p> <p>Note that the scale factor 2 in each level of the Gentleman-Sande butterfly can be omitted,</p> <p>with multiplying the final result by $n^{-1}$ in the end.</p> <p>The coefficients of the output polynomials are indexed under natural order.</p> <p>This type of Gentleman-Sande INTT algorithm is denoted by $\text{INTT}^{GS}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_7.png" alt="image"> </p> <p>Adjust its input/output order and we can obtain $\text{INTT}^{GS}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_8.png" alt="image"> </p> <ul> <li> <p>$\text{NTT}^{GS}$</p> <p><img src="/june.github.io/assets/img/post/ntt/image_9.png" alt="image"> </p> <p><img src="/june.github.io/assets/img/post/ntt/image_10.png" alt="image"> </p> </li> </ul> <h4 id="fft-trick-for-nwc-based-ntt-over-mathbbz_qxxn--1">FFT Trick for NWC-based NTT over $\mathbb{Z}_q[x]/(x^n + 1)$</h4> <p>The FFT trick to compute $\text{NTT}^\psi$ and $\text{INTT}^{\psi^{-1}}$ over $\mathbb{Z}_q[x]/(x^n + 1)$,</p> <p>where $n$ is a power of two and $q$ is a prime number satisfying $q \equiv 1 \pmod{2n}$.</p> <p>Since $\psi_{2n}^{n/2} \equiv -1 \pmod q$, it holds that</p> \[x^n + 1 = x^n - \psi_{2n}^{n/2} = (x^{n/2} - \psi_{2n}^{n/2})(x^{n/2} + \psi_{2n}^{n/2}) \pmod q.\] <p>As for $\text{NTT}^\psi$, the forward FFT trick implies that we have the following isomorphism</p> \[\mathbb{Z}_q[x]/(x^n + 1) \;\cong\; \mathbb{Z}_q[x]/(x^{\frac{n}{2} } - \psi_{2n}^{\frac{n}{2} }) \times \mathbb{Z}_q[x]/(x^{\frac{n}{2} } + \psi_{2n}^{\frac{n}{2} })\] <p>FFT trick can be applied repeatedly.</p> <p>Notice that $x^n + 1$ has $n$ distinct roots in $\mathbb{Z}<em>q$, i.e., $\psi</em>{2n}^{2i+1}, i = 0, 1, \dots, n-1$.</p> <p>Therefore, there is a CRT isomorphism similarly.</p> \[\mathbb{Z}_q[x]/(x^n + 1) \;\cong\; \prod_{i=0}^{n-1} \mathbb{Z}_q[x]/(x - \psi_{2n}^{2\text{brv}_n(i)+1}).\] <p>Figure 3 shows the detailed process of using FFT trick to map $\mathbb{Z}_q[x]/(x^n + 1)$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_11.png" alt="image"> </p> <p>After the $k$-th level, where $0 \le k &lt; \log n$, it produces</p> \[\qquad\mathbb{Z}_q[x]/(x^{n/2^{k+1}} \pm \psi_{2n}^{\text{brv}_n(2^k+i)})\qquad (i = 0, 1, \dots, 2^k - 1 )\] <p>with pairs of rings.</p> <p>Such fast algorithm of $\text{NTT}^\psi$ is denoted by $\text{NTT}^{CT, \psi}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_12.png" alt="image"> </p> <p>Similarly, by adjusting its input/output order, we can get $\text{NTT}^{CT, \psi}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_13.png" alt="image"> </p> <p>Similarly, the fast algorithm to compute $\text{INTT}^{\psi^{-1}}$ can be obtained by iteratively inverting the CRT mapping process.</p> <p>This type of fast algorithm for $\text{INTT}^{\psi^{-1}}$ is denoted by $\text{INTT}^{GS, \psi^{-1}}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_14.png" alt="image"> </p> <p>Adjust the input/output order and get $\text{INTT}^{GS, \psi^{-1}}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_15.png" alt="image"> </p> <p>Omitting the scale factor 2 in each level can multiply the final result by $n^{-1}$ in the end.</p> <p>There is an alternative way to deal with the total factor $n^{-1}$.</p> <p>Zhang et al. noticed that $n^{-1}$ can both be integrated into the computing process of each level, based on the fact that the scale factor 2 will be dealt with directly, by using addition and displacement<code class="language-plaintext highlighter-rouge">shifting</code> to compute $x/2 \bmod q$.</p> \[x/2 \equiv \begin{cases} (x \gg 1) \mod q,&amp; x\text{ is even}\\ (x \gg 1) + (q+1)/2 \mod q, &amp; x\text{ is odd} \end{cases}\] <h4 id="twisted-fft-trick">Twisted FFT Trick</h4> <p>The Gentleman-Sande algorithm can be applied to compute NTT,</p> <p>and the Cooley-Tukey algorithm can be applied to compute INTT.</p> <p>It means, mapping</p> \[\mathbb{Z}_q[x]/(x^n - 1) \;\cong\; \mathbb{Z}_q[x]/(x^{\frac{n}{2} } - 1) \times \mathbb{Z}_q[x]/(x^{\frac{n}{2} } + 1)\] <p>by CRT, followed by mapping $\mathbb{Z}_q[x]/(x^{ n/2 } + 1)$ via following isomorphism</p> \[\Psi: \mathbb{Z}_q[x]/(x^{ n/2 } + 1) \;\cong\; \mathbb{Z}_q[x]/(x^{ n/2 } - 1) \\[.3em] x \mapsto \omega_n x\] <p>Thus, as for $\mathbb{Z}_q[x]/(x^n - 1)$, there is</p> \[\Psi\Phi: \mathbb{Z}_q[x]/(x^n - 1) \;\cong\; \mathbb{Z}_q[x]/(x^{ n/2 } - 1) \times \mathbb{Z}_q[x]/(x^{ n/2 } - 1) \\[.5em] \boldsymbol{a} \mapsto (\boldsymbol{a}', \boldsymbol{a}'')\] <p>and the detailed functioning process</p> \[\begin{aligned} &amp;(\Psi\Phi)\left(\sum_{i=0}^{n-1} a_i x^i\right) \ =\ \left(\sum_{i=0}^{ n/2\,-1\!} (a_i + a_{i+{n}/{2} }) x^i, \sum_{i=0}^{ n/2\,-1\!\!} \omega_n^i \!\cdot\! (a_i - a_{i+{n}/{2} }) x^i\right) \\[2.5em] &amp;(\Psi\Phi)^{-1}\!\!\left(\sum_{i=0}^{ n/2\,-1\!\!} a'_i x^i, \sum_{i=0}^{ n/2\,-1\!\!} a''_i x^i\!\right) \\[1.5em] &amp; =\ \sum_{i=0}^{ n/2\,-1\!} \frac{a'_i + \omega_n^{-i} \cdot a''_i}{2} x^i + \sum_{i=0}^{ n/2\,-1\!} \frac{a'_i - \omega_n^{-i} \cdot a''_i}{2} x^{i+{n}/{2} }. \end{aligned}\] <p>As for the forward twisted FFT trick, for example, $\boldsymbol{a} \in \mathbb{Z}_q[x]/(x^n - 1)$ in the $0$-th level generates $\boldsymbol{a}â€™$ and $\boldsymbol{a}â€™â€™$, where</p> \[\qquad a'_i = a_i + a_{i+\frac{n}{2} }, a''_i = \omega_n^i \cdot (a_i - a_{i+\frac{n}{2} })\qquad (i = 0, 1, \dots, n/2 - 1),\] <p>where Gentleman-Sande algorithm are used.</p> <p>It can be applied repeatedly to map $\mathbb{Z}_q[x]/(x^{ n/2 } - 1)$, and down to linear terms such as $\mathbb{Z}_q[x]/(x \mp 1)$.</p> <p>Specifically, in the $k$-th level, the similar isomorphism $\Psi: x \mapsto \omega_n^{2^{k-1}} x$ is applied from $\mathbb{Z}_q[x]/(x^{n/2^k} + 1)$ to $\mathbb{Z}_q[x]/(x^{n/2^k} - 1)$, $1 \le k &lt; \log n$.</p> <p>The complete process of twisted FFT trick on mapping $\mathbb{Z}_q[x]/(x^n - 1)$ is shown in Figure 4.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_16.png" alt="image"> </p> <p>Such GS NTT algorithm is denoted by $\text{NTT}^{GS}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_17.png" alt="image"> </p> <p>Adjust the input/output order, and we obtain $\text{NTT}^{GS}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_18.png" alt="image"> </p> <p>The inverse twisted FFT trick is computed in much the same way by iteratively inverting the above process. For example, the process of computing $\boldsymbol{a}$ in the $0$-th level from $\boldsymbol{a}â€™$ and $\boldsymbol{a}â€™â€™$ in the first level with Cooley-Tukey butterflies is as follows</p> \[a_i = (a'_i + \omega_n^{-i} \cdot a''_i)/2, a_{i+{n}/{2} } = (a'_i - \omega_n^{-i} \cdot a''_i)/2\qquad (i = 0, 1, \dots, n/2 - 1).\] <p>Such computing from the $(k+1)$-th level to the $k$-th level can be achieved in the same way, where $1 \le k &lt; \log n$. The scale factor 2 in each level can be omitted, with multiplying the final result by $n^{-1}$ in the end. We denote this type of CT INTT by $\text{INTT}^{CT}_{bo \to no}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_6.png" alt="image"> </p> <p>Adjust its input/output order and the new transform is denoted by $\text{INTT}^{CT}_{no \to bo}$.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_5.png" alt="image"> </p> <p>Notice that there only exists fast algorithm based on Cooley-Tukey butterfly for $\text{NTT}^\psi$, and that based on Gentleman-Sande butterfly for $\text{INTT}^{\psi^{-1}}$. This is because, once we use Gentleman-Sande butterfly to compute $\text{NTT}^\psi$ or use Cooley-Tukey butterfly to compute $\text{INTT}^{\psi^{-1}}$, the $\psi_{2n}$ term can not be further processed.</p> <h4 id="radix-2-fast-number-theoretic-transform-from-fft-perspectives">RADIX-2 FAST NUMBER THEORETIC TRANSFORM FROM FFT PERSPECTIVES</h4> <p>This section describes NTT algorithms from FFT perspectives.</p> <p>The basic principle of fast NTT algorithms is using â€œdivide and conquerâ€ skill to divide the $n$-point NTT into two $n/2$-point NTTs, based on the periodicity and symmetry of the primitive root of unity.</p> <p>The properties of primitive roots of unity in NTT are similar to those of twiddle factors in FFT.</p> <p>The primitive $n$-th root of unity $\omega_n$ in $\mathbb{Z}_q$ has the following properties</p> \[\text{periodicity: } \omega_n^{k+n} = \omega_n^k\\[.5em] \text{symmetry: } \omega_n^{k+n/2} = -\omega_n^k\] <p>where $k$ is a non-negative integer.</p> <p>It is trivial that the primitive $2n$-th root of unity $\psi_{2n}$ shares similar properties if $\psi_{2n}$ exists.</p> <h5 id="cooley-tukey-algorithm-for-cc-based-ntt">Cooley-Tukey Algorithm for CC-based NTT</h5> <ol> <li> <p><strong>NTT</strong></p> <p>Based on the parity of the indexes of the coefficients $a_i$ in $\boldsymbol{a}$, the terms can be separated into two parts, for $j = 0, 1, \dots, n-1$,</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} \omega_n^{2ij} + \sum_{i=0}^{n/2-1} a_{2i+1} \omega_n^{(2i+1)j} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} + \omega_n^j \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, for $j = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} + \omega_n^j \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} \bmod q \\[1.5em] \hat{a}_{j+n/2} &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} - \omega_n^j \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} \hat{a}'_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} \bmod q,\\[1.5em] \hat{a}''_j &amp;= \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} \bmod q,\quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>Formula can be rewritten as</p> \[\begin{aligned} \hat{a}_j &amp;= \hat{a}'_j + \omega_n^j \hat{a}''_j \bmod q, \\[.7em] \hat{a}_{j+n/2} &amp;= \hat{a}'_j - \omega_n^j \hat{a}''_j \bmod q, \quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>One can learn from the definition of NTT that, $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$ can be computed by $n/2$-point NTT, from the even-indexed and the odd-indexed coefficients of $\boldsymbol{a}$, respectively.</p> <p>Formula shows that, the original $n$-point NTT can be divided into two $n/2$-point NTTs by â€œdivide-and-conquerâ€ method.</p> <p>After getting the $n/2$-point NTT results $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$, the original $n$-point $<br> \hat{\boldsymbol{a}}$ can be easily achieved by multiplying $\omega_n^j$ and simple additions/subtractions.</p> <p>This kind of â€œdivide and conquerâ€ skill can also be applied to compute $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$.</p> <p>Since $n$ is a power of two, it can be separated down to 2-point NTTs.</p> <p>Note that, the coefficients of the input polynomials are indexed under bit-reversed order, while the coefficients of the output polynomials are indexed under natural order.</p> </li> <li> <p><strong>INTT</strong></p> <p>Cooley-Tukey butterfly can also be applied to compute INTT. In contrast to NTT, there is extra multiplications by a scale factor $n^{-1}$ in INTT.</p> <p>With neglecting $n^{-1}$, the terms in the summation are the same as those in NTT formula, except replacing $\omega_n$ with $\omega_n^{-1}$.</p> <p>For the convenience of understanding, its brief computing process is given here.</p> \[a_i = \sum_{j=0}^{n/2-1} \hat{a}_{2j} (\omega_n^2)^{-ij} + \omega_n^{-i} \sum_{j=0}^{n/2-1} \hat{a}_{2j+1} (\omega_n^2)^{-ij} \bmod q. \quad i = 0, 1, \dots, n-1\] <p>Let</p> \[\begin{aligned} a'_i &amp;= \sum_{j=0}^{n/2-1} \hat{a}_{2j} (\omega_n^2)^{-ij} \bmod q,\\[1.5em] a''_i &amp;= \sum_{j=0}^{n/2-1} \hat{a}_{2j+1} (\omega_n^2)^{-ij} \bmod q,\quad i = 0, 1, \dots, n/2 - 1. \end{aligned}\] \[\begin{aligned} a_i &amp;= a'_i + \omega_n^{-i} a''_i \bmod q \\[1em] a_{i+n/2} &amp;= a'_i - \omega_n^{-i} a''_i \bmod q, \quad i = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>Therefore, the computing of $n$-point INTT can be divided into two $n/2$-point INTTs, which can be done down to 2-point INTTs finally.</p> </li> </ol> <h5 id="gentlemen-sande-algorithm-for-cc-based-ntt">Gentlemen-Sande Algorithm for CC-based NTT</h5> <ol> <li> <p><strong>NTT</strong></p> <p>Gentlemen-Sande algorithm separates the coefficients of $\boldsymbol{a}$ into the upper half and the lower half. Specifically, for $j = 0, 1, \dots, n-1$,</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_i \omega_n^{ij} + \sum_{i=n/2}^{n-1} a_i \omega_n^{ij} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} a_i \omega_n^{ij} + \sum_{i=0}^{n/2-1} a_{i+n/2} \omega_n^{(i+n/2)j} \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, the terms $\hat{a}_j$ continue to be dealt with according to the parity of index $j$. For $j = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} \hat{a}_{2j} &amp;= \sum_{i=0}^{n/2-1} a_i \omega_n^{2ij} + (-1)^{2j} \cdot \sum_{i=0}^{n/2-1} a_{i+n/2} \omega_n^{2ij} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} (a_i + a_{i+n/2}) (\omega_n^2)^{ij} \bmod q, \\[1.5em] \hat{a}_{2j+1} &amp;= \sum_{i=0}^{n/2-1} a_i \omega_n^{(2j+1)i} + (-1)^{2j+1} \cdot \sum_{i=0}^{n/2-1} a_{i+n/2} \omega_n^{(2j+1)i} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} \left[ (a_i - a_{i+n/2}) \cdot \omega_n^i \right] (\omega_n^2)^{ij} \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} b'_i &amp;= a_i + a_{i+n/2} \bmod q,\\[1em] b''_i &amp;= (a_i - a_{i+n/2}) \cdot \omega_n^i \bmod q, i = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>The above formula can be rewritten as</p> \[\begin{aligned} \hat{a}_{2j} &amp;= \sum_{i=0}^{n/2-1} b'_i (\omega_n^2)^{ij} \bmod q, \\[1.5em] \hat{a}_{2j+1} &amp;= \sum_{i=0}^{n/2-1} b''_i (\omega_n^2)^{ij} \bmod q, \quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>One can learn from the definition of NTT that, formula is exact the $n/2$-point NTTs with respect to $bâ€™_i, bâ€™â€˜_i\, (i = 0, 1, \dots, n/2 - 1)$.</p> <p>Thus, after deriving $bâ€™_i, bâ€™â€˜_i$ from $a_i$, the original $n$-point NTT is transformed into $n/2$-point NTTs with respect to $bâ€™_i, bâ€™â€˜_i$.</p> <p>Similarly, the $n/2$-point NTT can be transformed into $n/4$-point NTTs, and down to 2-point NTTs.</p> </li> <li> <p><strong>INTT</strong></p> <p>Gentleman-Sande butterfly can be similarly applied to compute INTT, by neglecting $n^{-1}$ and replacing $\omega_n$ with $\omega_n^{-1}$ in NTT. That is, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= \sum_{j=0}^{n/2-1} (\hat{a}_j + \hat{a}_{j+n/2}) (\omega_n^2)^{-ij} \bmod q \\[1.5em] a_{2i+1} &amp;= \sum_{i=0}^{n/2-1} \left[ (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \omega_n^{-j} \right] (\omega_n^2)^{-ij} \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} \hat{b}'_j &amp;= \hat{a}_j + \hat{a}_{j+n/2} \bmod q,\\[1em] \hat{b}''_j &amp;= (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \omega_n^{-j} \bmod q,\quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>Formula can be rewritten as:</p> \[\begin{aligned} a_{2i} &amp;= \sum_{j=0}^{n/2-1} \hat{b}'_j (\omega_n^2)^{-ij} \bmod q \\ a_{2i+1} &amp;= \sum_{j=0}^{n/2-1} \hat{b}''_j (\omega_n^2)^{-ij} \bmod q, \quad i = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>Similarly, $n$-point INTT can be divided into two $n/2$-point INTTs, and down to 2-point INTTs.</p> </li> </ol> <h5 id="radix-2-fast-nwc-based-ntt">Radix-2 Fast NWC-based NTT</h5> <p>The process of multiplying the coefficients by $\psi_{2n}^i$ before forward transform is referred to as pre-processing,</p> <p>while the process of multiplying the coefficients by $\psi_{2n}^{-i}$ after inverse transform is referred to as post-processing.</p> <p>Fast algorithms for NWC-based NTT, such as $\text{NTT}^\psi$ and $\text{INTT}^{\psi^{-1}}$, can be constructed by using radix-2 CT/GS NTT/INTT algorithm with pre-processing and post-processing.</p> <p>However, such construction requires extra point-wise multiplication with $\boldsymbol{\psi}/\boldsymbol{\psi}^{-1}$ besides radix-2 algorithms, resulting with $n$ extra multiplications. In fact, these additional multiplications are not necessary.</p> <ul> <li>Roy et al. integrate the pre-processing about $\boldsymbol{\psi}$ into $\text{NTT}^{CT}_{bo \to no}$.</li> <li>PÃ¶ppelmann et al. integrate the post-processing about $\boldsymbol{\psi}^{-1}$ into $\text{INTT}^{GS}_{bo \to no}$.</li> <li>Furthermore, Zhang et al. integrate $\boldsymbol{\psi}^{-1}$ and $n^{-1}$ into $\text{INTT}^{GS}_{bo \to no}$. <ol> <li><strong>Cooley-Tukey algorithm for $\text{NTT}^\psi$</strong></li> </ol> <p>According to the definition of $\text{NTT}^\psi$, the coefficients of $\hat{\boldsymbol{a}}$ can be written as</p> \[\hat{a}_j = \sum_{i=0}^{n-1} a_i \psi_{2n}^i \omega_n^{ij} \bmod q, \quad j = 0, 1, \dots, n - 1.\] <p>Divide the summation into two parts based on the parity of the index of $a_i$, and for $j = 0, 1, \dots, n - 1$, we get</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} \omega_n^{2ij} \psi_{2n}^{2i} + \sum_{i=0}^{n/2-1} a_{2i+1} \omega_n^{(2i+1)j} \psi_{2n}^{2i+1} \bmod q \\[1.5em] &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i + \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, for $j = 0, 1, \dots, n/2 - 1$, we get</p> \[\begin{aligned} \hat{a}_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i + \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q \\[1.5em] \hat{a}_{j+n/2} &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i - \omega_n^j \psi_{2n} \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q. \end{aligned}\] <p>Let</p> \[\begin{aligned} \hat{a}'_j &amp;= \sum_{i=0}^{n/2-1} a_{2i} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q,\\[1.5em] \hat{a}''_j &amp;= \sum_{i=0}^{n/2-1} a_{2i+1} (\omega_n^2)^{ij} (\psi_{2n}^2)^i \bmod q,\quad j = 0, 1, \dots, n/2 - 1 . \end{aligned}\] <p>With $\omega_n^j \psi_{2n} = \psi_{2n}^{2j+1}$, the above formula can be rewritten as, for $j = 0, 1, \dots, n/2 - 1$:</p> \[\hat{a}_j = \hat{a}'_j + \psi_{2n}^{2j+1} \hat{a}''_j \bmod q, \quad \hat{a}_{j+n/2} = \hat{a}'_j - \psi_{2n}^{2j+1} \hat{a}''_j \bmod q.\] <p>One can see that, $\hat{a}â€™_j$ and $\hat{a}â€™â€˜_j$ can be obtained via exact $n/2$-point $\text{NTT}^\psi$s.</p> </li> </ul> <ol> <li> <p><strong>Gentleman-Sande algorithm for $\text{INTT}^{\psi^{-1}}$</strong></p> <p>According to the definition of $\text{INTT}^{\psi^{-1}}$, the coefficients of $\boldsymbol{a}$ can be written as</p> \[a_i = n^{-1} \psi_{2n}^{-i} \sum_{j=0}^{n-1} \hat{a}_j \omega_n^{-ij} \bmod q, \quad i = 0, 1, \dots, n - 1.\] <p>With neglecting $n^{-1}$, the summation can be divided into the upper half and the lower half with respect to the index of $\hat{a}_j$.</p> <p>For $i = 0, 1, \dots, n - 1$,</p> \[\begin{aligned} a_i &amp;= \psi_{2n}^{-i} \left( \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-ij} + \sum_{j=n/2}^{n-1} \hat{a}_j \omega_n^{-ij} \right) \\[1.5em] &amp;= \psi_{2n}^{-i} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-ij} + \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-i(j+n/2)} \right] \bmod q. \end{aligned}\] <p>Based on the periodicity and symmetry of the primitive root of unity, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= \psi_{2n}^{-2i} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-2ij} + (-1)^{2i} \cdot \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-2ij} \right] \bmod q \\[1.5em] &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} (\hat{a}_j + \hat{a}_{j+n/2}) (\omega_n^2)^{-ij} \bmod q, \\[2em] a_{2i+1} &amp;= \psi_{2n}^{-(2i+1)} \left[ \sum_{j=0}^{n/2-1} \hat{a}_j \omega_n^{-(2i+1)j} + (-1)^{2i+1} \cdot \sum_{j=0}^{n/2-1} \hat{a}_{j+n/2} \omega_n^{-(2i+1)j} \right] \bmod q \\[1.5em] &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \left[ (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \omega_n^{-j} \psi_{2n}^{-1} \right] (\omega_n^2)^{-ij} \bmod q. \end{aligned}\] <p>Since $\omega_n^{-j} \psi_{2n}^{-1} = \psi_{2n}^{-(2j+1)}$, letting</p> \[\begin{aligned} \hat{b}'_j &amp;= \hat{a}_j + \hat{a}_{j+n/2} \bmod q,\\[1em] \hat{b}''_j &amp;= (\hat{a}_j - \hat{a}_{j+n/2}) \cdot \psi_{2n}^{-(2j+1)} \bmod q,\quad j = 0, 1, \dots, n/2 - 1, \end{aligned}\] <p>the above formula can be rewritten as, for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}'_j (\omega_n^2)^{-ij} \bmod q, \\[1.5em] a_{2i+1} &amp;= (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}''_j (\omega_n^2)^{-ij} \bmod q. \end{aligned}\] <p>Computing $n$-point $\text{INTT}^{\psi^{-1}}$ can be transformed into two $n/2$-point $\text{INTT}^{\psi^{-1}}$s with respect to $\hat{b}â€™_j, \hat{b}â€™â€˜_j$.</p> <p>Forthermore, $\boldsymbol{\psi}^{-1}$ and $n^{-1}$ can both be integrated into $\text{INTT}^{GS}_{bo \to no}$.</p> <p>Thus, $n^{-1}$ is no longer neglected, and for $i = 0, 1, \dots, n/2 - 1$,</p> \[\begin{aligned} a_{2i} &amp;= \left(\frac{n}{2}\right)^{-1} (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}'_j (\omega_n^2)^{-ij} \bmod q, \\[1.5em] a_{2i+1} &amp;= \left(\frac{n}{2}\right)^{-1} (\psi_{2n}^2)^{-i} \sum_{j=0}^{n/2-1} \hat{b}''_j (\omega_n^2)^{-ij} \bmod q, \end{aligned}\\[.7em] \begin{aligned} \text{where }\; &amp; \hat{b}'_j = (\hat{a}_j + \hat{a}_{j+n/2})/2 \mod q,\\[.5em]&amp; \hat{b}''_j = (\hat{a}_j - \hat{a}_{j+n/2})/2 \cdot \psi_{2n}^{-(2j+1)} \bmod q, \quad j = 0, 1, \dots, n/2 - 1. \end{aligned}\] <p>When computing $\hat{b}â€™_j$ and $\hat{b}â€™â€˜_j$, the scale factor 2 will be dealt with directly, by using addition and displacement (i.e., â€œ$\gg$â€) to compute $x/2 \bmod q$.</p> \[x/2 \equiv \begin{cases} (x \gg 1) \bmod q, &amp; x\text{ is even},\\ (x \gg 1) + (q+1)/2 \bmod q, &amp; x\text{ is odd}. \end{cases}\] </li> </ol> <h4 id="in-place-operation-reordering-and-complexity">In-place Operation, Reordering and Complexity</h4> <h5 id="in-place-operation">In-place operation</h5> <p>The Cooley-Tukey butterfly and Gentleman-Sande butterfly store the input and output data in the same address before and after the computing process, i.e., read data from some storage address for the computation, where the computing results are stored. This kind of operation is referred to as in-place operation. Obviously, there is no need of extra storage for in-place operation.</p> <h5 id="reordering">Reordering</h5> <p>The input and output order of the polynomial coefficients have to be taken into consideration.</p> <p>Although the coefficients of the practical input polynomial are under natural order,</p> <p>the output after $\text{NTT}^{CT}<em>{no \to bo}/\text{NTT}^{GS}</em>{no \to bo}$ will end under bit-reversed order,</p> <p>which is the required order for input of $\text{INTT}^{CT}<em>{bo \to no}/\text{INTT}^{GS}</em>{bo \to no}$,</p> <p>but not the required one for input of $\text{INTT}^{CT}<em>{no \to bo}/\text{INTT}^{GS}</em>{no \to bo}$.</p> <p>In this case, extra reordering is needed from bit-reversed order to natural order.</p> <p>Besides, if NTT is conducted via $\text{NTT}^{CT}<em>{bo \to no}$ and $\text{NTT}^{GS}</em>{bo \to no}$, the input polynomial is supposed to be reordered from natural order to bit-reversed order.</p> <p>Similarly, there is a requirement on reordering the output polynomial of $\text{INTT}^{CT}<em>{no \to bo}$ and $\text{INTT}^{GS}</em>{no \to no}$.</p> <p>In a word, there is a way for cyclic convolution-based polynomial multiplication without reordering, i.e., for $\ddagger, \natural \in {CT, GS}$</p> \[\boldsymbol{c} = \text{INTT}^{\ddagger}_{bo \to no} \left( \text{NTT}^{\natural}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{\natural}_{no \to bo}(\boldsymbol{b}) \right).\] <p>Similarly, there is a way for NWC-based polynomial multiplication without extra reordering:</p> \[\boldsymbol{c} = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right).\] <h5 id="complexity-1">Complexity</h5> <p>The complexities of NTT/INTT are given in Table.</p> <p>Each Cooley-Tukey butterfly consumes one multiplication and two additions (subtractions), where $\omega b$ is computed once and can be used twice.</p> <p>Similar analysis can also be applied to Gentleman-Sande butterfly.</p> <p>All the fast algorithms consist of $\log n$ levels, where there are ${n}/{2}$ butterfly operations on each level. As for the inverse transforms, their complexities require extra $n$ multiplications because of dealing with the scale factor $n^{-1}$.</p> <p>All the complexity of the polynomial multiplication based on these NTT fast algorithms is $O(n \log n)$, which has a significant advantage over that of polynomial multiplication based on directly-computing NTT/INTT, or any other polynomial multiplication algorithms such as the schoolbook algorithm and Karatsuba/Toom-Cook algorithm.</p> <table> <thead> <tr> <th><strong>NTT algorithms</strong></th> <th><strong>Multiplication complexities</strong></th> </tr> </thead> <tbody> <tr> <td>$\text{NTT}, \text{INTT}, \text{NTT}^\psi, \text{INTT}^{\psi^{-1}}$</td> <td>$O(n^2)$</td> </tr> <tr> <td>$\text{NTT}^{\natural}<em>{no \to bo}, \text{NTT}^{\natural}</em>{bo \to no}, \text{NTT}^{CT, \psi}<em>{no \to bo}, \text{NTT}^{CT, \psi}</em>{bo \to no}$</td> <td>$\frac{1}{2} n \log n$</td> </tr> <tr> <td>$\text{INTT}^{\ddagger}<em>{no \to bo}, \text{INTT}^{\ddagger}</em>{bo \to no}, \text{INTT}^{GS, \psi^{-1}}<em>{no \to bo}, \text{INTT}^{GS, \psi^{-1}}</em>{bo \to no}$</td> <td>$\frac{1}{2} n \log n + n$</td> </tr> <tr> <td>$\text{NTT}^{\natural}<em>{no \to bo} \circ \psi, \text{NTT}^{\natural}</em>{bo \to no} \circ \psi_{bo}$</td> <td>$\frac{1}{2} n \log n + n$</td> </tr> <tr> <td>$\psi^{-1}<em>{bo} \circ \text{INTT}^{\ddagger}</em>{no \to bo}, \psi^{-1} \circ \text{INTT}^{\ddagger}_{bo \to no}$</td> <td>$\frac{1}{2} n \log n + 2n$</td> </tr> </tbody> </table> <p>$\ddagger, \natural \in {CT, GS}$. $\psi_{bo}$ and $\psi^{-1}_{bo}$ mean that the coefficients are under bit-reversed order. $n$ is the length of NTT.</p> <h3 id="methods-to-weaken-restrictions-on-parameter-conditions-of-ntt">METHODS TO WEAKEN RESTRICTIONS ON PARAMETER CONDITIONS OF NTT</h3> <p>The full CC-based NTT requires that the parameter $n$ is a power of two and $q$ is prime satisfying $q\equiv 1\pmod n$, while the full NWC-based NTT requires that the parameter $n$ is a power of two and $q$ is prime satisfying $q\equiv 1\pmod {2n}$</p> <p>Traditionally, NTT puts some restrictions on its parameters. In recent years, many research efforts are made for NTTâ€™s restrictions on parameters and a series of methods have been proposed to weaken them.</p> <p>This section introduces the recent advances of weakening parameter restrictions with respect to $\mathbb{Z}_q[x]/(x^n\pm 1)$ where $n$ is a power of two. Those methods can be mainly classified into the following three categories.</p> <ul> <li>Method based on incomplete FFT trick</li> <li>Method based on splitting polynomial ring</li> <li>Method based on large modulus</li> </ul> <p>The first two methods are applied for the case that the modulus $q$ is an NTT-friendly prime of the form $q=qâ€™\cdot 2^e +1$ but $q$ can not lead to a full NTT.</p> <p>The last method is applied for the case that the modulus $q$ is an NTT-unfriendly prime.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_19.png" alt="image"> </p> <h4 id="method-based-on-incomplete-fft-trick">Method Based on Incomplete FFT trick</h4> <p>Introduce the method based on the incomplete FFT trick over $\mathbb{Z}_q[x]/(x^n + 1)$ where $n$ is a power of two and $q$ is NTT-friendly prime but does not satisfy $q \equiv 1 \pmod{2n}$.</p> <p>Then extend the ring to $\mathbb{Z}_q[x]/(x^n - 1)$ where $n$ is a power of two and $q$ is NTT-friendly prime but does not satisfy $q \equiv 1 \pmod n$.</p> <h5 id="method-based-on-incomplete-fft-trick-over-mathbbz_qxxn--1">Method based on incomplete FFT trick over $\mathbb{Z}_q[x]/(x^n + 1)$</h5> <p>Fully-mapping FFT trick means to map $\mathbb{Z}<em>q[x]/(x^n + 1)$ down to linear terms, e.g., $\mathbb{Z}_q[x]/(x - \psi</em>{2n}^{2i+1})$. The condition $q \equiv 1 \pmod{2n}$ is required such that the primitive $2n$-th root of unity $\psi_{2n}$ exits.</p> <p><img src="/june.github.io/assets/img/post/ntt/image_11.png" alt="image"> </p> <p>Moenck noticed that FFT trick does not have to map down to linear terms, and one can stop its mapping before the last $\beta$ level, $\beta = 0, 1, \dots, \log n - 1$.</p> <p>In detail, its CRT map of $\mathbb{Z}_q[x]/(x^n + 1)$ is as follows.</p> \[\mathbb{Z}_q[x]/(x^n + 1) \cong \prod_{i=0}^{n/2^\beta - 1} \mathbb{Z}_q[x]/(x^{2^\beta} - \psi_{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1}).\] <p>It is referred to as â€œIncomplete NTTâ€ or â€œTruncated-NTTâ€.</p> <p>The reason is that its CRT tree map is obtained by cropping the last $\beta$ levels from fully-mapping $(\log n)$-level FFT trick tree map.</p> <p>Note that after forward transforms, $\boldsymbol{a}$â€™s images in $\mathbb{Z}<em>q[x]/(x^{2^\beta} - \psi</em>{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1})$ are degree-$(2^\beta - 1)$ polynomials.</p> <p>The point-wise multiplication is performed about the corresponding degree-$(2^\beta - 1)$ polynomials in $\mathbb{Z}<em>q[x]/(x^{2^\beta} - \psi</em>{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1})$.</p> <p>As for the inverse transforms, the scale factor 2 is omitted in every level, followed by multiplying by a total scalar $(n/2^\beta)^{-1}$ in the end. The forward/inverse transforms with $\beta$ levels cropped are denoted by $\text{NTT}^{CT, \psi}<em>{no \to bo, \beta} / \text{INTT}^{GS, \psi^{-1}}</em>{bo \to no, \beta}$ respectively, where $\beta = 0, 1, \dots, \log n - 1$.</p> <p>Obviously, they are exactly $\text{NTT}^{CT, \psi}<em>{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no}$ if $\beta = 0$.</p> <p>The restriction on $n$ and $q$ can be weakened to $q \equiv 1 \pmod{2n/{2^\beta}}$.</p> <p>The way to compute polynomial multiplication is the general form of formula</p> \[\boldsymbol{c} = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right),\] <p>that is</p> \[\boldsymbol{c} = \text{INTT}^{GS, \psi^{-1}}_{bo \to no, \beta} \left( \text{NTT}^{CT, \psi}_{no \to bo, \beta}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo, \beta}(\boldsymbol{b}) \right).\] <p><strong>A high-level description of incomplete FFT trick over $\mathbb{Z}_q[x]/(x^n + 1)$</strong></p> \[\mathbb{Z}_q[x]/(x^n + 1) \to (\mathbb{Z}_q[x]/(x^{2^\beta} - y))[y]/(y^{\frac{n}{2^\beta}} + 1),\] <p>along with rewriting $\boldsymbol{a} \in \mathbb{Z}<em>q[x]/(x^n + 1)$ as $\boldsymbol{a} = \sum</em>{i=0}^{ n/2\beta -1} \tilde{a}_i y^i$,</p> <p>where $y = x^{2^\beta}$ and $\tilde{a}<em>i = \sum</em>{j=0}^{2^\beta-1} a_{2^\beta \cdot i + j} x^j \in \mathbb{Z}_q[x]/(x^{2^\beta} - y)$.</p> <p>Thus, $\boldsymbol{a}$ can be seen as a polynomial of degree $({n}/{2^\beta} - 1)$ with respect to $y$.</p> <p>FFT trick will map</p> \[(\mathbb{Z}_q[x]/(x^{2^\beta} - y))[y]/(y^{\frac{n}{2^\beta}} + 1) \cong \prod_{i=0}^{n/2^\beta - 1} (\mathbb{Z}_q[x]/(x^{2^\beta} - y))[y]/(y - \psi_{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1}).\] <p>Its forward transform (resp., inverse transform) is treated as radix-2 ${n}/{2^\beta}$-point full NWC-based $\text{NTT}^{CT, \psi}<em>{no \to bo}$ (resp., $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no}$) with respect to $y$.</p> <p>And the point-wise multiplication is performed in $(\mathbb{Z}<em>q[x]/(x^{2^\beta} - y))[y]/(y - \psi</em>{2n/2^\beta}^{2\text{brv}_{n/2^\beta}(i)+1})$.</p> <h5 id="method-based-on-incomplete-fft-trick-over-mathbbz_qxxn---1">Method based on incomplete FFT trick over $\mathbb{Z}_q[x]/(x^n - 1)$</h5> <p>The method based on incomplete FFT trick over$\mathbb{Z}_q[x]/(x^n - 1)$ achieves its CRT map as follows.</p> \[\mathbb{Z}_q[x]/(x^n - 1) \cong \prod_{i=0}^{n/2^\beta - 1} \mathbb{Z}_q[x]/(x^{2^\beta} - \omega_{n/2^\beta}^{\text{brv}_{n/2^\beta}(i)}).\] <p>where $\beta = 0, 1, \dots, \log n - 1$.</p> <p>Similarly, denote by $\text{NTT}^{CT}<em>{no \to bo, \beta}$ and $\text{INTT}^{GS}</em>{bo \to no, \beta}$ the forward and the inverse transform.</p> <p>The restriction on $q$ can be weakened to $q \equiv 1 \pmod{\frac{n}{2^\beta}}$.</p> <p>Its way to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n - 1)$ is</p> \[\boldsymbol{c} = \text{INTT}^{GS}_{bo \to no, \beta} \left( \text{NTT}^{CT}_{no \to bo, \beta}(\boldsymbol{a}) \circ \text{NTT}^{CT}_{no \to bo, \beta}(\boldsymbol{b}) \right).\] <p>Its high-level description can be written as</p> \[\mathbb{Z}_q[x]/(x^n - 1) \to (\mathbb{Z}_q[x]/(x^{2^\beta} - y))[y]/(y^{\frac{n}{2^\beta}} - 1),\] <p>followed by CRT isomorphism.</p> \[(\mathbb{Z}_q[x]/(x^{2^\beta} - y))[y]/(y^{\frac{n}{2^\beta}} - 1) \cong \prod_{i=0}^{n/2^\beta - 1} (\mathbb{Z}_q[x]/(x^{2^\beta} - y))[y]/(y - \omega_{n/2^\beta}^{\text{brv}_{n/2^\beta}(i)}).\] <h4 id="method-based-on-splitting-polynomial-ring">Method Based on Splitting Polynomial Ring</h4> <p>The computing strategies of Pt-NTT, K-NTT, and H-NTT are similarly dependent on splitting the initial polynomial ring, based on which they are classified as the method based on splitting the polynomial ring. And their basic idea can be traced back to Nussbaumerâ€™s trick. Following the description of Nussbaumerâ€™s trick, they can essentially be described by the following isomorphism. Let $\alpha$ be a non-negative integer.</p> \[\Psi_\alpha : \mathbb{Z}_q[x]/(x^n \pm 1) \cong \left( \mathbb{Z}_q[y]/(y^{\frac{n}{2^\alpha}} \pm 1) \right)[x]/(x^{2^\alpha} - y)\] \[a = \sum_{i=0}^{n-1} a_i x^i \mapsto \Psi_\alpha(a) = \sum_{i=0}^{2^\alpha-1} \left( \sum_{j=0}^{\frac{n}{2^\alpha}-1} a_{2^\alpha \cdot j + i} y^j \right) x^i .\] <p>Obviously, the isomorphism $\Psi_\alpha$ and its inverse $\Psi_\alpha^{-1}$ only perform simple reordering of the polynomial coefficients. $\Psi_\alpha$ is the identity mapping if $\alpha = 0$.</p> <p>Briefly speaking, the general form of $\alpha$-round method based on splitting polynomial ring to compute $c = a \cdot b \in \mathbb{Z}_q[x]/(x^n \pm 1)$ mainly contains the following three steps, where $n$ is a power of two and $q$ is a prime number (more details about $q$ can be seen below).</p> <ul> <li> <p><strong>Step 1, Splitting.</strong></p> <p>The polynomials $a$ and $b$ are split by $\Psi_\alpha$ into</p> \[\Psi_\alpha(a) = \sum_{i=0}^{2^\alpha-1} \tilde{a}_i \cdot x^i, \quad \Psi_\alpha(b) = \sum_{i=0}^{2^\alpha-1} \tilde{b}_i \cdot x^i \in \left( \mathbb{Z}_q[y]/(y^{\frac{n}{2^\alpha}} \pm 1) \right)[x]/(x^{2^\alpha} - y),\] <p>where $y = x^{2^\alpha}$, and</p> \[\tilde{a}_i = \sum_{j=0}^{\frac{n}{2^\alpha}-1} a_{2^\alpha \cdot j + i} y^j, \quad \tilde{b}_i = \sum_{j=0}^{\frac{n}{2^\alpha}-1} b_{2^\alpha \cdot j + i} y^j \in \mathbb{Z}_q[y]/(y^{\frac{n}{2^\alpha}} \pm 1).\] </li> <li> <p><strong>Step 2, Multiplication.</strong></p> <p>The product of $\Psi_\alpha(a)$ and $\Psi_\alpha(b)$ is obtained by $(\sum_{i=0}^{2^\alpha-1} \tilde{a}<em>i \cdot x^i)(\sum</em>{i=0}^{2^\alpha-1} \tilde{b}_i \cdot x^i) \pmod{x^{2^\alpha} - y}$,</p> <p>which means that one need to compute $\tilde{c}_i \in \mathbb{Z}_q[y]/(y^{ n/2\alpha} \pm 1)$ for $i = 0, 1, \dots, 2^\alpha - 1$ as follows.</p> \[\tilde{c}_i = \sum_{l=0}^{i} \tilde{a}_l \cdot \tilde{b}_{i-l} + \sum_{l=i+1}^{2^\alpha-1} y \cdot \tilde{a}_l \cdot \tilde{b}_{2^\alpha+i-l} \in \mathbb{Z}_q[y]/(y^{ n/2\alpha} \pm 1).\] </li> <li> <p><strong>Step 3, Gatheration.</strong></p> <p>Gather all the $\tilde{c}<em>i$ by $\Psi</em>\alpha^{-1}$, and obtain $c = \Psi_\alpha^{-1} \left( \sum_{i=0}^{2^\alpha-1} \tilde{c}_i \cdot x^i \right)$.</p> </li> </ul> <p>Step 1 and Step 3 are simple and easy.</p> <p>Essentially, $\Psi_\alpha$ transforms NTT/INTT over $\mathbb{Z}_q[x]/(x^n \pm 1)$ into those over $\mathbb{Z}_q[y]/(y^{ n/2\alpha} \pm 1)$ which requires only ${n}/{2^\alpha}$-point NTT/INTT with arbitrary appropriate modulus $q$, but the point-wise multiplication needs to be adapted to NTT/INTT.</p> <p>There are three variants based on the method based on splitting polynomial ring, including Pt-NTT, K-NTT, H-NTT. The main difference between them is that they use different skills and NTTs to compute $\tilde{c}_i$ of Step 2.</p> <h5 id="621-pt-ntt">6.2.1 Pt-NTT</h5> <p>Preprocess-then-NTT (Pt-NTT) improves formula as follows.</p> \[\begin{aligned} \tilde{c}_i &amp;= \sum_{l=0}^{i} \tilde{a}_l \cdot \tilde{b}_{i-l} + \sum_{l=i+1}^{2^\alpha-1} \vec{a}_l \cdot \tilde{b}_{2^\alpha+i-l} \\ &amp;= \text{INTT} \left( \sum_{l=0}^{i} \text{NTT}(\tilde{a}_l) \circ \text{NTT}(\tilde{b}_{i-l}) + \sum_{l=i+1}^{2^\alpha-1} \text{NTT}(\vec{a}_l) \circ \text{NTT}(\tilde{b}_{2^\alpha+i-l}) \right), \end{aligned}\] <p>where â€œ$\circ$â€ is the corresponding point-wise multiplication, and for $\mathbb{Z}_q[y]/(y^{ n/2\alpha} + 1)$, there is</p> \[\tilde{\tilde{a}}_l = y \cdot \tilde{a}_l = -a_{n-2^\alpha+l} + \sum_{j=0}^{ n/2\alpha-2} a_{2^\alpha \cdot j + l} y^{j+1} \in \mathbb{Z}_q[y]/(y^{ n/2\alpha} + 1),\] <p>or, for $\mathbb{Z}_q[y]/(y^{ n/2\alpha} - 1)$, there is</p> \[\tilde{\tilde{a}}_l = y \cdot \tilde{a}_l = a_{n-2^\alpha+l} + \sum_{j=0}^{ n/2\alpha-2} a_{2^\alpha \cdot j + l} y^{j+1} \in \mathbb{Z}_q[y]/(y^{ n/2\alpha} - 1).\] <p>Here, Pt-NTT uses ${n}/{2^\alpha}$-point full NWC-based NTT/INTT over $\mathbb{Z}_q[y]/(y^{ n/2\alpha} + 1)$, or ${n}/{2^\alpha}$-point full CC-based NTT/INTT over $\mathbb{Z}_q[y]/(y^{ n/2\alpha} - 1)$.</p> <h5 id="622-k-ntt">6.2.2 K-NTT</h5> <p>Later, Karatsuba-NTT (K-NTT) is proposed based on Pt-NTT, equipping with one-iteration Karatsuba algorithm. Its Step 2 is given as</p> \[\begin{aligned} \tilde{c}_i &amp;= \sum_{l=0}^{i} \tilde{a}_l \cdot \tilde{b}_{i-l} + \sum_{l=i+1}^{2^\alpha-1} y \cdot \tilde{a}_l \cdot \tilde{b}_{2^\alpha+i-l} \\ &amp;= \text{INTT} \left( \sum_{l=0}^{i} \text{NTT}(\tilde{a}_l) \circ \text{NTT}(\tilde{b}_{i-l}) + \sum_{l=i+1}^{2^\alpha-1} \text{NTT}(y) \circ \text{NTT}(\tilde{a}_l) \circ \text{NTT}(\tilde{b}_{2^\alpha+i-l}) \right). \end{aligned}\] <p>Here, K-NTT uses ${n}/{2^\alpha}$-point full NWC-based NTT/INTT over $\mathbb{Z}_q[y]/(y^{ n/2\alpha} + 1)$, or ${n}/{2^\alpha}$-point full CC-based NTT/INTT over $\mathbb{Z}_q[y]/(y^{ n/2\alpha} - 1)$.</p> <p>Since $y$ has been known, $\text{NTT}(y)$ can be computed and stored offline in advance. In Step 2, one-iteration Karatsuba algorithm is used in such a manner.</p> <p>First compute and store $\text{NTT}(\tilde{a}_i) \circ \text{NTT}(\tilde{b}_i)$ for any $i = j$,</p> <p>and then</p> \[\begin{aligned} &amp;\text{NTT}(\tilde{a}_i) \circ \text{NTT}(\tilde{b}_j) + \text{NTT}(\tilde{a}_j) \circ \text{NTT}(\tilde{b}_i) \\[.5em] &amp;= (\text{NTT}(\tilde{a}_i) + \text{NTT}(\tilde{a}_j)) \circ (\text{NTT}(\tilde{b}_i) + \text{NTT}(\tilde{b}_j)) \\&amp;\quad\;\ - \text{NTT}(\tilde{a}_i) \circ \text{NTT}(\tilde{b}_i) - \text{NTT}(\tilde{a}_j) \circ \text{NTT}(\tilde{b}_j) \end{aligned}\] <p>for any $i \neq j$.</p> <h5 id="623-h-ntt">6.2.3 H-NTT</h5> <p>Furthermore, Hybrid-NTT (H-NTT) is proposed as an improved K-NTT and a new variant of NTT, by applying truncated-NTT in Step 2 and one-iteration Karatsuba algorithm in its point-wise multiplication.</p> <p>H-NTT uses truncated-NTT with $\beta$ levels cropped, instead of those full NTT in K-NTT. Its Step 2 is given as</p> \[\begin{aligned} \tilde{c}_i &amp;= \sum_{l=0}^{i} \tilde{a}_l \cdot \tilde{b}_{i-l} + \sum_{l=i+1}^{2^\alpha-1} y \cdot \tilde{a}_l \cdot \tilde{b}_{2^\alpha+i-l} \\ &amp;= \text{INTT}_\beta\! \left( \sum_{l=0}^{i} \text{NTT}_\beta(\tilde{a}_l) \circ \text{NTT}_\beta(\tilde{b}_{i-l}) +\! \sum_{l=i+1}^{2^\alpha-1} \text{NTT}_\beta(y) \circ \text{NTT}_\beta(\tilde{a}_l) \circ \text{NTT}_\beta(\tilde{b}_{2^\alpha+i-l}) \right), \end{aligned}\] <p>where $\text{NTT}<em>\beta/\text{INTT}</em>\beta$ means NWC-based $\text{NTT}^{CT, \psi}<em>{no \to bo, \beta}/\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no, \beta}$ over $\mathbb{Z}<em>q[y]/(y^{ n/2\alpha} + 1)$, or CC-based $\text{NTT}^{CT}</em>{no \to bo, \beta}/\text{INTT}^{GS}_{bo \to no, \beta}$ over $\mathbb{Z}_q[y]/(y^{ n/2\alpha} - 1)$.</p> <p>One-iteration Karatsuba algorithm is also used in its point-wise multiplication.</p> <p>For example, to compute $(\sum_{i=0}^{2^\beta-1} \hat{a}<em>i x^i)(\sum</em>{i=0}^{2^\beta-1} \hat{b}_i x^i) \pmod{x^{2^\beta} - \psi}$,</p> <p>one can compute $\hat{a}_i \hat{b}_j$ for any $i = j$ first</p> <p>and then compute $\hat{a}_i \hat{b}_j + \hat{a}_j \hat{b}_i = (\hat{a}_i + \hat{a}_j)(\hat{b}_i + \hat{b}_j) - \hat{a}_i \hat{b}_i - \hat{a}_j \hat{b}_j$ for any $i \neq j$.</p> <h5 id="624-comparisons-and-discussions">6.2.4 Comparisons and discussions</h5> <p>Based on the high-level description of incomplete FFT trick, it shares some similarities with the method based on splitting polynomial ring.</p> <p>In fact, there is an isomorphism between $(\mathbb{Z}_q[x]/(x^{2^\beta} - y))[y]/(y^{ n/2\beta} \pm 1)$ and $(\mathbb{Z}_q[y]/(y^{ n/2\alpha} \pm 1))[x]/(x^{2^\alpha} - y)$ for any $\alpha = \beta$. And they have been proved computationally equivalent, which implies that their efficiencies are the same theoretically.</p> <p>These two methods can expand the value range of modulus $q$, because $q$ can only satisfy $q \equiv 1 \pmod{2n/{2^{\alpha+\beta}}}$ for some $\alpha, \beta$, instead of $q \equiv 1 \pmod{2n}$ when $n$ is fixed, for NWC-based NTT; besides, $q$ can only satisfy $q \equiv 1 \pmod{ n/2{\alpha+\beta}}$ for some $\alpha, \beta$, instead of $q \equiv 1 \pmod{n}$ when $n$ is fixed, for CC-based NTT.</p> <p>However, the limitations on $q$ can not be ignored, since $q$ must be an NTT-friendly prime such that $\mathbb{Z}_q$ is a finite field and $x^n \pm 1$ can be split into polynomials of small degree over $\mathbb{Z}_q$.</p> <p>In addition, as for the method based on splitting polynomial ring, the polynomial operations over $\mathbb{Z}_q[x]/(x^n \pm 1)$ can be transformed into those over a smaller ring $\mathbb{Z}_q[y]/(y^{ n/2\alpha} \pm 1)$. It leads to more modular implementation, since NTT over $\mathbb{Z}_q[y]/(y^{ n/2\alpha} \pm 1)$ can be implemented as a â€œblack boxâ€, and be re-called when required in Step 2.</p> <p>Both Pt-NTT and K-NTT use ${n}/{2^\alpha}$-point full NTT in their Step 2. It requires that the primitive ${n}/{2^{\alpha-1}}$-th root of unity exits for NWC-based NTT, or the primitive ${n}/{2^\alpha}$-th root of unity exits for CC-based NTT.</p> <p>Therefore, the parameter condition of Pt-NTT and K-NTT can be weakened to $q \equiv 1 \pmod{2n/{2^\alpha}}$ for the initial ring $\mathbb{Z}_q[x]/(x^n + 1)$, or $q \equiv 1 \pmod{ n/2\alpha}$ for the initial ring $\mathbb{Z}_q[x]/(x^n - 1)$. H-NTT can further weaken the parameter condition to $q \equiv 1 \pmod{2n/{2^{\alpha+\beta}}}$ for the ring $\mathbb{Z}_q[x]/(x^n + 1)$ by using truncated-NTT, or $q \equiv 1 \pmod{ n/2{\alpha+\beta}}$ for the ring $\mathbb{Z}_q[x]/(x^n - 1)$.</p> <p>By comparison, it can be seen that $\alpha$-round K-NTT and truncated-NTT are the special cases of H-NTT when $\beta = 0$ and $\alpha = 0$ respectively.</p> <p>More specially, $\text{NTT}^{CT, \psi}<em>{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no}$ are the cases of H-NTT over $\mathbb{Z}_q[x]/(x^n + 1)$ when $\alpha = 0, \beta = 0$,</p> <p>and $\text{NTT}^{CT}<em>{no \to bo}$ and $\text{INTT}^{GS}</em>{bo \to no}$ are the cases of H-NTT over $\mathbb{Z}_q[x]/(x^n - 1)$ when $\alpha = 0, \beta = 0$.</p> <h4 id="method-based-on-large-modulus">Method Based on Large Modulus</h4> <p>Here we consider $\mathbb{Z}_q[x]/(x^n \pm 1)$, where $n$ is a power of two and the modulus $q$ is an NTT-unfriendly prime, but $q$ can be actually any positive integer.</p> <p>The process of $c = a \cdot b \in \mathbb{Z}_q[x]/(x^n \pm 1)$ is divided into two steps.</p> <ul> <li> <p><strong>Step 1.</strong></p> <p>Compute $câ€™ = a \cdot b \in \mathbb{Z}_N[x]/(x^n \pm 1)$, where $N$ is a positive integer and larger than the maximum absolute value of the coefficients during the computation over $\mathbb{Z}$.</p> </li> <li> <p><strong>Step 2.</strong></p> <p>One can recover the result in $\mathbb{Z}_q[x]/(x^n \pm 1)$ through reduction module $q$, i.e., $c = câ€™ \bmod q$.</p> </li> </ul> <p>It is called the method based on large modulus in this paper, because its key step is to select a large enough modulus $N$ in Step 1.</p> <p>Obviously, $N$ could be chosen such that $N &gt; nq^2$. When $N$ is large enough, the product of $a$ and $b$ in $\mathbb{Z}[x]/(x^n \pm 1)$ is identical to that in $\mathbb{Z}_N[x]/(x^n \pm 1)$.</p> <p>In order to apply NTTs, we consider two sub-cases of the values of $N$. One is that $N$ is an NTT-friendly prime. The other is that $N$ is the product of some NTT-friendly primes. When $N$ is the product of some NTT-friendly primes, i.e., $N = \prod_{i=1}^l q_i$ where each $q_i$ is an NTT-friendly prime, in this case, it can further be classified into two sub-methods.</p> <p>One is the method based on residue number system (RNS). The other is the method based on composite-modulus ring.</p> <h5 id="631-method-based-on-ntt-friendly-large-prime">6.3.1 Method based on NTT-friendly large prime.</h5> <p>When $N$ is an NTT-friendly prime, NTT can be performed in $\mathbb{Z}_N[x]/(x^n \pm 1)$ directly in Step 1.</p> <p>Notice that if $N$ is set sufficiently large and NTT-friendly, this method always works regardless of the value of the original modulus $q$.</p> <p>For example, if $N$ is a prime satisfying $N &gt; nq^2$ and $N \equiv 1 \pmod{2n}$, $n$-point full NWC-based NTT of modulus $N$ can always be used over $\mathbb{Z}_N[x]/(x^n + 1)$. Besides, if $N$ is a prime satisfying $N &gt; nq^2$ and $N \equiv 1 \pmod{n}$, $n$-point full CC-based NTT of modulus $N$ can always be used over $\mathbb{Z}_N[x]/(x^n - 1)$.</p> <h5 id="632-method-based-on-residue-number-system">6.3.2 Method based on residue number system.</h5> <p>Residue number system (RNS) is widely used in the context of homomorphic encryption for computing NTTs over many primes.</p> <p>Based on RNS, negative wrapped convolution with a modulus that is the product of some primes, can be transformed into ones with smaller moduli by Chinese Remainder Theorem, that is</p> \[\mathbb{Z}_N[x]/(x^n \pm 1) \cong \prod_{i=1}^l \mathbb{Z}_{q_i}[x]/(x^n \pm 1).\] <p>Denote by $c_i$ the product of $a$ and $b$ in $\mathbb{Z}_{q_i}[x]/(x^n \pm 1)$ for $i = 1, \dots, l$.</p> <p>After using NTTs to compute $c_i, i = 1, \dots, l$, the original product $c$ in $\mathbb{Z}_N[x]/(x^n \pm 1)$ can be recovered from $c_i, i = 1, \dots, l$, by Chinese Remainder Theorem in number theoretic.</p> <h5 id="633-method-based-on-composite-modulus-ring">6.3.3 Method based on composite-modulus ring.</h5> <p>The NTT can be performed over a polynomial ring with a composite modulus directly.</p> <p>Specifically, generalizes the concepts of NTT from a finite field to an integer ring, the basic idea of which was first developed in terms of FFT.</p> <p>Consider $\mathbb{Z}<em>N[x]/(x^n + 1)$, where $N = \prod</em>{i=1}^l q_i$ and each $q_i$ is NTT-friendly prime. If $2n \mid \gcd(q_1 - 1, \dots, q_l - 1)$, there exits a principal $2n$-th root of unity $\psi_{2n}$ in $\mathbb{Z}_N$.</p> <p>$\psi_{2n}$ is a principle $2n$-th root of unity in $\mathbb{Z}<em>N$, iff $(\psi</em>{2n} \bmod q_i)$ is a principle $2n$-th root of unity in $\mathbb{Z}_{q_i}$ for any $i$.</p> \[\mathbb{Z}_N[x]/(x^n + 1) \cong \prod_{i=0}^{n-1} \mathbb{Z}_N[x]/(x - \psi_{2n}^{2brv_n(i)+1}).\] <p>Its forward transform and inverse transform are illustrated as $\text{NTT}^{CT, \psi}<em>{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no}$ over $\mathbb{Z}_N[x]/(x^n + 1)$.</p> <p>The CRT map of truncated-NTT with $\beta$ levels cropped is as follows.</p> \[\mathbb{Z}_N[x]/(x^n + 1) \cong \prod_{i=0}^{n/2^\beta - 1} \mathbb{Z}_N[x]/(x^{2^\beta} - \psi_{2n/2^\beta}^{2brv_{n/2^\beta}(i)+1}),\] <p>where $\psi_{2n/2^\beta}$ is a principal $2n/2^\beta$-th root of unity in $\mathbb{Z}_N$.</p> <p>Its forward transform and inverse transform are illustrated as $\text{NTT}^{CT, \psi}<em>{no \to bo, \beta}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no, \beta}$ over $\mathbb{Z}_N[x]/(x^n + 1)$, respectively.</p> <p>As for $\mathbb{Z}<em>N[x]/(x^n - 1)$, where $N = \prod</em>{i=1}^l q_i$ and each $q_i$ is NTT-friendly prime.</p> <p>If $n \mid \gcd(q_1 - 1, \dots, q_l - 1)$, there exits a principal $n$-th root of unity $\omega_n$ in $\mathbb{Z}_N$.</p> <p>$\omega_n$ is a principle $n$-th root of unity in $\mathbb{Z}<em>N$, iff $(\omega_n \bmod q_i)$ is a principle $n$-th root of unity in $\mathbb{Z}</em>{q_i}$ for any $i$.</p> <p>The CRT map of full-mapping FFT trick and truncated-NTT with $\beta$ levels cropped over $\mathbb{Z}_N[x]/(x^n - 1)$ can be derived similarly to those over $\mathbb{Z}_N[x]/(x^n + 1)$.</p> <h5 id="634-comparisons-and-discussions">6.3.4 Comparisons and discussions.</h5> <p>Compare the method based on large modulus and those based on incomplete FFT trick/splitting polynomial ring.</p> <p>The three sub-methods of the method based on large modulus are valid for any original modulus $q$ (including NTT-friendly ones), and can completely remove the restriction on $q$. But, their shortcomings are also obvious.</p> <p>Specifically, the method based on incomplete FFT trick and based on splitting polynomial ring still choose original $q$ as the modulus. But, the modulus $N$ used in the method based on NTT-friendly large prime and method based on composite-modulus ring, is much larger than original modulus $q$.</p> <p>For examples, $N$ could be chosen as $nq^2$. Although $N$ be smaller if one of the multiplicands is small, it will still be several orders of magnitude larger than $q$.</p> <p>It causes that the storage of coefficients and the computing-resource consume will be more than the cases of $q$ during the computation. Besides, as for the method based on residue number system, there are more than one NTT computation needed to be computed. Traditionally, it is more time-consuming and resource-consuming, because full NWC-based NTT, the method based on incomplete FFT trick and the method based on splitting polynomial ring only need one NTT computation.</p> <p>Therefore, if $q$ is an NTT-friendly prime number, the methods based on incomplete FFT trick and based on splitting polynomial ring are recommended strongly for an efficient implementation, instead of the method based on large modulus. But, when $q$ is an NTT-unfriendly prime number, one can turn to the method based on large modulus.</p> <p>Note that, there are some connections between the method based on residue number system and composite-modulus ring.</p> <p>Here review $\mathbb{Z}<em>N[x]/(x^n \pm 1)$. Both of them could choose $N = \prod</em>{i=1}^l q_i$ where each $q_i$ is NTT-friendly prime. If one split $N$ via CRT and keep $x^n \pm 1$ unchanged, it implies the method based on residue number system.</p> <p>If one split $x^n \pm 1$ via CRT and keep $N$ unchanged, it implies the method based on composite-modulus ring.</p> <p>Therefore, these two methods are derived from different splitting forms of moduli via CRT.</p> <h3 id="choosing-number-theoretic-transform-for-given-rings">CHOOSING NUMBER THEORETIC TRANSFORM FOR GIVEN RINGS</h3> <p>This section introduces how to choose an appropriate NTT for the given polynomial ring, mainly classifying the rings into three categories for the convenience of understanding.</p> <ul> <li>$\mathbb{Z}_q[x]/(x^n \pm 1)$ with respect to power-of-two $n$</li> <li>$\mathbb{Z}_q[x]/(x^n \pm 1)$ with respect to non-power-of-two $n$</li> <li>$\mathbb{Z}_q[x]/(\phi(x))$ with respect to general $\phi(x)$ of degree $n$.</li> </ul> <p>Mainly focus on the special rings of the form $\mathbb{Z}_q[x]/(x^n \pm 1)$ in the first two categories, and then extend the results to the general rings of the form $\mathbb{Z}_q[x]/(\phi(x))$ with respect to general $\phi(x)$ of degree $n$.</p> <h4 id="mathbbz_qxxn-pm-1-with-respect-to-power-of-two-n">$\mathbb{Z}_q[x]/(x^n \pm 1)$ with Respect to Power-of-two $n$</h4> <h5 id="ntt-friendly-q">NTT-friendly $q$</h5> <p>In this case, $q$ is an NTT-friendly prime of the form $q = qâ€™ \cdot 2^e + 1$.</p> <p>Furthermore, classify it into two sub-cases, the first sub-case is that $q$ can lead to a full NTT.</p> <p>The another sub-case is that $q$ can not lead to a full NTT.</p> <p>First consider the first sub-case of $n$ being a power of two and $q$ leading to a full NTT.</p> <p>As for $\mathbb{Z}<em>q[x]/(x^n + 1)$, there exits $q \equiv 1 \pmod{2n}$, then full NWC-based NTT (e.g., $\text{NTT}^{CT, \psi}</em>{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}_{bo \to no}$) can be used to multiply two polynomials in $\mathbb{Z}_q[x]/(x^n + 1)$.</p> <p>Restate that one can compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n + 1)$ by</p> \[\boldsymbol{c} = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right).\] <p>As for $\mathbb{Z}<em>q[x]/(x^n - 1)$, there exits $q \equiv 1 \pmod n$, then full CC-based NTT (e.g., $\text{NTT}^{CT}</em>{no \to bo}$ and $\text{INTT}^{GS}_{bo \to no}$) can be used to multiply two polynomials in $\mathbb{Z}_q[x]/(x^n - 1)$.</p> <p>Restate that one can compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n - 1)$ by</p> \[\boldsymbol{c} = \text{INTT}^{GS}_{bo \to no} \left( \text{NTT}^{CT}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT}_{no \to bo}(\boldsymbol{b}) \right).\] <p>Then consider the another sub-case of $n$ being a power of two and $q$ not leading to a full NTT.</p> <p>It means that, for $\mathbb{Z}_q[x]/(x^n + 1)$, $q$ does not satisfy $q \equiv 1 \pmod{2n}$,</p> <p>or, for $\mathbb{Z}_q[x]/(x^n - 1)$, $q$ does not satisfy $q \equiv 1 \pmod n$.</p> <p>In this sub-case, the method based on incomplete FFT trick and the method splitting polynomial ring are highly recommended.</p> <p>For example, as for $\mathbb{Z}_q[x]/(x^n + 1)$, if $q$ only satisfies $q \equiv 1 \pmod{2n/{2^\alpha}}$ (resp., $q \equiv 1 \pmod{2n/{2^\beta}}$), then one can use $\alpha$-round method based on splitting polynomial ring (resp., method based on incomplete FFT trick with $\beta$ levels cropped) can be used to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n + 1)$.</p> <p>Besides, as for $\mathbb{Z}_q[x]/(x^n - 1)$, if $q$ only satisfies $q \equiv 1 \pmod{ n/2\alpha}$ (resp., $q \equiv 1 \pmod{ n/2\beta}$), then one can use $\alpha$-round method based on splitting polynomial ring (resp., method based on incomplete FFT trick with $\beta$ levels cropped) can be used to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n - 1)$.</p> <p>Furthermore, if $q$ only satisfies $q \equiv 1 \pmod{2n/{2^{\alpha+\beta}}}$ for $\mathbb{Z}_q[x]/(x^n + 1)$, one can use H-NTT with $\alpha$-round splitting and $\beta$ levels cropped;</p> <p>similarly, if $q$ only satisfies $q \equiv 1 \pmod{ n/2{\alpha+\beta}}$ for $\mathbb{Z}_q[x]/(x^n - 1)$, one can use H-NTT with $\alpha$-round splitting and $\beta$ levels cropped.</p> <h5 id="ntt-unfriendly-q">NTT-unfriendly $q$</h5> <p>In this case, $q$ is an NTT-unfriendly prime.</p> <p>In order to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n \pm 1)$, one can use the method based on large modulus.</p> <p>Firstly, compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_N[x]/(x^n \pm 1)$, where $N$ is a positive integer and larger than the maximum absolute value of the coefficients during the computation over $\mathbb{Z}$, and then compute $\boldsymbol{c} = \boldsymbol{c}â€™ \bmod q$.</p> <p>To compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_N[x]/(x^n \pm 1)$, one can use the method based on NTT-friendly large prime, the method based on residue number system or the method based on composite-modulus ring.</p> <h4 id="mathbbz_qxxn-pm-1-with-respect-to-non-power-of-two-n">$\mathbb{Z}_q[x]/(x^n \pm 1)$ with Respect to Non-power-of-two $n$</h4> <p>Consider the case of non-power-of-two $n$, but actually $n$ can be a general integer.</p> <p>The essential idea about the computation of $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^n \pm 1)$ is described through two steps as follows.</p> <ol> <li> <p><strong>Step 1.</strong></p> <p>Compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^{nâ€™} \pm 1)$, where $nâ€™$ is a larger integer and $nâ€™ \ge 2n$.</p> </li> <li> <p><strong>Step 2.</strong></p> <p>One can recover the result in $\mathbb{Z}_q[x]/(x^n \pm 1)$ through reduction modulo $x^{nâ€™} \pm 1$, i.e., $\boldsymbol{c} = \boldsymbol{c}â€™ \bmod x^{nâ€™} \pm 1$.</p> <p>As for the ring $\mathbb{Z}_q[x]/(x^{nâ€™} \pm 1)$</p> <ol> <li>The first case is that $nâ€™$ is a power of two, which is denoted by $2^k$.</li> <li>The other case is that $nâ€™$ is of the form $h \cdot 2^k$, where $h$ is an odd number.</li> </ol> </li> </ol> <h5 id="power-of-two-n">Power-of-two $nâ€™$</h5> <p>As for the first case, the computation is transformed into that with respect to $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^{nâ€™} \pm 1)$, where $nâ€™$ is a power of two.</p> <h5 id="use-goods-trick">Use Goodâ€™s trick</h5> <p>As for the other case, the computation is transformed into that with respect to $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(x^{nâ€™} \pm 1)$, where $nâ€™ = h \cdot 2^k$ and $h$ is an odd number.</p> <p>One can use Goodâ€™s trick to compute polynomial multiplication over $\mathbb{Z}_q[x]/(x^{h \cdot 2^k} - 1)$. In this paper, Goodâ€™s trick is recommended, since there are more freedom to select an odd number $h$ and power-of-two $2^k$. If one expand the length to power-of-two $nâ€™$, it is inconvenient to find a suitable polynomial of some particular degree up to the next power of two.</p> <h4 id="mathbbz_qxphix-with-respect-to-general-phix-of-degree-n">$\mathbb{Z}_q[x]/(\phi(x))$ with Respect to General $\phi(x)$ of Degree $n$</h4> <p>Here we consider the more general ring $\mathbb{Z}_q[x]/(\phi(x))$ where $\phi(x)$ is an arbitrary polynomial of degree $n$. In order to apply fast NTT algorithm, there are complex but efficient methods.</p> <p>The computation of $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(\phi(x))$ can be described through two steps as follows.</p> <ol> <li> <p><strong>Step 1.</strong></p> <p>Compute $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_N[x]/(x^{nâ€™} \pm 1)$, where $N$ is a positive integer and larger than the maximum absolute value of the coefficients during the computation over $\mathbb{Z}$, $nâ€™$ is a larger integer and $nâ€™ \ge 2n$.</p> </li> <li> <p><strong>Step 2.</strong></p> <p>And then compute $\boldsymbol{c} = (\boldsymbol{c}â€™ \bmod \phi(x)) \bmod q$.</p> </li> </ol> <p>Therefore, the computation of $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_q[x]/(\phi(x))$ is transformed into that of $\boldsymbol{c}â€™ = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathbb{Z}_N[x]/(x^{nâ€™} \pm 1)$.</p> <h3 id="number-theoretic-transform-in-nist-pqc">NUMBER THEORETIC TRANSFORM IN NIST PQC</h3> <p>NIST PQC Round 3 candidatesâ€™ schemes mainly focus on their NTT-based implementations over their underlying rings $\mathbb{Z}_q[x]/(\phi(x))$, where $\mathbb{Z}_q[x]/(\phi(x))$ is instantiated as in Table.</p> <table> <thead> <tr> <th>Schemes</th> <th>n</th> <th>q</th> <th>Rings</th> <th>Types</th> <th>Methods &amp; Algorithms</th> </tr> </thead> <tbody> <tr> <td>Kyber Round 1</td> <td>256</td> <td>7681</td> <td>$\mathbb{Z}_q[x]/(x^n + 1)$</td> <td>NTT-friendly</td> <td>Â </td> </tr> <tr> <td>$q \equiv 1 \pmod{2n}$</td> <td>$n$-point full NWC-based NTT</td> <td>Â </td> <td>Â </td> <td>Â </td> <td>Â </td> </tr> <tr> <td>Kyber Round 2, Kyber Round 3</td> <td>256</td> <td>3329</td> <td>$\mathbb{Z}_q[x]/(x^n + 1)$</td> <td>NTT-friendly</td> <td>Â </td> </tr> <tr> <td>$q \equiv 1 \pmod{n}$</td> <td>Incomplete FFT trick,</td> <td>Â </td> <td>Â </td> <td>Â </td> <td>Â </td> </tr> <tr> <td>Splitting polynomial ring</td> <td>Â </td> <td>Â </td> <td>Â </td> <td>Â </td> <td>Â </td> </tr> <tr> <td>Dilithium Round 3</td> <td>256</td> <td>8380417</td> <td>$\mathbb{Z}_q[x]/(x^n + 1)$</td> <td>NTT-friendly</td> <td>Â </td> </tr> <tr> <td>$q \equiv 1 \pmod{2n}$</td> <td>$n$SS-point full NWC-based NTT</td> <td>Â </td> <td>Â </td> <td>Â </td> <td>Â </td> </tr> </tbody> </table> <p><img src="/june.github.io/assets/img/post/ntt/image_20.png" alt="image"> </p> <p>Notice that not all the schemes can directly use full NTT to multiply polynomials. For example, full NWC-based NTT over $\mathbb{Z}_q[x]/(x^n + 1)$ further requires that the prime $q$ satisfies $q \equiv 1 \pmod{2n}$. Only Dilithium and Falcon can meet the situation. Besides, full NTT can not be directly used in those lattice-based schemes with power-of-two moduli, such as Saber and NTRU.</p> <h4 id="kyber">Kyber</h4> <p>Kyber is an IND-CCA secure MLWE-based KEM from the lattice-based cryptography suite called â€œCryptographic Suite for Algebraic Lattices (CRYSTALS)â€.</p> <p>The Kyber submission in NIST PQC Round 1, named Kyber Round 1, uses $n = 256$ and $q = 7681$ which satisfies $q \equiv 1 \pmod{2n}$.</p> <p>Its way to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathcal{R}_q$ in C reference implementation is elaborated as</p> \[c = \psi^{-1} \circ \text{INTT}^{GS}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right),\] <p>where the inverse transform is $\psi^{-1} \circ \text{INTT}^{GS}<em>{bo \to no}$, the output of which is the same as that of $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no}$.</p> <p>As for its AVX2 optimized implementation, Kyber Round 1 uses $\text{NTT}^{CT, \psi}<em>{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no}$, and the computation is restated as</p> \[c = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right).\] <p>The Kyber submissions in the second and third round of NIST PQC competition use a smaller prime number $q = 3329$ which no longer satisfies $q \equiv 1 \pmod{2n}$, but $q \equiv 1 \pmod{n}$.</p> <p>Kyber Round 2 and Round 3 use truncated-NTT with one level cropped: $\text{NTT}^{CT, \psi}<em>{no \to bo, \beta=1}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no, \beta=1}$.</p> <p>The point-wise multiplication is treated as the corresponding polynomial multiplications in $\mathbb{Z}<em>q[x]/(x^2 - \omega</em>{n}^{2brv_{n/2}(i)+1})$.</p> <p>Its way to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathcal{R}_q$ is restated as</p> \[c = \text{INTT}^{GS, \psi^{-1}}_{bo \to no, \beta=1} \left( \text{NTT}^{CT, \psi}_{no \to bo, \beta=1}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo, \beta=1}(\boldsymbol{b}) \right).\] <p>Further, Liang et al. improve its truncated-NTT by using H-NTT with $\alpha = 0$, which can be seen as $\text{NTT}^{CT, \psi}<em>{no \to bo, \beta=1}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no, \beta=1}$ with one-iteration Karatsuba algorithm in its point-wise multiplication.</p> <p>Different from truncated-NTT used in Kyber Round 2 and Round 3, they used 1-round Pt-NTT with ${n}/{2}$-point full NWC-based NTT for â€œsmall-Kyberâ€. But, their implementation had a slightly worse performance than the initial one.</p> <h4 id="dilithium">Dilithium</h4> <p>Dilithium is a signature scheme based on module lattice and is one of the algorithms from CRYSTALS.</p> <p>Its parameter sets satisfy the condition $q \equiv 1 \pmod{2n}$ such that $n$-point full NWC-based $\text{NTT}^{CT, \psi}<em>{no \to bo}$ and $\text{INTT}^{GS, \psi^{-1}}</em>{bo \to no}$ can be utilized.</p> <p>Its way to compute $\boldsymbol{c} = \boldsymbol{a} \cdot \boldsymbol{b} \in \mathcal{R}_q$ is restated as</p> \[c = \text{INTT}^{GS, \psi^{-1}}_{bo \to no} \left( \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{a}) \circ \text{NTT}^{CT, \psi}_{no \to bo}(\boldsymbol{b}) \right).\] <h5 id="c-some-skills">C SOME SKILLS</h5> <p>Those lattice-based schemes fully utilizes the advantages of NTT to improve their efficiency.</p> <p>As for MLWE-based schemes such as Kyber, Dilithium, etc, at a high level, their basic operations can be described as matrix-vector polynomial multiplication $\mathbf{A}^T \mathbf{r}$ and vector-vector polynomial multiplication $\mathbf{s}^T \mathbf{u}$, where $\mathbf{A} \in \mathcal{R}_q^{k \times k}$, $\mathbf{r}, \mathbf{s}, \mathbf{u} \in \mathcal{R}_q^{k \times 1}$.</p> <p>Those schemes directly generate the public key term $\hat{\mathbf{A}}$ already in the NTT domain by rejection sampling, instead of generating $\mathbf{A}$ followed by applying forward transform on each element. It can save $k^2$ forward transforms.</p> <p>The linearity of NTT can lead to $\text{INTT}\left( \hat{\mathbf{A}}^T \circ \text{NTT}(\mathbf{r}) \right)$ where there are only $k$ forward transforms and $k$ inverse transforms.</p> <p>Once the forward transform result $\hat{\mathbf{s}}$ is computed, $\hat{\mathbf{s}}$ can be stored or transmitted without any extra requirement of storage, for following use in multiple polynomial multiplications.</p> <p>Using $\hat{\mathbf{s}}$ that is stored or transmitted in advance, one can compute $\mathbf{s}^T \mathbf{u}$ by $\text{INTT}\left( \hat{\mathbf{s}}^T \circ \text{NTT}(\mathbf{u}) \right)$, within only $k$ forward transforms and $k$ inverse transforms.</p> <p>As for MLWR-based schemes, the linearity of NTT is helpful in the NTT-based implementation of MLWR-based schemes such as Saber. The number of forward transforms and inverse transforms in Saberâ€™s matrix-vector multiplication $\mathbf{As}$ can be reduced from $2k^2$ and $k^2$ to $k^2 + k$ and $k$, respectively, while the number of inverse transforms $\mathbf{b}^T \mathbf{s}$ in vector-vector multiplication can be reduced from $k$ to 1, where $\mathbf{A} \in \mathcal{R}_q^{k \times k}, \mathbf{b}, \mathbf{s} \in \mathcal{R}_q^{k \times 1}$.</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> Â© Copyright 2026 Jieun Ryu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: February 20, 2026. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/june.github.io/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/june.github.io/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/june.github.io/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script src="/june.github.io/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/june.github.io/assets/js/common.js?v=c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/june.github.io/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/june.github.io/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/june.github.io/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/june.github.io/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/june.github.io/assets/js/vanilla-back-to-top.min.js?v=f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/june.github.io/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/june.github.io/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/june.github.io/assets/js/search-data.js"></script> <script src="/june.github.io/assets/js/shortcut-key.js?v=ccc841c459bfc0e64c1c2b5acd10df02"></script> <script type="text/javascript">
      // ìš°í´ë¦­ ë°©ì§€
      document.oncontextmenu = function() {
        return false;
      };

      // ë“œë˜ê·¸ ë° ì„ íƒ ë°©ì§€
      document.onselectstart = function() {
        return false;
      };

      // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ ë°©ì§€ (F12, Ctrl+Shift+I ë“± ê°œë°œì ë„êµ¬ ë° ë³µì‚¬ ë°©ì§€)
      document.onkeydown = function(e) {
        if (e.ctrlKey && (e.keyCode === 67 || e.keyCode === 86 || e.keyCode === 85 || e.keyCode === 83)) {
          return false; // Ctrl+C, Ctrl+V, Ctrl+U(ì†ŒìŠ¤ë³´ê¸°), Ctrl+S ë°©ì§€
        }
      };
    </script> </body> </html>